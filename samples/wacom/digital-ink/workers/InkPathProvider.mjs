import"js-ext";import{vec2 as t,vec3 as e,vec4 as i,mat4 as s,quat2 as r}from"gl-matrix";import*as n from"poly2tri";import*as a from"clipper-lib";"function"==typeof Worker&&(Worker.prototype.on=function(t,e){this[`on${t}`]=i=>{let s="message"==t?i.data:i;e(s)}}),"function"==typeof DedicatedWorkerGlobalScope&&(DedicatedWorkerGlobalScope.prototype.on=function(t,e){this[`on${t}`]=i=>{let s="message"==t?i.data:i;e(s)}});class o{constructor(s,r,n,a){if(isNaN(s))throw new Error(`Invalid x found: ${s}`);if(isNaN(r))throw new Error(`Invalid y found: ${r}`);let o=[s,r];isFinite(n)&&(o.push(n),isFinite(a)&&o.push(a)),this.value=o.toFloat32Array(),Object.defineProperty(this,"x",{get:()=>this.value[0],set:t=>{this.value[0]=t},enumerable:!0}),Object.defineProperty(this,"y",{get:()=>this.value[1],set:t=>{this.value[1]=t},enumerable:!0}),2==o.length?this.vec=t:3==o.length?(this.vec=e,Object.defineProperty(this,"z",{get:()=>this.value[2],set:t=>{this.value[2]=t},enumerable:!0})):(this.vec=i,Object.defineProperty(this,"w",{get:()=>this.value[3],set:t=>{this.value[3]=t},enumerable:!0}))}add(t){t instanceof o||(t=o.fromPoint(t));let e=this.vec.create();return this.vec.add(e,this.value,t.value),o.fromPoint(e)}addSelf(t){return t instanceof o||(t=o.fromPoint(t)),this.vec.add(this.value,this.value,t.value),this}subtract(t){t instanceof o||(t=o.fromPoint(t));let e=this.vec.create();return this.vec.subtract(e,this.value,t.value),o.fromPoint(e)}subtractSelf(t){return t instanceof o||(t=o.fromPoint(t)),this.vec.subtract(this.value,this.value,t.value),this}multiply(t){t instanceof o||(t=o.fromPoint(t));let e=this.vec.create();return this.vec.multiply(e,this.value,t.value),o.fromPoint(e)}multiplySelf(t){return t instanceof o||(t=o.fromPoint(t)),this.vec.multiply(this.value,this.value,t.value),this}divide(t){t instanceof o||(t=o.fromPoint(t));let e=this.vec.create();return this.vec.divide(e,this.value,t.value),o.fromPoint(e)}divideSelf(t){return t instanceof o||(t=o.fromPoint(t)),this.vec.divide(this.value,this.value,t.value),this}scale(t){let e=this.vec.create();return this.vec.scale(e,this.value,t),o.fromPoint(e)}scaleSelf(t){return this.vec.scale(this.value,this.value,t),this}abs(){return new o(Math.abs(this.x),Math.abs(this.y),isFinite(this.z)?Math.abs(this.z):void 0,isFinite(this.w)?Math.abs(this.w):void 0)}absSelf(){return this.x=Math.abs(this.x),this.y=Math.abs(this.y),isFinite(this.z)&&(this.z=Math.abs(this.z)),isFinite(this.w)&&(this.w=Math.abs(this.w)),this}transform(t){if(!t)return this;let e=this.vec.create();return this.vec.transformMat4(e,this.value,t.toFloat32Array()),o.fromPoint(e)}transformSelf(t){return this.vec.transformMat4(this.value,this.value,t.toFloat32Array()),this}toFloat32Array(){return this.value}toJSON(){let t={x:this.x,y:this.y};return isFinite(this.z)&&(t.z=this.z,isFinite(this.w)&&(t.w=this.w)),t}toString(){return`point(${this.value.join(", ")})`}clone(){return o.fromPoint(this)}static fromPoint(t){return Array.isArray(t)||ArrayBuffer.isTypedArray(t)?new o(t[0],t[1],t[2],t[3]):new o(t.x,t.y,t.z,t.w)}}const h={m11:0,m12:1,m13:2,m14:3,m21:4,m22:5,m23:6,m24:7,m31:8,m32:9,m33:10,m34:11,m41:12,m42:13,m43:14,m44:15},l=h.m11,u=h.m12,c=h.m21,p=h.m22,d=h.m41,f=h.m42;class m{constructor(t=s.create(),e=m.MultiplicationType.PRE){Object.defineProperty(this,"value",{value:t,enumerable:!0}),Object.defineProperty(this,"multiplicationType",{value:e,enumerable:!0});let i=function(t,e){let i=h[t];this.value[i]=e};Object.defineProperty(this,"a",{get:()=>this.value[l],set:i.bind(this,"m11"),enumerable:!0}),Object.defineProperty(this,"b",{get:()=>this.value[u],set:i.bind(this,"m12"),enumerable:!0}),Object.defineProperty(this,"c",{get:()=>this.value[c],set:i.bind(this,"m21"),enumerable:!0}),Object.defineProperty(this,"d",{get:()=>this.value[p],set:i.bind(this,"m22"),enumerable:!0}),Object.defineProperty(this,"e",{get:()=>this.value[d],set:i.bind(this,"m41"),enumerable:!0}),Object.defineProperty(this,"f",{get:()=>this.value[f],set:i.bind(this,"m42"),enumerable:!0}),Object.defineProperty(this,"tx",{get:()=>this.value[d],set:i.bind(this,"m41"),enumerable:!0}),Object.defineProperty(this,"ty",{get:()=>this.value[f],set:i.bind(this,"m42"),enumerable:!0}),Object.defineProperty(this,"m11",{get:()=>this.value[0],set:i.bind(this,"m11"),enumerable:!0}),Object.defineProperty(this,"m12",{get:()=>this.value[1],set:i.bind(this,"m12"),enumerable:!0}),Object.defineProperty(this,"m13",{get:()=>this.value[2],set:i.bind(this,"m13"),enumerable:!0}),Object.defineProperty(this,"m14",{get:()=>this.value[3],set:i.bind(this,"m14"),enumerable:!0}),Object.defineProperty(this,"m21",{get:()=>this.value[4],set:i.bind(this,"m21"),enumerable:!0}),Object.defineProperty(this,"m22",{get:()=>this.value[5],set:i.bind(this,"m22"),enumerable:!0}),Object.defineProperty(this,"m23",{get:()=>this.value[6],set:i.bind(this,"m23"),enumerable:!0}),Object.defineProperty(this,"m24",{get:()=>this.value[7],set:i.bind(this,"m24"),enumerable:!0}),Object.defineProperty(this,"m31",{get:()=>this.value[8],set:i.bind(this,"m31"),enumerable:!0}),Object.defineProperty(this,"m32",{get:()=>this.value[9],set:i.bind(this,"m32"),enumerable:!0}),Object.defineProperty(this,"m33",{get:()=>this.value[10],set:i.bind(this,"m33"),enumerable:!0}),Object.defineProperty(this,"m34",{get:()=>this.value[11],set:i.bind(this,"m34"),enumerable:!0}),Object.defineProperty(this,"m41",{get:()=>this.value[12],set:i.bind(this,"m41"),enumerable:!0}),Object.defineProperty(this,"m42",{get:()=>this.value[13],set:i.bind(this,"m42"),enumerable:!0}),Object.defineProperty(this,"m43",{get:()=>this.value[14],set:i.bind(this,"m43"),enumerable:!0}),Object.defineProperty(this,"m44",{get:()=>this.value[15],set:i.bind(this,"m44"),enumerable:!0}),Object.defineProperty(this,"isIdentity",{get:()=>1==this.a&&0==this.b&&0==this.c&&1==this.d&&0==this.tx&&0==this.ty,enumerable:!0}),Object.defineProperty(this,"is2D",{get:()=>!(0!=this.m31||0!=this.m32||0!=this.m13||0!=this.m23||1!=this.m33||0!=this.m43||0!=this.m14||0!=this.m24||0!=this.m34||1!=this.m44),enumerable:!0}),Object.defineProperty(this,"translateX",{get:()=>this.tx}),Object.defineProperty(this,"translateY",{get:()=>this.ty}),Object.defineProperty(this,"skewX",{get:()=>Math.tan(this.c)}),Object.defineProperty(this,"skewY",{get:()=>Math.tan(this.b)}),Object.defineProperty(this,"scaleX",{get:()=>Math.sqrt(this.a*this.a+this.c*this.c)}),Object.defineProperty(this,"scaleY",{get:()=>Math.sqrt(this.d*this.d+this.b*this.b)}),Object.defineProperty(this,"rotation",{get:()=>Math.atan2(this.b,this.a)})}clone(){return new m(this.value.clone(),this.multiplicationType)}translate(t){return this.multiply(m.fromTranslate(t))}translateSelf(t){this.multiplySelf(m.fromTranslate(t))}rotate(t,e){return this.multiply(m.fromRotate(t,e))}rotateSelf(t,e){this.multiplySelf(m.fromRotate(t,e))}scale(t,e){return this.multiply(m.fromScale(t,e))}scaleSelf(t,e){this.multiplySelf(m.fromScale(t,e))}multiply(t){return this.multiplicationType==m.MultiplicationType.PRE?this.preMultiply(t):this.postMultiply(t)}preMultiply(t){let e=s.create();return s.multiply(e,t.toFloat32Array(),this.value),new m(e,this.multiplicationType)}postMultiply(t){let e=s.create();return s.multiply(e,this.value,t.toFloat32Array()),new m(e,this.multiplicationType)}multiplySelf(t){this.multiplicationType==m.MultiplicationType.PRE?this.preMultiplySelf(t):this.postMultiplySelf(t)}preMultiplySelf(t){s.multiply(this.value,t.toFloat32Array(),this.value)}postMultiplySelf(t){s.multiply(this.value,this.value,t.toFloat32Array())}invert(){let t=s.create();return s.invert(t,this.value),new m(t,this.multiplicationType)}invertSelf(){s.invert(this.value,this.value)}decompose(){return{translate:{x:this.tx,y:this.ty},rotate:{angle:Math.atan2(this.b,this.a)},skew:{angleX:Math.tan(this.c),angleY:Math.tan(this.b)},scale:{x:Math.sqrt(this.a*this.a+this.c*this.c),y:Math.sqrt(this.d*this.d+this.b*this.b)},matrix:this.toJSON()}}transformPoint(t){return o.fromPoint(t).transform(this)}toFloat32Array(){return this.value}toJSON(){return{a:this.a,b:this.b,c:this.c,d:this.d,tx:this.tx,ty:this.ty}}toString(t){if(t){let t=t=>((t<0?"":" ")+t.toPrecision(6)).substring(0,8);return" Matrix 4x4\n"+"-".repeat(39)+`\n${t(this.m11)}, ${t(this.m21)}, ${t(this.m31)}, ${t(this.m41)}`+`\n${t(this.m12)}, ${t(this.m22)}, ${t(this.m32)}, ${t(this.m42)}`+`\n${t(this.m13)}, ${t(this.m23)}, ${t(this.m33)}, ${t(this.m43)}`+`\n${t(this.m14)}, ${t(this.m24)}, ${t(this.m34)}, ${t(this.m44)}`}return this.is2D?`matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`:`matrix3d(${this.m11}, ${this.m12}, ${this.m13}, ${this.m14}, ${this.m21}, ${this.m22}, ${this.m23}, ${this.m24}, ${this.m31}, ${this.m32}, ${this.m33}, ${this.m34}, ${this.m41}, ${this.m42}, ${this.m43}, ${this.m44})`}static fromString(t,e){let i=s.create();if("none"!=t){let e=t.substring(0,t.indexOf("("));t=t.substring(t.indexOf("(")+1,t.indexOf(")")).split(/,\s*/g),"matrix3d"==e?(i[0]=parseFloat(t[0]),i[1]=parseFloat(t[1]),i[2]=parseFloat(t[2]),i[3]=parseFloat(t[3]),i[4]=parseFloat(t[4]),i[5]=parseFloat(t[5]),i[6]=parseFloat(t[6]),i[7]=parseFloat(t[7]),i[8]=parseFloat(t[8]),i[9]=parseFloat(t[9]),i[10]=parseFloat(t[10]),i[11]=parseFloat(t[11]),i[12]=parseFloat(t[12]),i[13]=parseFloat(t[13]),i[14]=parseFloat(t[14]),i[15]=parseFloat(t[15])):(i[l]=parseFloat(t[0]),i[u]=parseFloat(t[1]),i[c]=parseFloat(t[2]),i[p]=parseFloat(t[3]),i[d]=parseFloat(t[4]),i[f]=parseFloat(t[5]))}return new m(i,e)}static fromMatrix(t,e){if(!t)throw new Error("data not found, Matrix instance creation failed");if("function"==typeof t)throw new Error("data type function is not allowed");if(t instanceof m)return t;if(Array.isArray(t)&&(t=new Float32Array(t)),t instanceof Float32Array)return new m(t,e);if("string"==typeof t)return m.fromString(t,e);let i=s.create(),r=Object.assign({},t);return isFinite(t.a)&&(r.m11=t.a),isFinite(t.b)&&(r.m12=t.b),isFinite(t.c)&&(r.m21=t.c),isFinite(t.d)&&(r.m22=t.d),isFinite(t.tx)?r.m41=t.tx:isFinite(t.e)?r.m41=t.e:isFinite(t.dx)&&(r.m41=t.dx),isFinite(t.ty)?r.m42=t.ty:isFinite(t.f)?r.m42=t.f:isFinite(t.dy)&&(r.m42=t.dy),isFinite(r.m11)&&(i[0]=r.m11),isFinite(r.m12)&&(i[1]=r.m12),isFinite(r.m13)&&(i[2]=r.m13),isFinite(r.m14)&&(i[3]=r.m14),isFinite(r.m21)&&(i[4]=r.m21),isFinite(r.m22)&&(i[5]=r.m22),isFinite(r.m23)&&(i[6]=r.m23),isFinite(r.m24)&&(i[7]=r.m24),isFinite(r.m31)&&(i[8]=r.m31),isFinite(r.m32)&&(i[9]=r.m32),isFinite(r.m33)&&(i[10]=r.m33),isFinite(r.m34)&&(i[11]=r.m34),isFinite(r.m41)&&(i[12]=r.m41),isFinite(r.m42)&&(i[13]=r.m42),isFinite(r.m43)&&(i[14]=r.m43),isFinite(r.m44)&&(i[15]=r.m44),new m(i,e||t.multiplicationType)}static fromTranslate(t){let e=isFinite(t)?{tx:t,ty:t}:{tx:t.x,ty:t.y};return m.fromMatrix(e)}static fromRotate(t,e){let i=Math.sin(t),s=Math.cos(t),r={a:s,b:i,c:-i,d:s};return e&&(r.tx=e.x-e.x*s+e.y*i,r.ty=e.y-e.x*i-e.y*s),m.fromMatrix(r)}static fromScale(t,e){isFinite(t)&&(t={x:t,y:t});let i={a:t.x,d:t.y};return e&&(i.tx=e.x-e.x*t.x,i.ty=e.y-e.y*t.y),m.fromMatrix(i)}static fromPoints(t,e){if(!Array.isArray(t)||!Array.isArray(e))throw new Error("Expected input type Array requirement not satisfied");if(3!=t.length||3!=e.length)throw new Error("Expected input size 3 requirement not satisfied");let i=m.fromMatrix({m11:t[0].x,m21:t[1].x,m31:t[2].x,m12:t[0].y,m22:t[1].y,m32:t[2].y,m13:1,m23:1,m33:1}),s=m.fromMatrix({m11:e[0].x,m21:e[1].x,m31:e[2].x,m12:e[0].y,m22:e[1].y,m32:e[2].y,m13:1,m23:1,m33:1}),r=i.invert().preMultiply(s);return m.fromMatrix({a:r.m11,b:r.m12,c:r.m21,d:r.m22,tx:r.m31,ty:r.m32})}static multiply(t,e){let i=s.create();return s.multiply(i,t.value,e.value),new m(i)}}m.MultiplicationType=Object.freeze({PRE:"PRE",POST:"POST"});class y extends o{static defaults={size:1,rotation:0,scaleX:1,scaleY:1,scaleZ:1,offsetX:0,offsetY:0,offsetZ:0};constructor(t,e,i,s={}){super(t,e,i),this.red=s.red,this.green=s.green,this.blue=s.blue,this.alpha=s.alpha,this.size=s.size||y.defaults.size,this.rotation=s.rotation||y.defaults.rotation,this.scaleX=s.scaleX||y.defaults.scaleX,this.scaleY=s.scaleY||y.defaults.scaleY,this.scaleZ=isFinite(i)?s.scaleZ||y.defaults.scaleZ:void 0,this.offsetX=s.offsetX||y.defaults.offsetX,this.offsetY=s.offsetY||y.defaults.offsetY,this.offsetZ=isFinite(i)?s.offsetZ||y.defaults.offsetZ:void 0,this.dX,this.dY}static createInstance(t,e,i,s=0){let r=new y(0,0,t.includes(y.Property.Z)?0:void 0);return i&&r.fill(s,i,t,e),r}fill(t,e,i,s={}){let r={},n=t*i.length;i.forEach(((t,i)=>y.setProperty(r,t,e[n+i]))),this.x=r.x,this.y=r.y,this.z=r.z,this.red=isFinite(r.red)?r.red:s.red,this.green=isFinite(r.green)?r.green:s.green,this.blue=isFinite(r.blue)?r.blue:s.blue,this.alpha=isFinite(r.alpha)?r.alpha:s.alpha,this.size=r.size||s.size||y.defaults.size,this.rotation=r.rotation||s.rotation||y.defaults.rotation,this.scaleX=r.scaleX||s.scaleX||y.defaults.scaleX,this.scaleY=r.scaleY||s.scaleY||y.defaults.scaleY,this.scaleZ=isFinite(r.z)?r.scaleZ||s.scaleZ||y.defaults.scaleZ:void 0,this.offsetX=r.offsetX||s.offsetX||y.defaults.offsetX,this.offsetY=r.offsetY||s.offsetY||y.defaults.offsetY,this.offsetZ=isFinite(r.z)?r.offsetZ||s.offsetZ||y.defaults.offsetZ:void 0,this.dX=r.dX,this.dY=r.dY}getProperty(t){switch(t){case y.Property.X:return this.x;case y.Property.Y:return this.y;case y.Property.Z:return this.z;case y.Property.RED:return this.red;case y.Property.GREEN:return this.green;case y.Property.BLUE:return this.blue;case y.Property.ALPHA:return this.alpha;case y.Property.SIZE:return this.size;case y.Property.ROTATION:return this.rotation;case y.Property.SCALE_X:return this.scaleX;case y.Property.SCALE_Y:return this.scaleY;case y.Property.SCALE_Z:return this.scaleZ;case y.Property.OFFSET_X:return this.offsetX;case y.Property.OFFSET_Y:return this.offsetY;case y.Property.OFFSET_Z:return this.offsetZ;case y.Property.D_X:return this.dX;case y.Property.D_Y:return this.dY;default:throw console.warn(t),new Error("Invalid property found")}}setProperty(t,e){y.setProperty(this,t,e)}static setProperty(t,e,i){switch(e){case y.Property.X:t.x=i;break;case y.Property.Y:t.y=i;break;case y.Property.Z:t.z=i;break;case y.Property.RED:t.red=i;break;case y.Property.GREEN:t.green=i;break;case y.Property.BLUE:t.blue=i;break;case y.Property.ALPHA:t.alpha=i;break;case y.Property.SIZE:t.size=i;break;case y.Property.ROTATION:t.rotation=i;break;case y.Property.SCALE_X:t.scaleX=i;break;case y.Property.SCALE_Y:t.scaleY=i;break;case y.Property.SCALE_Z:t.scaleZ=i;break;case y.Property.OFFSET_X:t.offsetX=i;break;case y.Property.OFFSET_Y:t.offsetY=i;break;case y.Property.OFFSET_Z:t.offsetZ=i;break;case y.Property.D_X:t.dX=i;break;case y.Property.D_Y:t.dY=i;break;default:throw console.warn(e),new Error("Invalid property found")}}transform(t){if(!(t instanceof m))throw new Error(`matrix is instance of ${t.constructor.name} - it should be instance of Matrix. Use Matrix.fromMatrix method to convert.`);let e=t.scaleX,i=t.rotation;this.transformSelf(t),this.size*=e,this.rotation+=i,this.scaleX*=e,this.scaleY*=e,isFinite(this.z)&&(this.scaleZ*=e),this.offsetX*=e,this.offsetY*=e,isFinite(this.z)&&(this.offsetZ*=e)}toArray(t){return t.map((t=>{let e=this.getProperty(t);if(null==e||isNaN(e))throw new Error(`Property ${t.name} has invalid value ${e}`);return e}))}toJSON(){let t={};return y.Property.values.forEach((e=>{let i=this.getProperty(e);null!=i&&isFinite(i)&&(t[e.name]=this.getProperty(e))})),t}}Object.defineEnum(y,"Property",["X","Y","Z","RED","GREEN","BLUE","ALPHA","SIZE","ROTATION","SCALE_X","SCALE_Y","SCALE_Z","OFFSET_X","OFFSET_Y","OFFSET_Z","D_X","D_Y"]);class g{constructor(t,e,i,s=1){if(this.red=t,this.green=e,this.blue=i,this.alpha=s,s<0||s>1)throw new Error(`Invalid alpha ${s} found. The value must be in the interval [0, 1].`);Object.defineProperty(this,"hex",{get:()=>`#${this.red.toString(16).pad(2,"0")}${this.green.toString(16).pad(2,"0")}${this.blue.toString(16).pad(2,"0")}${Math.round(255*this.alpha).toString(16).pad(2,"0")}`,enumerable:!0})}premultiply(){return{red:this.red/255*this.alpha,green:this.green/255*this.alpha,blue:this.blue/255*this.alpha,alpha:this.alpha}}static postdivide(t,e,i,s){let r=parseInt(255*t/s),n=parseInt(255*e/s),a=parseInt(255*i/s);return new g(r,n,a,s)}equals(t){return t&&this.red==t.red&&this.green==t.green&&this.blue==t.blue&&this.alpha==t.alpha}toRGB(){return 1==this.alpha?this:new g(this.red,this.green,this.blue)}toRGBA(t){return new g(this.red,this.green,this.blue,t)}toHSLA(){let t=this.red/255,e=this.green/255,i=this.blue/255,s=Math.min(t,e,i),r=Math.max(t,e,i),n=0,a=0,o=(r+s)/2;if(r!=s){let h=r-s;switch(a=h/(1-Math.abs(2*o-1)),r){case t:n=(e-i)/h%6;break;case e:n=(i-t)/h+2;break;case i:n=(t-e)/h+4}}return n*=60,n<0&&(n+=360),{hue:parseFloat(n.toFixed(0)),saturation:parseFloat((100*a).toFixed(2)),lightness:parseFloat((100*o).toFixed(2)),alpha:this.alpha}}toArray(){return[this.red,this.green,this.blue,this.alpha]}toJSON(){return{red:this.red,green:this.green,blue:this.blue,alpha:this.alpha}}toString(){return 1==this.alpha?`rgb(${this.red}, ${this.green}, ${this.blue})`:`rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`}static isColor(t){return t&&isFinite(t.red)&&isFinite(t.green)&&isFinite(t.blue)}static fromColor(t){let e,i,s,r;if("string"==typeof t)if(t.startsWith("rgb"))t=t.substring(t.indexOf("(")+1,t.indexOf(")")).split(/,\s*/g),e=parseInt(t[0]),i=parseInt(t[1]),s=parseInt(t[2]),r=t[3]?parseInt(t[3]):1;else{if(!t.startsWith("#"))throw new Error(`Unknown input found: ${t}. Expected data starts with rgba, rgb or #.`);t=t.substring(1),e=parseInt(t.substring(0,2),16),i=parseInt(t.substring(2,4),16),s=parseInt(t.substring(4,6),16),r=8==t.length?parseInt(t.substring(6,8),16)/255:1}else Array.isArray(t)?(e=t[0],i=t[1],s=t[2],r=t[3]):(e=t.red,i=t.green,s=t.blue,r=t.alpha);return new g(e,i,s,r)}static fromHSLA(t=0,e=0,i=0,s){t/=60,e/=100,i/=100;let r=(1-Math.abs(2*i-1))*e,n=r*(1-Math.abs(t%2-1)),a=0,o=0,h=0;t>=0&&t<1?(a=r,o=n):t>=1&&t<2?(a=n,o=r):t>=2&&t<3?(o=r,h=n):t>=3&&t<4?(o=n,h=r):t>=4&&t<5?(a=n,h=r):(a=r,h=n);let l=i-r/2;return a+=l,o+=l,h+=l,new g(Math.round(255*a),Math.round(255*o),Math.round(255*h),s)}static random(t){return new g(Math.randomInt(0,255),Math.randomInt(0,255),Math.randomInt(0,255),t?Math.random():1)}}g.TRANSPERENT=new g(0,0,0,0),g.BLACK=new g(0,0,0,1),g.WHITE=new g(255,255,255,1),g.RED=new g(255,0,0,1),g.GREEN=new g(0,255,0,1),g.BLUE=new g(0,0,255,1);let P={longToByteArray(t){let e=[0,0,0,0,0,0,0,0];for(let i=0;i<e.length;i++){let s=255&t;e[i]=s,t=(t-s)/256}return e},byteArrayToLong(t){let e=0;for(let i=t.length-1;i>=0;i--)e=256*e+t[i];return e},crc32:function(){let t=new Uint32Array(256);for(let e=256;e--;){let i=e;for(let t=8;t--;)i=1&i?3988292384^i>>>1:i>>>1;t[e]=i}return function(e){let i=-1;for(let s=0,r=e.length;s<r;s++)i=i>>>8^t[255&i^e[s]];return(-1^i)>>>0}}(),encodeBitMask(t=[]){if(0==t.length)return 0;let e="",i=Math.max(...t);for(let s=1;s<=i;s++)e+=t.includes(s)?"1":"0";return parseInt(e.split("").reverse().join(""),2)},decodeBitMask(t){let e=[],i=t.toString(2).split("").reverse();for(let t=0;t<i.length;t++)1==i[t]&&e.push(t+1);return e},mapTo:(t,e,i)=>i.min+(P.clamp(t,e)-e.min)/(e.max-e.min)*(i.max-i.min),clamp:(t,e)=>Math.min(Math.max(t,e.min),e.max),debounce(t,e){let i=null;return function(){let s=this,r=arguments;clearTimeout(i),i=setTimeout((function(){t.apply(s,r)}),e)}},comparator(){let t=Array.prototype.slice.call(arguments),e=function(t,e,i){return e.replace("[",".").replace("]","").split(".").forEach((e=>t=t[e])),i?t.toLowerCase():t};return function(i,s){return t.map((t=>function(t,e,i){let s="asc"===i?1:-1;return t>e?1*s:t<e?-1*s:0}(e(i,t.sortBy,t.ignoreCase),e(s,t.sortBy,t.ignoreCase),t.sortOrder))).reduceRight((function(t,e){return e||t}))}},isValidURL(t){if("string"!=typeof t)return!1;try{return new URL(t),!0}catch(t){return!1}},getPropName(t,e){let i=t.split("_"),s=i.first.toLowerCase();e&&(s=s.substring(0,1).toUpperCase()+s.substring(1));for(let t=1;t<i.length;t++)s+=i[t].substring(0,1),s+=i[t].substring(1).toLowerCase();return s},getEnumValueName(t){let e="";for(let i=0;i<t.length;i++)i>0&&t[i]!=t[i].toLowerCase()&&(e+="_"),e+=t[i];return e.toUpperCase()}};class b{constructor(t,e,i={}){this.layout=t,this.pointProps=e,this.sheet={};let s={};Object.defineProperties(s,{size:{get:this.getComputed.bind(this,"size"),set:this.setStyle.bind(this,"size"),enumerable:!0},red:{get:this.getComputed.bind(this,"red"),set:this.setStyle.bind(this,"red"),enumerable:!0},green:{get:this.getComputed.bind(this,"green"),set:this.setStyle.bind(this,"green"),enumerable:!0},blue:{get:this.getComputed.bind(this,"blue"),set:this.setStyle.bind(this,"blue"),enumerable:!0},alpha:{get:this.getComputed.bind(this,"alpha"),set:this.setStyle.bind(this,"alpha"),enumerable:!0},rotation:{get:this.getComputed.bind(this,"rotation"),set:this.setStyle.bind(this,"rotation"),enumerable:!0},scaleX:{get:this.getComputed.bind(this,"scaleX"),set:this.setStyle.bind(this,"scaleX"),enumerable:!0},scaleY:{get:this.getComputed.bind(this,"scaleY"),set:this.setStyle.bind(this,"scaleY"),enumerable:!0},scaleZ:{get:this.getComputed.bind(this,"scaleZ"),set:this.setStyle.bind(this,"scaleZ"),enumerable:!0},offsetX:{get:this.getComputed.bind(this,"offsetX"),set:this.setStyle.bind(this,"offsetX"),enumerable:!0},offsetY:{get:this.getComputed.bind(this,"offsetY"),set:this.setStyle.bind(this,"offsetY"),enumerable:!0},offsetZ:{get:this.getComputed.bind(this,"offsetZ"),set:this.setStyle.bind(this,"offsetZ"),enumerable:!0},color:{get:this.getComputed.bind(this,"color"),set:this.setStyle.bind(this,"color"),enumerable:!0},blendMode:{get:this.getComputed.bind(this,"blendMode"),set:this.setStyle.bind(this,"blendMode"),enumerable:!0},visibility:{get:this.getComputed.bind(this,"visibility"),set:this.setStyle.bind(this,"visibility"),enumerable:!0},reset:{value:t=>{t&&(i=t),this.clear(),Object.keys(i).forEach((t=>this.setStyle(t,i[t])))}},clear:{value:this.clear.bind(this)}}),this.style=Object.freeze(s),this.style.reset(i)}setStyle(t,e){if(null==e&&(e=void 0),b.validate(this.layout,t,e),"color"==t&&e)return this.sheet.red=e.red,this.sheet.green=e.green,this.sheet.blue=e.blue,void(this.sheet.alpha=e.alpha);null==e?delete this.sheet[t]:this.sheet[t]=e}getStyle(t){let e=this.sheet[t];return"visibility"==t?"boolean"!=typeof e&&(e=!0):"color"==t&&g.isColor(this.sheet)&&(e=g.fromColor(this.sheet)),e}getComputed(t){let e=this.getStyle(t);if(null==e)if("color"==t){let t={red:isFinite(this.sheet.red)?this.sheet.red:this.pointProps.red,green:isFinite(this.sheet.green)?this.sheet.green:this.pointProps.green,blue:isFinite(this.sheet.blue)?this.sheet.blue:this.pointProps.blue,alpha:isFinite(this.sheet.alpha)?this.sheet.alpha:this.pointProps.alpha};g.isColor(t)&&(e=g.fromColor(t))}else e=this.pointProps[t];return e}clear(){this.sheet={}}static validate(t,e,i,s){let r;if(i&&t.includes(y.Property[P.getEnumValueName(e)])){if(!s)throw new Error(`Property ${e} value ${i} is not applicable. This is a dynamic property and is part of the layout.`);console.warn(`Property ${e} value ${i} is not applicable. This is a dynamic property and is part of the layout.`),i=void 0}if("color"==e)!i||i instanceof g||(r=`Property ${e} is not an instance of Color`);else if("blendMode"==e)""==i&&(i=void 0);else if("number"==typeof i)if("size"==e)i<0?r=`Property ${e} with value ${i} is not allowed. Value should be a positive number.`:0==i&&(i=void 0);else if("red"==e||"green"==e||"blue"==e||"alpha"==e){let t="alpha"==e?{min:0,max:1}:{min:0,max:255};i>=t.min&&i<=t.max||(r=`Property ${e} with value ${i} is out of range. Allowd range: [${t.min}, ${t.max}].`)}else"rotation"==e?0==i&&(i=void 0):"scattering"==e&&i<0&&(i=void 0);if(r)throw new Error(r);return i}}const E=[y.Property.X,y.Property.Y];class w{constructor(t,e={},i=E){if(w.name==this.constructor.name)throw new Error("Path class is abstract. Constructor is not accessible.");if(t%i.length!=0)throw new Error("Points length do not matches with given layout");if(Object.defineProperties(this,{layout:{value:Object.freeze(i)},stride:{value:i.length},length:{value:t/i.length}}),!Object.isSealed(e))for(let t in e)void 0!==e[t]&&(e[t]=b.validate(this.layout,t,e[t],!0));i.includes(y.Property.ROTATION)||"rotation"in e||(e.rotation=void 0),i.includes(y.Property.SIZE)||e.size||(e.size=1),Object.defineProperty(this,"pointProps",{value:Object.seal(e)}),i.forEach(((t,e)=>{let i=P.getPropName(t.name,!0);Object.defineProperty(this,`setPoint${i}`,{value:this.setPointPropertyValue.bind(this,e)}),Object.defineProperty(this,`getPoint${i}`,{value:this.getPointPropertyValue.bind(this,e)})}))}setPointPropertyValue(t,e,i){if(isNaN(e))throw new Error("Point index is required");if(e>=this.length||e<0)throw new Error(`Index ${t} out of range - (0, ${this.length-1})`);if(isNaN(i))throw new Error("value is required");this.points[e*this.layout.length+t]=i}getPointPropertyValue(t,e){if(isNaN(e))throw new Error("Point index is required");if(e>=this.length||e<0)throw new Error(`Index ${t} out of range - (0, ${this.length-1})`);return this.points[e*this.layout.length+t]}setPoint(t,e){let i=t*this.stride;this.layout.forEach(((t,s)=>this.points[i+s]=e.getProperty(t)))}getPoint(t,e=this.pointProps){if(t>=this.length||t<0)throw new Error(`Index ${t} out of range - (0, ${this.length-1})`);return y.createInstance(this.layout,e,this.points,t)}getChannelData(t){let e=new([y.Property.RED,y.Property.GREEN,y.Property.BLUE].includes(t)?Uint8Array:Float32Array)(this.length),i=this.layout.indexOf(t);if(-1==i)throw new Error(`Property ${t.name} is not part from the spline layout ${this.layout.map((t=>t.name)).join(", ")}`);for(let t=0;t<this.length;t++)e[t]=this.points[t*this.stride+i];return e}transform(t){let e=t.scaleX,s=t.rotation;for(let r=0;r<this.length;r++){let n=r*this.stride,a=i.fromValues(this.getPointX(r),this.getPointY(r),0,1);i.transformMat4(a,a,t.value);for(let t=0;t<this.stride;t++){let i=n+t;switch(this.layout[t]){case y.Property.X:this.points[i]=a[0]/a[3];break;case y.Property.Y:this.points[i]=a[1]/a[3];break;case y.Property.Z:this.points[i]=a[2]/a[3];break;case y.Property.ROTATION:this.points[i]+=s;break;case y.Property.SIZE:case y.Property.SCALE_X:case y.Property.SCALE_Y:case y.Property.SCALE_Z:case y.Property.OFFSET_X:case y.Property.OFFSET_Y:case y.Property.OFFSET_Z:this.points[i]*=e}}}this.layout.includes(y.Property.ROTATION)||(this.pointProps.rotation=0==s?void 0:s)}clone(){throw new Error("Path.clone()) is abstract and should be implemented")}slice(t){throw new Error("Path.slice(fragment)) is abstract and should be implemented")}slicePoints(t,e,i=0,s=1){throw new Error("Path.slicePoints(fromPointIndex, toPointIndex, fromTValue, toTValue)) is abstract and should be implemented")}toSVGPath(){let t=[];for(let e=0;e<this.length;e++)t.push(`${this.getPointX(e)},${this.getPointY(e)}`);return`M ${t.join(" L ")} Z`}toJSON(){throw new Error("Path.toJSON() is abstract and should be implemented")}static fromJSON(t){throw new Error("static Path.fromJSON(data) is abstract and should be implemented")}static fromRect(t,e){return new this([t.left,t.top,t.right,t.top,t.right,t.bottom,t.left,t.bottom,t.left,t.top],e)}}class S{constructor(t,e,i,s=0,r=1){Object.defineProperties(this,{path:{value:t,enumerable:!0},fromPointIndex:{value:e,enumerable:!0},toPointIndex:{value:i,enumerable:!0},fromTValue:{value:s,enumerable:!0},toTValue:{value:r,enumerable:!0}}),this.validate()}validate(){S.validate(this.path,this.fromPointIndex,this.toPointIndex,this.fromTValue,this.toTValue)}overlaps(t){if(t.path!=this.path)return!1;let e=t.fromPointIndex<this.toPointIndex-3||t.fromPointIndex==this.toPointIndex-3&&t.fromTValue<=this.toTValue,i=t.toPointIndex-3>this.fromPointIndex||t.toPointIndex-3==this.fromPointIndex&&t.toTValue>=this.fromTValue;return e&&i}toPath(){return this.path.slice(this)}toString(){return`fragment${this.path.id?`{${this.path.id}}`:""}(${this.fromPointIndex}, ${this.toPointIndex}, ${this.fromTValue}, ${this.toTValue})`}static validate(t,e,i,s=0,r=1){if(e<0)throw new Error(`Invalid fragment fromPointIndex ${e} found. The value must be non-negative.`);if(i>t.length-1)throw new Error(`Invalid fragment toPointIndex ${i} found. Last point in path index is ${t.length-1}.`);if(isFinite(t.ts)&&isFinite(t.tf)){if(s<0||s>=1)throw new Error(`Invalid fragment fromTValue ${s} found. The value must be in the interval [0, 1).`);if(r<=0||r>1)throw new Error(`Invalid fragment toTValue ${r} found. The value must be in the interval (0, 1].`);if(i+1-e<4)throw new Error(`Invalid fragment points range {${e}, ${i}} found. At least 4 points are needed to define spline.`);if(e==i-3&&r<=s)throw new Error(`Invalid fragment T values range {${s}, ${r}} found. The value must be in the interval (fromTValue, 1].`)}}}y.Property.X,y.Property.Y;class v extends w{constructor(t,e,i){super(t.length,e,i),Array.isArray(t)&&(t=Object.seal(t)),Object.defineProperty(this,"points",{get:()=>t,enumerable:!0})}clone(){return new v(this.points.clone(),Object.clone(this.pointProps),this.layout.slice())}slice(t){let e=this.slicePoints(t.fromPointIndex,t.toPointIndex);return new v(e,Object.clone(this.pointProps),this.layout.slice())}slicePoints(t,e,i=0,s=1){return S.validate(this,t,e,i,s),this.points.slice(t*this.stride,(e+1)*this.stride)}toJSON(){return{type:"ArrayPath",points:this.points,pointProps:this.pointProps,layout:this.layout.map((t=>t.name))}}static fromJSON(t){if("ArrayPath"!=t.type)throw new Error(`ArrayPath deserialization failed. JSON type is ${t.type}, expected ArrayPath.`);return new v(t.points,t.pointProps,t.layout.map((t=>y.Property[t])))}}class I{static encode(t,e=I.Encoding.AUTO){let i;if(e==I.Encoding.AUTO&&(e="undefined"==typeof Buffer?"undefined"!=typeof SharedArrayBuffer&&t.buffer instanceof SharedArrayBuffer?I.Encoding.NONE:I.Encoding.ARRAY:I.Encoding.BUFFER),e==I.Encoding.NONE)i=t;else if(e==I.Encoding.ARRAY)i=t.toArray();else{if("undefined"==typeof Buffer)throw new Error("Buffer not found, unable to serialize. Please provide Buffer in global scope.");let s=Buffer.from(t.buffer);switch(e){case I.Encoding.BUFFER:i=s.toJSON();break;case I.Encoding.BASE64:i=s.toString("base64");break;default:throw new Error(`Invalid encoding provided: ${e.name}`)}}return{encoding:e.name,type:t.constructor.name,content:i}}static decode(t){let e,i=I.Encoding[t.encoding];if(i==I.Encoding.NONE)e=t.content;else if(i==I.Encoding.ARRAY)e=t.content.toFloat32Array();else{if("undefined"==typeof Buffer)throw new Error("Buffer not found, unable to deserialize. Please provide Buffer in global scope.");let s;switch(i){case I.Encoding.BUFFER:s=Buffer.from(t.content);break;case I.Encoding.BASE64:s=Buffer.from(t.content,"base64");break;default:throw new Error(`Invalid encoding provided: ${i.name}`)}let r=new Uint8Array(s);e=new globalThis[t.type](r.buffer)}return e}static isTypedArrayData(t){return t&&t.encoding&&t.type&&t.type.endsWith("Array")}}Object.defineEnum(I,"Encoding",["AUTO","NONE","ARRAY","BUFFER","BASE64"]);class O extends w{constructor(t,e,i){super(t.length,e,i),t=Float32Array.createSharedInstance(t),Object.defineProperty(this,"points",{get:()=>t,enumerable:!0}),Object.defineProperty(this,"buffer",{get:()=>t.buffer,set:e=>{if("undefined"!=typeof SharedArrayBuffer&&this.points.buffer instanceof SharedArrayBuffer)throw new Error("Underlying buffer is SharedArrayBuffer and cannot be restored");if(this.points.buffer.byteLength>0)throw new Error("Cannot restore buffer when underlying buffer is not empty");t=new Float32Array(e)}})}clone(t=!1){if(0==this.buffer.byteLength)throw new Error("Path buffer is empty. Data could be processing under some thread. Clone failed.");return t?new v(this.points.toArray(),Object.clone(this.pointProps),this.layout.slice()):new O(this.points.clone(),Object.clone(this.pointProps),this.layout.slice())}slice(t){let e=this.slicePoints(t.fromPointIndex,t.toPointIndex);return new O(e,Object.clone(this.pointProps),this.layout.slice())}slicePoints(t,e,i=0,s=1){let r;if(S.validate(this,t,e,i,s),"undefined"!=typeof SharedArrayBuffer&&this.buffer instanceof SharedArrayBuffer){let i=this.points.subarray(t*this.stride,(e+1)*this.stride),s=new SharedArrayBuffer(i.length*Float32Array.BYTES_PER_ELEMENT);r=new Float32Array(s),r.set(i)}else r=this.points.slice(t*this.stride,(e+1)*this.stride);return r}toJSON(){return{type:"SharedPath",points:I.encode(this.points,this.encoding),pointProps:this.pointProps,layout:this.layout.map((t=>t.name))}}static fromJSON(t){if("SharedPath"!=t.type)throw new Error(`SharedPath deserialization failed. JSON type is ${t.type}, expected SharedPath.`);return new O(I.decode(t.points),t.pointProps,t.layout.map((t=>y.Property[t])))}}class T{constructor(t,e,i,s){let r=t,n=e,a=t+i,o=e+s;Object.defineProperties(this,{left:{value:r,enumerable:!0},x:{value:t,enumerable:!0},bottom:{value:n,enumerable:!0},y:{value:e,enumerable:!0},right:{value:a,enumerable:!0},top:{value:o,enumerable:!0},width:{value:i,enumerable:!0},height:{value:s,enumerable:!0}})}union(t){if(t&&!(t instanceof T))throw new TypeError("rect must be instance of RectGL");return t?T.ofEdges(Math.min(this.left,t.left),Math.min(this.bottom,t.bottom),Math.max(this.right,t.right),Math.max(this.top,t.top)):this}intersect(t){if(t&&!(t instanceof T))throw new TypeError("rect must be instance of RectGL");if(!t)return null;let e=T.ofEdges(Math.max(this.left,t.left),Math.max(this.bottom,t.bottom),Math.min(this.right,t.right),Math.min(this.top,t.top));return e.width>0&&e.height>0?e:null}ceil(){return T.ofEdges(Math.floor(this.left),Math.floor(this.bottom),Math.ceil(this.right),Math.ceil(this.top))}floor(){return T.ofEdges(Math.ceil(this.left),Math.ceil(this.bottom),Math.floor(this.right),Math.floor(this.top))}transform(t){if(!t)return this;let e=o.fromPoint({x:this.left,y:this.bottom}).transform(t),i=o.fromPoint({x:this.right,y:this.bottom}).transform(t),s=o.fromPoint({x:this.left,y:this.top}).transform(t),r=o.fromPoint({x:this.right,y:this.top}).transform(t),n=Math.min(s.x,r.x,e.x,i.x),a=Math.min(s.y,r.y,e.y,i.y),h=Math.max(s.x,r.x,e.x,i.x),l=Math.max(s.y,r.y,e.y,i.y);return T.ofEdges(n,a,h,l)}toQuad(t){let e;if(t){let i=o.fromPoint({x:this.left,y:this.bottom}).transform(t),s=o.fromPoint({x:this.right,y:this.bottom}).transform(t),n=o.fromPoint({x:this.left,y:this.top}).transform(t),a=o.fromPoint({x:this.right,y:this.top}).transform(t);e=r.fromValues(i.x,i.y,s.x,s.y,n.x,n.y,a.x,a.y)}else e=r.fromValues(this.left,this.bottom,this.right,this.bottom,this.left,this.top,this.right,this.top);return e}toString(){return`gl-rect(${this.x}, ${this.y}, ${this.width}, ${this.height})`}static ofEdges(t,e,i,s){return new T(t,e,i-t,s-e)}static calculateBrushGLSegmentBounds(t,e=0,i){let s,r=.5*t.size,n=Math.abs(e*r);if(i){s=new o(t.x,t.y,t.x,t.z).transform(i)}else s=t;let a=s.x,h=s.y,l=t.scaleX*r,u=t.scaleY*r,c=t.offsetX,p=-t.offsetY,d=Math.cos(t.rotation),f=Math.sin(t.rotation),m=Number.MAX_SAFE_INTEGER,y=Number.MIN_SAFE_INTEGER,g=Number.MAX_SAFE_INTEGER,P=Number.MIN_SAFE_INTEGER;return[{x:-1,y:-1},{x:1,y:-1},{x:-1,y:1},{x:1,y:1}].forEach((t=>{t.x=t.x*l+c,t.y=t.y*u+p;let e=d*t.x+f*t.y+a,i=-f*t.x+d*t.y+h,s=e-n;m=Math.min(m,s),y=Math.max(y,s),s=e+n,m=Math.min(m,s),y=Math.max(y,s);let r=i-n;g=Math.min(g,r),P=Math.max(P,r),r=i+n,g=Math.min(g,r),P=Math.max(P,r)})),T.ofEdges(m,g,y,P)}}Object.defineProperty(T,"SQURE",{value:Object.freeze([Object.freeze({x:-1,y:-1}),Object.freeze({x:1,y:-1}),Object.freeze({x:-1,y:1}),Object.freeze({x:1,y:1})]),enumerable:!0});class A{constructor(t,e,i,s){let r,n,a=t,o=e,h=t+i,l=e+s;Object.defineProperties(this,{left:{value:a,enumerable:!0},top:{value:o,enumerable:!0},right:{value:h,enumerable:!0},bottom:{value:l,enumerable:!0},x:{value:t,enumerable:!0},y:{value:e,enumerable:!0},width:{value:i,enumerable:!0},height:{value:s,enumerable:!0},size:{get:()=>(r||(r={width:i,height:s}),r),enumerable:!0},center:{get:()=>(n||(n={x:(a+h)/2,y:(o+l)/2}),n),enumerable:!0}})}union(t){return t?A.ofEdges(Math.min(this.left,t.left),Math.min(this.top,t.top),Math.max(this.right,t.right),Math.max(this.bottom,t.bottom)):this}intersect(t){if(!t)return null;let e=A.ofEdges(Math.max(this.left,t.left),Math.max(this.top,t.top),Math.min(this.right,t.right),Math.min(this.bottom,t.bottom));return e.width>0&&e.height>0?e:null}intersects(t){return this.left<=t.right&&this.right>=t.left&&this.top<=t.bottom&&this.bottom>=t.top}ceil(t){let e=Math.floor(this.left),i=Math.floor(this.top),s=Math.ceil(this.right),r=Math.ceil(this.bottom);if(t){let t=s-e,n=r-i;t+=t%2,n+=n%2,s=e+t,r=i+n}return A.ofEdges(e,i,s,r)}floor(t){let e=Math.ceil(this.left),i=Math.ceil(this.top),s=Math.floor(this.right),r=Math.floor(this.bottom);if(t){let t=s-e,n=r-i;t-=t%2,n-=n%2,s=e+t,r=i+n}return A.ofEdges(e,i,s,r)}contains(t){return this.left<=t.x&&this.right>=t.x&&this.top<=t.y&&this.bottom>=t.y}includes(t){return this.left<=t.left&&this.right>=t.right&&this.top<=t.top&&this.bottom>=t.bottom}transform(t){if(!t)return this;let e=o.fromPoint({x:this.left,y:this.top}).transform(t),i=o.fromPoint({x:this.right,y:this.top}).transform(t),s=o.fromPoint({x:this.left,y:this.bottom}).transform(t),r=o.fromPoint({x:this.right,y:this.bottom}).transform(t),n=Math.min(e.x,i.x,s.x,r.x),a=Math.min(e.y,i.y,s.y,r.y),h=Math.max(e.x,i.x,s.x,r.x),l=Math.max(e.y,i.y,s.y,r.y);return A.ofEdges(n,a,h,l)}toPath(t,e=1){throw new Error("Rect.toPath is deprecated. Try oneof (ArrayPath, SharedPath, Spline).fromRect(rect, pointProps)")}toGLRect(){return new T(this.x,this.y,this.width,this.height)}toString(){return`rect(${this.x}, ${this.y}, ${this.width}, ${this.height})`}toJSON(){return{x:this.left,y:this.top,width:this.width,height:this.height}}static fromGLRect(t){if(!t)return null;if(!(t instanceof T))throw new TypeError("rect must be instance of RectGL");return new A(t.left,t.bottom,t.width,t.height)}static isRect(t){return t&&isFinite(t.left)&&isFinite(t.top)&&isFinite(t.width)&&isFinite(t.height)}static fromString(t){return t=t.substring(t.indexOf("(")+1,t.indexOf(")")).split(/,\s*/g),new A(parseFloat(t[0]),parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3]))}static fromRect(t){return"string"==typeof t?A.fromString(t):new A(t.x,t.y,t.width,t.height)}static ofPolygon(t){if(t.shape&&(t=t.shape),0==t.length)return null;let e=Number.MAX_SAFE_INTEGER,i=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER;for(let n=0;n<t.length;n++){let a=t.getPointX(n),o=t.getPointY(n);e=Math.min(e,a),i=Math.min(i,o),s=Math.max(s,a),r=Math.max(r,o)}return A.ofEdges(e,i,s,r)}static ofSpline(t,e=0){let i;for(let s=0;s<t.length;s++)i=T.calculateBrushGLSegmentBounds(t.getPoint(s),e).union(i);return A.fromGLRect(i)}static ofEdges(t,e,i,s){return new A(t,e,i-t,s-e)}static union(t,e){return t?e?t.union(e):t:e}static intersect(t,e){return t&&e?t.intersect(e):null}}class x extends O{constructor(t,e,i,s=0,r=1){super(e,i,t),this.ts=s,this.tf=r,Object.defineProperty(this,"segmentsCount",{value:this.length-3,configurable:!0}),Object.defineProperty(this,"bounds",{get:()=>A.ofSpline(this,this.pointProps.scattering).ceil(),enumerable:!0}),Object.defineProperty(this,"color",{get:()=>g.isColor(this.pointProps)?g.fromColor(this.pointProps):void 0,set:t=>{if(!t)throw new Error("Spline color cannot be removed");if(!(t instanceof g))throw new Error("Expected value should be Color instance");"red"in this.pointProps&&(this.pointProps.red=t.red),"green"in this.pointProps&&(this.pointProps.green=t.green),"blue"in this.pointProps&&(this.pointProps.blue=t.blue),"alpha"in this.pointProps&&(this.pointProps.alpha=t.alpha)},enumerable:!0}),this.validate()}validate(){if(!this.layout.includes(y.Property.X))throw new Error("Layout doesn't contains required properties X");if(!this.layout.includes(y.Property.Y))throw new Error("Layout doesn't contains required properties Y");if(0==this.points.length)throw new Error("Empty spline is not allowed");if(this.points.length%this.stride!=0)throw new Error("Path length doesn't match the stride provided via the layout");if(this.ts<0||this.ts>=1)throw new Error(`Invalid spline ts ${this.ts} found. The value must be in the interval [0, 1).`);if(this.tf<=0||this.tf>1)throw new Error(`Invalid spline tf ${this.tf} found. The value must be in the interval (0, 1].`);if(1==this.segmentsCount&&this.ts>this.tf)throw new Error(`Invalid spline t range ${this.ts} - ${this.tf} found. Spline has only one segment and ts <= tf.`);if(this.segmentsCount<1)throw new Error("Incompleted spline found. Spline is defined with at least 4 control points.")}clone(){return new x(this.layout.slice(),this.points.clone(),Object.clone(this.pointProps),this.ts,this.tf)}getSegment(t){let e=t,i=t+3,s=0==e?this.ts:0,r=i+1==this.length?this.tf:1;return this.slice({fromPointIndex:e,toPointIndex:i,fromTValue:s,toTValue:r})}slice(t){let e=this.slicePoints(t.fromPointIndex,t.toPointIndex,t.fromTValue,t.toTValue),i=new x(this.layout.slice(),e,Object.clone(this.pointProps),t.fromTValue,t.toTValue);return i.id=t.id,i}toPlainPath(){let t=[];for(let e=0;e<this.length;e++)t.push(this.getPointX(),this.getPointY());return new v(t)}toJSON(){return{type:"Spline",id:this.id,layout:this.layout.map((t=>t.name)),points:I.encode(this.points,this.encoding),pointProps:this.pointProps,ts:this.ts,tf:this.tf}}static fromJSON(t){let e=I.decode(t.points),i=new x(t.layout.map((t=>y.Property[t])),e,t.pointProps,t.ts,t.tf);return i.id=t.id,i}static fromRect(t,e){let i=[t.left,t.top,t.left,t.top,t.right,t.top,t.right,t.bottom,t.left,t.bottom,t.left,t.top,t.left,t.top];return new x(void 0,i,e)}}class R extends O{constructor(t,e,i,s=[]){super(e,i,t),s.length>0&&!Object.isFrozen(s.first)&&s.forEach((t=>Object.freeze(t))),Object.defineProperty(this,"splineParameters",{value:Object.freeze(s),enumerable:!0});let r=new b(t,i);Object.defineProperty(this,"style",{get:()=>r.style,set:t=>r.style.reset(t),enumerable:!0}),Object.defineProperty(this,"color",{get:()=>this.style.color,set:t=>{if(!t)throw new Error("Spline color cannot be removed");if(!(t instanceof g))throw new Error("Expected value should be Color instance");"red"in this.pointProps&&(this.pointProps.red=t.red),"green"in this.pointProps&&(this.pointProps.green=t.green),"blue"in this.pointProps&&(this.pointProps.blue=t.blue),"alpha"in this.pointProps&&(this.pointProps.alpha=t.alpha)},enumerable:!0}),Object.defineProperty(this,"bounds",{get:()=>A.ofSpline(this,this.pointProps.scattering).ceil(),enumerable:!0}),this.validate()}validate(){if(!this.layout.includes(y.Property.X))throw new Error("Layout doesn't contains required properties X");if(!this.layout.includes(y.Property.Y))throw new Error("Layout doesn't contains required properties Y");if(0==this.points.length)throw new Error("Empty spline is not allowed");if(this.points.length%this.stride!=0)throw new Error("Path length doesn't match the stride provided via the layout")}clone(){return new R(this.layout.slice(),this.points.clone(),Object.clone(this.pointProps),this.splineParameters.slice())}getPoint(t){return super.getPoint(t,this.style)}getPointSegmentIndex(t){return this.splineParameters[t]?this.splineParameters[t].index:void 0}getPointT(t){return this.splineParameters[t]?this.splineParameters[t].t:void 0}getPointParameter(t){return this.splineParameters[t]}toJSON(){return{type:"InterpolatedSpline",layout:this.layout.map((t=>t.name)),points:I.encode(this.points,this.encoding),pointProps:this.pointProps,splineParameters:this.splineParameters}}static fromJSON(t){let e=I.decode(t.points);return new R(t.layout.map((t=>y.Property[t])),e,t.pointProps,t.splineParameters)}static fromRect(t,e){throw new Error("InterpolatedSpline.fromRect is not supported. Try Spline.fromRect and interpolate with particular Spline interpolator.")}}let N;class M{constructor(){if(N)throw new Error("URIResolver instance already available");N=this,this.init()}init(){throw new Error("URIResolver: init should be implemented")}get(t){return this[t]}register(t,e){this[t]=e}resolve(t){let e;if(t.includes("?")){let i=this[t.split("?")[0]];if(i){let s=t.split("?")[1],r=[];s.split("&").forEach((t=>{let e=t.split("=")[1],i=parseFloat(e);isFinite(i)?e=i:"true"==e?e=!0:"false"==e&&(e=!1),r.push(e)})),e=function(){return i(...Array.from(arguments).concat(r))}}}else e=this[t];if(!e)throw new Error(`Failed to resolve ${t}`);return e}}Object.defineProperty(M,"instance",{get:()=>N});class C{static repetitionsCache=new Set;constructor(t,e){this.name=t,!t||P.isValidURL(t)||C.repetitionsCache.has(t)||(C.repetitionsCache.add(t),console.warn(`The string ${t} is not a well formed URI`)),Object.defineProperty(this,"value",{get:function(){if(!e){if(!this.name)throw new Error("Resource descriptor identifier not found. Cannot resolve resource content.");if("function"==typeof this.resolve&&(e=this.resolve(this.name)),!e){if(!M.instance)throw new Error(`Resource URI ${this.name} cannot be resolved. URIResolver not implemented yet. Please implement and instantiate.`);e=M.instance.resolve(this.name)}if(!e)throw new Error(`Resource URI ${this.name} cannot be resolved. Please provide resource definition in URIResolver init implementation.`)}return e},set:function(t){e=t},enumerable:!0})}toJSON(){let t=this.value;return ArrayBuffer.isTypedArray(t)?t=I.encode(t,this.encoding):"function"==typeof t&&(t=t()),{name:this.name,value:t}}static fromJSON(t){let e=t.value;return I.isTypedArrayData(e)&&(e=I.decode(e)),new C(t.name,e)}static getInstance(t,e){return new C(e,t)}}class F{constructor(t){P.isValidURL(t)||(C.repetitionsCache.has(t)||(C.repetitionsCache.add(t),console.warn(`Brush URI ${t} is not a well formed URI`)),t=this.constructor.onInvalidName(t)),Object.defineProperty(this,"id",{value:t}),Object.defineProperty(this,"uri",{value:t}),Object.defineProperty(this,"name",{value:t,enumerable:!0})}toJSON(){throw new Error("Brush.toJSON() should be implemented")}static fromJSON(t){throw new Error("static Brush.fromJSON() should be implemented")}static onInvalidName(t){return t}}class L{static defaults={CIRCLE_PRECISION:20,CIRCLE_RADIUS:.5,ELLIPSE_PRECISION:20,ELLIPSE_RADIUS_X:.5,ELLIPSE_RADIUS_Y:.25,STAR_POINTS:5,STAR_RADIUS:.5,STAR_INTERNAL_RADIUS:.25};static createCircle(t=L.defaults.CIRCLE_PRECISION,e=L.defaults.CIRCLE_RADIUS,i={x:0,y:0}){return L.createEllipse(t,e,e,i)}static createEllipse(t=L.defaults.ELLIPSE_PRECISION,e=L.defaults.ELLIPSE_RADIUS_X,i=L.defaults.ELLIPSE_RADIUS_Y,s={x:0,y:0}){let r=[],n=2*Math.PI/t;if(e<=0)throw new Error(`Invalid radius x found ${e} > 0`);if(i<=0)throw new Error(`Invalid radius y found ${i} > 0`);for(let a=0;a<t;a++){let t=a*n,o=e*Math.cos(t),h=i*Math.sin(t);r.push(s.x+o,s.y+h)}return Float32Array.createSharedInstance(r)}static createStar(t=L.defaults.STAR_POINTS,e=L.defaults.STAR_INTERNAL_RADIUS,i=L.defaults.STAR_RADIUS){let s=[];if(i<=0)throw new Error(`Invalid radius found ${i} > 0`);if(e<=0)throw new Error(`Invalid internal radius found ${e} > 0`);if(e>i)throw new Error(`Invalid internal radius found 0 < ${e} < ${i}`);let r=2*Math.PI/t;for(let n=0;n<t;n++){let t=n*r,a=i*Math.cos(t),o=i*Math.sin(t),h=e*Math.cos(t+r/2),l=e*Math.sin(t+r/2);s.push(a,o,h,l)}return Float32Array.createSharedInstance(s)}}let _=n?n.default||globalThis.poly2tri:{};const{SweepContext:D,Point:j}=_;class ${constructor(t=2){this.stride=t}sort(t,e){return this.sortArrayPart(t,0,t.length-this.stride,e),t}partition(t,e,i,s){let r=t[i],n=t[i+1],a=e-this.stride;for(let o=e;o<i;o+=2)s?s(r,n,t[o],t[o+1])&&(a+=this.stride,this.swap(t,a,o)):(r>t[o]||r==t[o]&&n>t[o+1])&&(a+=this.stride,this.swap(t,a,o));return this.swap(t,a+this.stride,i),a+this.stride}swap(t,e,i){let s=t[e],r=t[e+1];return t[e]=t[i],t[e+1]=t[i+1],t[i]=s,t[i+1]=r,t}sortArrayPart(t,e,i,s){if(e<i){let r=this.partition(t,e,i,s);this.sortArrayPart(t,e,r-this.stride,s),this.sortArrayPart(t,r+this.stride,i,s)}}}function Y(t,e,i,s,r,n){return(i-t)*(n-e)-(s-e)*(r-t)}function k(t,e,i,s,r,n){let a=t-i,o=r-i,h=a*(n-s)-o*(e-s);h*=h,a=r-i,o=n-s;let l=a*a+o*o;return l>0?Math.sqrt(h/l):Math.sqrt((i-t)*(i-t)+(s-e)*(s-e))}class B{constructor(t=Float32Array){this.ArrayType=t,this.quickSort=new $}monotoneChain(t){if(t.length<=0)return new this.ArrayType;this.quickSort.sort(t);let e=new this.ArrayType(t.length),i=0;for(let s=0;s<t.length;s+=2){for(;i>=4&&Y(e[i-4],e[i-3],e[i-2],e[i-1],t[s],t[s+1])<=0;)i-=2;e[i]=t[s],e[i+1]=t[s+1],i+=2}e=e.slice(0,i);let s,r=new this.ArrayType(t.length);i=0;for(let e=t.length-2;e>=0;e-=2){for(;i>=4&&Y(r[i-4],r[i-3],r[i-2],r[i-1],t[e],t[e+1])<=0;)i-=2;r[i]=t[e],r[i+1]=t[e+1],i+=2}if(r=r.slice(0,i-2),this.ArrayType==Float32Array){let t=r.length+e.length;s=Float32Array.createSharedInstance(t),s.set(r),s.set(e,r.length)}else s=r.concat(e);return s}}class U{constructor(t,e=[]){if(!(t instanceof w))throw new Error("Expected shape type is Path. Use createInstance or createSharedInstance Polygon methods to allocate instance.");if(e.some((t=>!(t instanceof w))))throw new Error("Expected hole type is Path. Use createInstance or createSharedInstance Polygon methods to allocate instance.");let i;this.holesDirection=U.PointsDirection.CLOCKWISE,Object.defineProperty(this,"shape",{value:t,enumerable:!0}),Object.defineProperty(this,"holes",{value:e,enumerable:!0}),Object.defineProperty(this,"contours",{value:[t,...e],enumerable:!0}),Object.defineProperty(this,"ArrayType",{value:t instanceof O?Float32Array:Array}),Object.defineProperty(this,"bounds",{get:()=>A.ofPolygon(this),enumerable:!0}),Object.defineProperty(this,"vertices",{get:()=>(i||(i=this.triangulate()),i),set:t=>i=t,enumerable:!0}),Object.defineProperty(this,"verticesValue",{get:()=>i})}clone(t=!1){let e=this.shape.clone(t),i=this.holes.map((e=>e.clone(t))),s=new U(e,i);return this.verticesValue&&(s.vertices=this.vertices.slice()),s}fit(t){let e=this.bounds,i=t.width/e.width,s=t.height/e.height,r=i>0&&s>0?Math.min(i,s):Math.max(i,s);for(let t of this.contours)for(let e=0;e<t.length;e++)t.setPointX(e,t.getPointX(e)*r),t.setPointY(e,t.getPointY(e)*r)}center(){let t=this.bounds;for(let e of this.contours)for(let i=0;i<e.length;i++)e.setPointX(i,e.getPointX(i)-t.center.x),e.setPointY(i,e.getPointY(i)-t.center.y)}transform(t){this.contours.forEach((e=>e.transform(t)))}intersects(t){if(!(t instanceof U))throw new Error("Expected 'poly' type is Polygon");let e=this.shape,i=t.shape;for(let t=0;t<2;t++){let s=0==t?e:i;for(let t=0;t<s.length;t++){let r=t+1==s.length?0:t+1,n=s.getPointX(t),a=s.getPointY(t),o=s.getPointX(r),h=s.getPointY(r)-a,l=n-o,u=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY;for(let t=0;t<e.length;t++){let i=h*e.getPointX(t)+l*e.getPointY(t);i<u&&(u=i),i>c&&(c=i)}let p=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY;for(let t=0;t<i.length;t++){let e=h*i.getPointX(t)+l*i.getPointY(t);e<p&&(p=e),e>d&&(d=e)}if(c<p||d<u)return!1}}return!0}triangulate(){let t,e=[];for(let t of this.contours){let i=[];for(let e=0;e<t.length;e++){let s=new j(t.getPointX(e),t.getPointY(e));if(e>0){if(i.last.x==s.x&&i.last.y==s.y)continue;if(e==t.length-1&&i.first.x==s.x&&i.first.y==s.y)continue}i.push(s)}e.push(i)}try{t=new D(e.shift())}catch(t){return console.error(t),new Float32Array}for(let i of e)try{t.addHole(i)}catch(t){return console.error(t),new Float32Array}try{t.triangulate()}catch(t){return console.warn(t),new Float32Array}let i=t.getTriangles(),s=Float32Array.createSharedInstance(6*i.length),r=0;for(let t of i){let e=t.getPoints();for(let t of e)s[r++]=t.x,s[r++]=t.y}return s}convex(){return this.buildConvex.convex(this.shape.points)}union(t){let e=Array.of(...this.shape.points,...t.shape.points);return this.buildConvex(e)}buildConvex(t){this.convexHullProducer||(this.convexHullProducer=new B(this.ArrayType));let e=this.convexHullProducer.monotoneChain(t);return this.ArrayType==Float32Array?U.createSharedInstance(e):U.createInstance(e)}simplify(t=.1){if(t<=0)throw new Error("epsilon expected value > 0");this.epsilon=t;let e=this.simplifyPath(this.shape),i=[];for(let t of this.holes){let e=this.simplifyPath(t);e.length>0&&i.push(e)}return this.shape instanceof O?U.createSharedInstance(e,i):U.createInstance(e,i)}simplifyPath(t){if(t.length<3)return t.points;let e=Array.of(...t.points,t.getPointX(0),t.getPointY(0)),i=this.simplifyPolyline(e);return i.length<8?e.slice(0,e.length-2):i.slice(0,i.length-2)}simplifyPolyline(t){if(t.length<4)return t;let e=0,i=0;for(let s=2;s<t.length-2;s+=2){let r=k(t[s],t[s+1],t[0],t[1],t[t.length-2],t[t.length-1]);r>e&&(i=s,e=r)}if(e>this.epsilon){let e=this.simplifyPolyline(t.slice(0,i+2)),s=this.simplifyPolyline(t.slice(i,t.length));return e.concat(s.slice(2,s.length))}return[t[0],t[1],t[t.length-2],t[t.length-1]]}toSVGPath(){return this.contours.map((t=>t.toSVGPath())).join(" ")}toJSON(){return{type:"Polygon",shape:this.shape.toJSON(),holes:this.holes.map((t=>t.toJSON())),holesDirection:this.holesDirection.name,vertices:this.verticesValue}}static fromJSON(t){if("Polygon"!=t.type)throw new Error(`Polygon deserialization failed. JSON type is ${t.type}, expected Polygon.`);let e="SharedPath"==t.shape.type?O.fromJSON(t.shape):v.fromJSON(t.shape),i=t.holes.map((t=>"SharedPath"==t.type?O.fromJSON(t):v.fromJSON(t))),s=new U(e,i);return s.holesDirection=U.PointsDirection[t.holesDirection],s.vertices=t.vertices,s}static fromRect(t){return U.createInstance([t.left,t.top,t.right,t.top,t.right,t.bottom,t.left,t.bottom,t.left,t.top])}static createInstance(t,e=[]){return new U(new v(t),e.map((t=>new v(t))))}static createSharedInstance(t,e=[]){let i=new U(new O(t),e.map((t=>new O(t))));return Object.defineProperty(i,"encoding",{get:()=>i.shape.encoding,set:t=>{i.contours.forEach((e=>e.encoding=t))},enumerable:!0}),i}}Object.defineEnum(U,"PointsDirection",["CLOCKWISE","COUNTERCLOCKWISE"]);class X{static SHAPE_FRAME=new A(-.5,-.5,1,1);constructor(t,e=1){this.size=e,Object.defineProperty(this,"descriptor",{value:{shape:void 0},enumerable:!0}),Object.defineProperty(this,"shape",{get:function(){if(!t){if("function"==typeof(t=this.descriptor.shape.value)&&(t=t()),(Array.isArray(t)||t instanceof Float32Array)&&(t=U.createSharedInstance(t)),!(t instanceof U))throw new Error("Expected shape type is Polygon");X.fitShape(t)}return t},set:function(e){if(!e)throw new Error("BrushPrototype: shape not found");"string"==typeof e?e=new C(e):e instanceof U||e instanceof Float32Array||Array.isArray(e)?e=C.getInstance(e):e instanceof C||(e=new C(e.name,e.value)),t=null,this.descriptor.shape=e,this.descriptor.shape.resolve=X.resolve},enumerable:!0}),this.shape=t}toJSON(){return this.shape.encoding=this.encoding,{shape:{name:this.descriptor.shape.name,value:this.shape.toJSON()},size:this.size}}static fromJSON(t){return new X({name:t.shape.name,value:U.fromJSON(t.shape.value)},t.size)}static create(t,e=0,...i){let s,r=t;switch(t){case X.Type.CIRCLE:s=L.createCircle(...i),r+=`?precision=${i[0]||L.defaults.CIRCLE_PRECISION}&radius=${i[1]||L.defaults.CIRCLE_RADIUS}`;break;case X.Type.ELLIPSE:s=L.createEllipse(...i),r+=`?precision=${i[0]||L.defaults.ELLIPSE_PRECISION}&radiusX=${i[1]||L.defaults.ELLIPSE_RADIUS_X}&radiusY=${i[2]||L.defaults.ELLIPSE_RADIUS_Y}`;break;case X.Type.STAR:s=L.createStar(...i),r+=`?points=${i[0]||L.defaults.STAR_POINTS}&internalRadius=${i[1]||L.defaults.STAR_INTERNAL_RADIUS}&radius=${i[2]||L.defaults.STAR_RADIUS}`;break;default:console.error(`Brush2D: createShape fails with ${t} type`)}return new X({name:r,shape:s},e)}static resolve(t){let e,i=t.split("?"),s=i.first;if(Object.values(X.Type).includes(s)){let t=i.last.split("&"),r={};switch(t.forEach((t=>{r[t.substring(0,t.indexOf("="))]=t.substring(t.indexOf("=")+1)})),s){case X.Type.CIRCLE:{let t=r.precision?parseInt(r.precision):void 0,i=r.radius?parseFloat(r.radius):1;e=L.createCircle(t,i);break}case X.Type.ELLIPSE:{let t=r.precision?parseInt(r.precision):void 0,i=r.radiusX?parseFloat(r.radiusX):void 0,s=r.radiusY?parseFloat(r.radiusY):void 0;e=L.createEllipse(t,i,s);break}case X.Type.STAR:{let t=r.points?parseInt(r.points):void 0,i=r.radius?parseFloat(r.radius):void 0,s=r.internalRadius?parseFloat(r.internalRadius):void 0;e=L.createStar(t,s,i);break}default:console.error(`Brush2D: createShape fails with ${s} type`)}}return e}static fitShape(t){if(!(t instanceof U))throw new Error("Expected shape type is Polygon");t.center(),t.fit(X.SHAPE_FRAME)}}X.Type={ELLIPSE:"will://brush/3.0/shape/Ellipse",CIRCLE:"will://brush/3.0/shape/Circle",STAR:"will://brush/3.0/shape/Star"};Object.defineProperty(globalThis,"DIGITAL_INK_ENV",{value:"AUTO",enumerable:!0,configurable:!0});let z={version:"1.4.2"};async function G(t,e="binary",i={}){if(t instanceof Uint8Array)return t;let s,r=await fetch(t,Object.assign({mode:"no-cors"},i));if("json"==e)s=await r.json();else if("text"==e)s=await r.text();else if("binary"==e){let t=await r.arrayBuffer();s=new Uint8Array(t)}else{let t=await r.blob();s="base64"==e?await function(t){return new Promise(((e,i)=>{let s=new FileReader;s.readAsDataURL(t),s.onloadend=()=>e(s.result),s.onerror=i}))}(t):t}return s}async function V(t,e="binary",i={}){return G(t,e,i)}async function J(t){let e;return e="string"==typeof t||"undefined"==typeof createImageBitmap?await function(t){return new Promise(((e,i)=>{let s,r=new Image;r.crossOrigin="anonymous",r.onload=()=>{if(z.type2D==z.Type2D.OFFSCREEN){const t=new OffscreenCanvas(r.width,r.height);t.getContext("2d").drawImage(r,0,0),e(t)}else s&&URL.revokeObjectURL(s),e(r)},r.onerror=i,"string"==typeof t?r.src=t:z.type2D==z.Type2D.OFFSCREEN?t instanceof Uint8Array?r.src=Buffer.from(t):t instanceof OffscreenCanvas?e(t):r.src=t:(t instanceof Uint8Array&&(t.byteLength!=t.buffer.byteLength&&(t=t.slice()),t=t.buffer),t instanceof ArrayBuffer&&(t=new Blob([t],{type:"image/png"})),s=URL.createObjectURL(t),r.src=s)}))}(t):t instanceof ArrayBuffer||t instanceof Uint8Array?await createImageBitmap(new Blob([t],{type:"image/png"})):await createImageBitmap(t),e}Object.defineEnum(z,"Type",["WEB","WORKER","NODE","SHELL"]),Object.defineEnum(z,"Type2D",["SCREEN","OFFSCREEN"]),Object.defineEnum(z,"TypeGL",["WEB","STACK"]),function(t){let e,i="BROWSER"!=DIGITAL_INK_ENV&&"object"==typeof process&&"function"==typeof require;e="object"==typeof window?"WEB":"function"==typeof importScripts?"WORKER":i?"NODE":"SHELL";let s="undefined"==typeof OffscreenCanvas?"OFFSCREEN":"SCREEN",r="undefined"==typeof WebGLRenderingContext?"STACK":"WEB";Object.defineProperty(z,"commonJS",{value:i,enumerable:!0}),Object.defineProperty(z,"type",{value:z.Type[e],enumerable:!0}),Object.defineProperty(z,"type2D",{value:z.Type2D[s],enumerable:!0}),Object.defineProperty(z,"typeGL",{value:z.TypeGL[r],enumerable:!0})}();class Z extends F{constructor(t,e,i,s=1){super(t),isFinite(i)&&(s=i,i=void 0),s<=0&&(console.warn(`Invalid spacing found ${s}. It should be positive number.`),s=1),Object.defineProperty(this,"shape",{get:()=>e,set:t=>{if(t instanceof Float32Array&&(t=new X(t)),t instanceof X&&(t=[t]),t.some((t=>!(t instanceof X))))throw console.warn(t),new Error("Brush2D: Invalid shape found");t.sort(P.comparator({sortBy:"size",sortOrder:"asc"})),e=t},enumerable:!0}),this.shape=e,this.fill=i,this.spacing=s}async configure(t){if(this.pattern||!this.fill)return;if(!(t instanceof CanvasRenderingContext2D||t instanceof OffscreenCanvasRenderingContext2D))throw new Error("ctx is not instance of CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D");let e=await J(this.fill);this.pattern=t.createPattern(e,"repeat")}selectShape(t){let e;for(let i=1;i<this.shape.length;i++)if(this.shape[i].size>t){e=this.shape[i-1];break}return e||(e=this.shape.last),e.shape}toJSON(){return{type:"Brush2D",name:this.name,spacing:this.spacing,shape:this.shape.map((t=>(t.encoding=this.encoding,t.toJSON())))}}static fromJSON(t){let e=1==t.shape.length?X.fromJSON(t.shape[0]):t.shape.map((t=>X.fromJSON(t)));return new Z(t.name,e,t.spacing)}}function H(){}H.BlendMode={SOURCE_OVER:"source-over",DESTINATION_OVER:"destination-over",DESTINATION_IN:"destination-in",DESTINATION_OUT:"destination-out",LIGHTER:"lighter",COPY:"copy",MIN:"MIN",MAX:"MAX",DIRECT_SOURCE_OUT:"DIRECT_SOURCE_OUT",DIRECT_DESTINATION_OUT:"DIRECT_DESTINATION_OUT"};const q=H.BlendMode;class W{constructor(t,e){Object.defineProperty(this,"ctx",{value:t,enumerable:!0}),Object.defineProperty(this,"value",{value:e,enumerable:!0}),Object.defineProperty(this,"texture",{value:e,enumerable:!0})}async update(t,e){if(Array.isArray(t)){let i=[],s=t;for(let t of s){let e=await J(t);i.push(e)}this.completeMipMap(i),this.fill(i,e)}else{let e=t,i=await J(e);this.fill(i)}}completeMipMap(t){if(t.sort(((t,e)=>e.width-t.width)),1==t.last.width)return;let e=t.last.width;for(;e>1;){e/=2;let i=new OffscreenCanvas(t.last.width/2,t.last.height/2);i.getContext("2d").drawImage(t.last,0,0,i.width,i.height),t.push(i)}}fill(t,e){let i=this.ctx,s=this.value;if(i.bindTexture(i.TEXTURE_2D,s),i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),Array.isArray(t)){let s=t;this.size=[],s.forEach(((t,e)=>{i.texImage2D(i.TEXTURE_2D,e,i.RGBA,i.RGBA,i.UNSIGNED_BYTE,t),this.size.push({width:t.width,height:t.height}),t.close&&t.close()})),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,e?i.LINEAR_MIPMAP_LINEAR:i.LINEAR_MIPMAP_NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.LINEAR)}else i.texImage2D(i.TEXTURE_2D,0,i.RGBA,i.RGBA,i.UNSIGNED_BYTE,t),this.size={width:t.width,height:t.height},t.close&&t.close();i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),i.bindTexture(i.TEXTURE_2D,null),this.logError(this.ctx,s.name)}readPixels(){let t=this.ctx,e=this.value,i=(i,s)=>{let r=new Uint8Array(i.width*i.height*4);return t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,s),t.readPixels(0,0,i.width,i.height,t.RGBA,t.UNSIGNED_BYTE,r),r},s=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,s);let r=Array.isArray(this.size)?this.size.map(i):i(this.size,0);return t.deleteFramebuffer(s),r}logError(){let t=this.ctx.getError();if(t>0){let e=Object.keys(this.ctx.constructor.prototype).filter((e=>this.ctx[e]===t)).join(" | ");console.error(`WebGL error - ${this.texture.name}: ${t} - ${e}`)}}static createInstance(t,e=t.CLAMP_TO_EDGE,i=t.NEAREST){let s=t.createTexture();return t.bindTexture(t.TEXTURE_2D,s),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,i),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,i),t.bindTexture(t.TEXTURE_2D,null),new W(t,s)}}class K extends F{constructor(t,e,i,s={},r={}){super(t),this.spacing=s.spacing||.15,this.scattering=s.scattering||0,this.rotationMode=s.rotationMode||K.RotationMode.RANDOM;let n=s.blendMode||q.SOURCE_OVER;Object.defineProperty(this,"blendMode",{get:()=>n,set:t=>{if(!t)throw new Error("BrushGL blendMode is required");n=t}}),Object.defineProperty(this,"particleSettings",{get:()=>({spacing:this.spacing,scattering:this.scattering,blendMode:this.blendMode,rotationMode:this.rotationMode}),enumerable:!0}),Object.defineProperty(this,"fillTextureSettings",{get:()=>({randomize:this.randomizeFill,size:this.fillTextureSize,offset:this.fillTextureOffset}),enumerable:!0}),Object.defineProperty(this,"descriptor",{value:{shape:void 0,fill:void 0},enumerable:!0}),Object.defineProperty(this,"shape",{get:()=>Array.isArray(this.descriptor.shape)?this.descriptor.shape.map((t=>t.value)):this.descriptor.shape.value,enumerable:!0}),Object.defineProperty(this,"fill",{get:()=>this.descriptor.fill.value,enumerable:!0}),this.updateShape(e),this.updateFill(i,r)}async updateShape(t){Array.isArray(t)?t=t.map((t=>"string"==typeof t?C.getInstance(t):t instanceof C?t:new C(t.name,t.value))):"string"==typeof t?t=C.getInstance(t):t instanceof C||(t=new C(t.name,t.value)),this.descriptor.shape=t,this.ctx&&await this.configureShape()}async updateFill(t,e={}){if(this.randomizeFill=!("randomize"in e)||e.randomize,this.fillTextureSize=e.size,this.fillTextureOffset=e.offset||{x:0,y:0},Array.isArray(t))throw new Error("Mipmap is not compatible whith fill texture");"string"==typeof t?t=C.getInstance(t):t instanceof C||(t=new C(t.name,t.value)),this.descriptor.fill=t,this.ctx&&await this.configureFill()}async configure(t){this.ctx=t,await this.configureShape(),await this.configureFill()}async configureShape(){this.shapeTexture||(this.shapeTexture=W.createInstance(this.ctx,this.ctx.CLAMP_TO_EDGE,this.ctx.LINEAR)),await this.shapeTexture.update(this.shape,this.spacing<=1)}async configureFill(){this.fillTexture||(this.fillTexture=W.createInstance(this.ctx,this.ctx.REPEAT,this.ctx.NEAREST)),await this.fillTexture.update(this.fill),this.fillTextureSize||(this.fillTextureSize=this.fillTexture.size)}async getShapeBinary(){let t;if(Array.isArray(this.shape)){let e=[];for(let t of this.shape){let i=await V(t);e.push(i)}t=e}else t=await V(this.shape);return t}async getFillBinary(){return await V(this.fill)}toJSON(){return{type:"BrushGL",name:this.name,shape:Array.isArray(this.descriptor.shape)?this.descriptor.shape.map((t=>t.toJSON())):this.descriptor.shape.toJSON(),fill:this.descriptor.fill.toJSON(),particleSettings:{spacing:this.spacing,scattering:this.scattering,blendMode:this.blendMode.name,rotationMode:this.rotationMode.name},fillTextureSettings:{randomize:this.randomizeFill,size:this.fillTextureSize,offset:this.fillTextureOffset}}}static fromJSON(t){t.particleSettings.blendMode=q[t.particleSettings.blendMode],t.particleSettings.rotationMode=K.RotationMode[t.particleSettings.rotationMode];let e=Array.isArray(t.shape)?t.shape.map((t=>C.fromJSON(t))):C.fromJSON(t.shape),i=C.fromJSON(t.fill);return new K(t.name,e,i,t.particleSettings,t.fillTextureSettings)}equals(t){return t==this&&t.shapeTexture==this.shapeTexture&&t.fillTexture==this.fillTexture}delete(){this.deleteShape(),this.deleteFill()}deleteShape(){this.shapeTexture&&(this.ctx.deleteTexture(this.shapeTexture),delete this.shapeTexture)}deleteFill(){this.fillTexture&&(this.ctx.deleteTexture(this.fillTexture),delete this.fillTexture)}}Object.defineEnum(K,"RotationMode",["NONE","RANDOM","TRAJECTORY"]);class Q{constructor(t){this.phase=t.phase;let e=isNaN(t.altitude)||isNaN(t.azimuth)?void 0:{altitude:t.altitude,azimuth:t.azimuth};Object.defineProperty(this,"x",{value:t.x,enumerable:!0}),Object.defineProperty(this,"y",{value:t.y,enumerable:!0}),Object.defineProperty(this,"z",{value:t.z,enumerable:!0}),Object.defineProperty(this,"timestamp",{value:t.timestamp,enumerable:!0,writable:!0}),Object.defineProperty(this,"force",{value:t.pressure,enumerable:!0}),Object.defineProperty(this,"pressure",{value:t.pressure,enumerable:!0}),Object.defineProperty(this,"rotation",{value:t.rotation,enumerable:!0}),Object.defineProperty(this,"radiusX",{value:t.radiusX,enumerable:!0}),Object.defineProperty(this,"radiusY",{value:t.radiusY,enumerable:!0}),Object.defineProperty(this,"altitude",{get:()=>(e||(e=this.computeTilt(t)||{}),e.altitude),enumerable:!0}),Object.defineProperty(this,"azimuth",{get:()=>(e||(e=this.computeTilt(t)||{}),e.azimuth),enumerable:!0}),t.pointer&&Object.defineProperty(this,"pointer",{value:t.pointer,enumerable:!0}),this.computedAzimuth=void 0}createPathPoint(t){return new y(this.x,this.y,this.z,t)}computeTilt(t){if(isNaN(t.tiltX)||isNaN(t.tiltY))return;let{tiltX:e,tiltY:i}=t,s=Math.tan(Math.toRadians(e)),r=Math.tan(Math.toRadians(i)),n=Math.sqrt(s*s+r*r);return{altitude:Math.atan2(1,n),azimuth:Math.atan2(r,s)}}speed(t,e){let i={x:0,y:0,time:0};return i=t&&!e?this.minus(t):e&&!t?e.minus(this):e.minus(t),i.time>0?Q.getMagnitude(i.x,i.y)/(i.time/1e3):(0==i.time||console.warn(`Speed out of range: ${i.time}ms`),0)}computeNearestAzimuthAngle(t){let e;if(isNaN(this.azimuth))return 0;if(t){if(isNaN(t.azimuth))return 0;let i=2*Math.PI,s=t.computedAzimuth||t.azimuth,r=parseInt(s/i);e=this.azimuth+r*i;let n=e-s;n>=Math.PI?e-=i:n<-Math.PI&&(e+=i)}else e=this.azimuth;return this.computedAzimuth=e,e}minus(t){return{x:this.x-t.x,y:this.y-t.y,time:this.timestamp-t.timestamp}}static getMagnitude(t,e){return Math.sqrt(t*t+e*e)}}Object.defineEnum(Q,"Property",["X","Y","Z","PHASE","TIMESTAMP","PRESSURE","RADIUS_X","RADIUS_Y","ALTITUDE","AZIMUTH","ROTATION"]);class tt{constructor(){this.phase=tt.Phase.END}add(t,e,i){if(!this.move(t))throw new Error(`Cannot move from phase ${this.phase.name} to phase ${t.name}`);return this.debug&&(console.log("-------------------------------------"),console.log(this.constructor.name,t.name)),this.addImpl(e,i)}addImpl(t,e){throw new Error("Abstract method addImpl of DataProcessor should be implemented")}move(t){return(this.phase!=tt.Phase.END||t==tt.Phase.BEGIN)&&((this.phase!=tt.Phase.BEGIN||t==tt.Phase.UPDATE||t==tt.Phase.END)&&((this.phase!=tt.Phase.UPDATE||t==tt.Phase.UPDATE||t==tt.Phase.END)&&(t==tt.Phase.BEGIN&&this.reset(),this.phase=t,!0)))}reset(){this.phase=tt.Phase.END}}Object.defineEnum(tt,"Phase",["BEGIN","UPDATE","END"]);class et{constructor(t=[],e=[]){this.accumulatedAddition=t,this.lastPrediction=e,this.first=!1,this.last=!1}add(t,e,i=[]){t==tt.Phase.BEGIN?this.reset(!0):t==tt.Phase.END&&(this.last=!0),e&&this.accumulatedAddition.push(...e),this.lastPrediction=i}clone(){let t=new et(this.accumulatedAddition.slice(),this.lastPrediction.slice());return t.first=this.first,t.last=this.last,t}reset(t=!1){this.first=t,this.last=!1,this.accumulatedAddition.clear(),this.lastPrediction.clear()}}class it extends Array{static get[Symbol.species](){return Array}constructor(...t){if(super(...t),t.some((t=>!(t instanceof U))))throw new Error("Expected data item type is Polygon");Object.defineProperty(this,"bounds",{get:()=>{let t;return this.length>0&&(this.forEach((e=>t=e.bounds.union(t))),t=t.ceil()),t},enumerable:!0}),Object.defineProperty(this,"vertices",{get:()=>this.triangulate(),enumerable:!0})}clone(){return new this.constructor(...this.map((t=>t.clone())))}push(...t){if(t.some((t=>!(t instanceof U))))throw new Error("Expected data item type is Polygon");super.push(...t)}triangulate(){return Float32Array.createSharedInstance().concat(...this.map((t=>t.vertices)))}transform(t){this.forEach((e=>e.transform(t)))}toJSON(){return{type:"PolygonArray",polygons:this.map((t=>t.toJSON()))}}static fromJSON(t){if("PolygonArray"!=t.type)throw new Error(`PolygonArray deserialization failed. JSON type is ${t.type}, expected PolygonArray.`);return new it(...t.polygons.map((t=>U.fromJSON(t))))}}class st extends it{constructor(...t){let e;super(...t),Object.defineProperty(this,"encoding",{get:()=>e,set:t=>{e=t,this.forEach((e=>e.encoding=t))},enumerable:!0})}intersects(t){t instanceof U&&(t=[t]);for(let e of this)for(let i of t)if(e.intersects(i))return{poly1:e,poly2:i};return null}toJSON(){let t=super.toJSON();return t.type="InkPath2D",t}static fromJSON(t){if("InkPath2D"!=t.type)throw new Error(`InkPath2D deserialization failed. JSON type is ${t.type}, expected InkPath2D.`);return new st(...t.polygons.map((t=>U.fromJSON(t))))}}class rt{static ARRAY_TYPE=Array;constructor(){this.keepAllData=!1,Object.defineProperty(this,"allData",{get:()=>{if(!this.keepAllData)throw new Error("All data is not accumulated. By default keepAllData property is false.");return this.path||(this.path=new this.constructor.ARRAY_TYPE),this.getOutput(this.path,rt.OutputType.ALL_DATA)},enumerable:!0})}build(t,e=rt.OutputType.PROCESSOR,i=!0){let s;switch(e){case rt.OutputType.ADDITION:s=this.add(t,i);break;case rt.OutputType.PREDICTION:s=this.predict(t);break;case rt.OutputType.PROCESSOR:this.reset(),s=this.buildImpl(t,e);break;default:throw new Error("Unexpected OutputType found. Allowed type is oneof(ADDITION, PREDICTION, PROCESSOR)")}return e!=rt.OutputType.PREDICTION&&this.keepAllData&&(this.path||(this.path=new this.constructor.ARRAY_TYPE),s instanceof U?this.path.push(s):this.path.push(...s)),this.debug&&console.log(this.constructor.name,e.name,i,s),this.getOutput(s,e)}add(t,e=!1){return this.buildImpl(t,rt.OutputType.ADDITION)}predict(t){return this.buildImpl(t,rt.OutputType.PREDICTION)}buildImpl(t){throw new Error("Abstract method buildImpl(input) of DataSequenceProcessor should be implemented")}getOutput(t,e){return t}reset(){this.path&&(this.path=new this.constructor.ARRAY_TYPE)}}Object.defineEnum(rt,"OutputType",["ADDITION","PREDICTION","ALL_DATA","PROCESSOR"]);class nt extends tt{constructor(t,e){super(),this.layout=t,this.pathPointCalculator=e,this.inputBuffer=[],this.prediction=!0}togglePrediction(t){console.warn("PathProducer togglePrediction method is deprecated. Use InkBuilder instance prediction property to configure prediction behaviour."),this.prediction=t}addImpl(t,e){if(t.phase!=this.phase)throw new Error(`The phase of the addition (${t.phase.name}) doesn't match the phase of the PathProducer (${this.phase.name})`);let i=[],s=[];t&&this.inputBuffer.push(t);let r=this.inputBuffer.length>=3?this.inputBuffer[this.inputBuffer.length-3]:null,n=this.inputBuffer.length>=2?this.inputBuffer[this.inputBuffer.length-2]:null,a=this.inputBuffer.length>=1?this.inputBuffer[this.inputBuffer.length-1]:null,o=this.calculate(r,n,a);return t&&o&&i.push(...o.toArray(this.layout)),this.phase==tt.Phase.END?(o=this.calculate(n,a,null),o&&i.push(...o.toArray(this.layout))):this.prediction&&(this.phase==tt.Phase.UPDATE||e)&&(o=this.calculate(n,a,e),o&&(s.push(...o.toArray(this.layout)),o=this.calculate(a,e,null),o&&s.push(...o.toArray(this.layout)))),{added:i,predicted:s}}calculate(t,e,i){return e?this.pathPointCalculator(t,e,i):null}reset(){super.reset(),this.inputBuffer.clear()}}const at=[-6e-6,-139e-6,-185e-6,414e-6,.002357,.003357,-.003135,-.023928,-.042909,-.017858,.096525,.254692,.347072,.26881,.114933];class ot extends rt{constructor(t,e=15){super(),this.buffer=[],this.pointsCount=0,this.filter=at.slice(),Object.defineProperty(this,"movingAverageWindowSize",{get:function(){return e},set:function(t){e=t,this.filter.length!=t&&(this.filter=ot.resample(at,t)),this.predictionPointsCount=4*t/15,this.windowSize=this.filter.length},enumerable:!0}),this.dimsCount=t,this.movingAverageWindowSize=e}add(t,e){return e?this.project(t):this.addSequence(t)}buildImpl(t){return this.project(t)}project(t){if(t.length%this.dimsCount!=0)throw new Error(`Points size ('${t.length}') must be multiple of the dimensions count ('${this.dimsCount}').`);if(0==t.length)return[];let e=[],i=this.buffer.slice(),s=t.slice(0,t.length-this.dimsCount),r=this.addSequence(s);e.push(...r);let n=t.slice(t.length-this.dimsCount,t.length),a=this.predictionPointsCount;for(let t=0;t<a;t++){let i=this.addPoint(n);a-t<=this.pointsCount&&e.push(...i)}return this.buffer=i,e}addSequence(t){if(t.length%this.dimsCount!=0)throw new Error(`Points size ('${t.length}') must be multiple of the dimensions count ('${this.dimsCount}').`);let e=[],i=t.length/this.dimsCount;for(let s=0;s<i;s++){let i=this.addPoint(t.slice(s*this.dimsCount,(s+1)*this.dimsCount));e.push(...i)}return this.pointsCount+=i,e}addPoint(t){for(this.buffer.push(...t);this.buffer.length<this.windowSize*this.dimsCount;)this.buffer.unshift(...this.buffer.slice(0,this.dimsCount));for(;this.buffer.length>this.windowSize*this.dimsCount;)this.buffer=this.buffer.slice(this.dimsCount);return this.filterBuffer()}filterBuffer(){let t=[];for(let e=0;e<this.windowSize;e++)for(let i=0;i<this.dimsCount;i++)isNaN(t[i])&&(t[i]=0),t[i]+=this.buffer[e*this.dimsCount+i]*this.filter[e];return t}reset(){super.reset(),this.pointsCount=0,this.buffer.clear()}static resample(t,e){let i=new Float32Array(e),s=t.length/e,r=0;for(let n=0;n<e;n++){let a=(t.length-1)*n/(e-1),o=Math.floor(a),h=Math.ceil(a),l=a-o,u=s*(t[o]*(1-l)+t[h]*l);r+=u,i[n]=u}let n=1/r;for(let t=0;t<e;t++)i[t]*=n;return i}}class ht extends rt{constructor(t){super(),this.layout=t,this.pathPointProps={},this.lastSpline=[]}add(t,e){0==this.lastSpline.length&&t.length>0&&t.unshift(...t.slice(0,this.layout.length)),e&&(t.length>=this.layout.length?t.push(...t.slice(t.length-this.layout.length,t.length)):t.push(...this.getLastPart()));let i=this.getFirstPart();return this.lastSpline=i.concat(t),t}predict(t=[]){if(0==t.length)return t;let e=[],i=this.getFirstPart();for(e.push(...i),e.push(...t),e.push(...e.slice(e.length-this.layout.length,e.length));e.length<4*this.layout.length;)e.unshift(e.slice(0,this.layout.length));return e}buildImpl(t){let e=[];return t.length>0&&(e.push(...t.slice(0,this.layout.length)),e.push(...t),t.length>=this.layout.length&&e.push(...t.slice(t.length-this.layout.length,t.length))),t}getOutput(t,e){let i=e==ht.OutputType.ADDITION?this.lastSpline.length>=4*this.layout.length?this.lastSpline:[]:t;return 0==i.length?void 0:new x(this.layout,i,this.pathPointProps,0,1)}getFirstPart(){return this.lastSpline.slice(Math.max(0,this.lastSpline.length-3*this.layout.length),this.lastSpline.length)}getLastPart(){return this.lastSpline.slice(this.lastSpline.length-this.layout.length,this.lastSpline.length)}reset(){super.reset(),this.lastSpline=[]}}const lt=s.fromValues(0,-.5,1,-.5,1,0,-2.5,1.5,0,.5,2,-1.5,0,0,-.5,.5);class ut extends rt{constructor(t=!1,e=!1){super(),this.calculateDerivates=t,this.keepSplineParameters=e,this.state={lastPointPosition:void 0,lastPointSize:0}}initState(t){this.state.layout={},t.layout.forEach(((t,e)=>{this.state.layout[t.name]={index:e,polynomials:i.create()}})),this.keepSplineParameters&&(this.state.splineParameters=[]),this.splineLayout=t.layout,this.pathPointProps=Object.clone(t.pointProps),this.scattering&&(this.pathPointProps.scattering=this.scattering),this.layout=this.calculateDerivates?t.layout.concat([y.Property.D_X,y.Property.D_Y]):t.layout,this.state.ready=!0}predict(t){if(!t)return[];this.state.ready||this.initState(t);let e=Object.clone(this.state);delete this.state.splineParameters,this.resetState();let i=this.discretize(t);return this.state=e,i}buildImpl(t){return t?(this.state.ready||this.initState(t),this.discretize(t)):[]}getOutput(t,e){if(0!=t.length){let i=e==ut.OutputType.ALL_DATA?void 0:this.state.splineParameters;return i&&(i=i.slice()),new R(this.layout,t,this.pathPointProps,i)}}discretize(t){throw new Error("This method is abstract and should be implemented")}storeLastPoint(t,e=0){this.state.lastPointPosition=new o(this.getPropValue(y.Property.X,t,e),this.getPropValue(y.Property.Y,t,e),this.getPropValue(y.Property.Z,t,e)),this.state.lastPointSize=this.getPropValue(y.Property.SIZE,t,e)}getPropValue(t,e,i=0){return this.state.layout[t.name]?e[i+this.state.layout[t.name].index]:void 0}calculatePolynomials(t,e){let s=t.points,r=this.splineLayout.length*(e+0),n=this.splineLayout.length*(e+1),a=this.splineLayout.length*(e+2),o=this.splineLayout.length*(e+3);this.splineLayout.forEach(((t,e)=>{let h=i.fromValues(s[r+e],s[n+e],s[a+e],s[o+e]);i.transformMat4(this.state.layout[t.name].polynomials,h,lt)}))}calculateInterpolatedPoint(t,e,s){this.initState(t);let r=new y(0,0,this.splineLayout.includes(y.Property.Z)?0:void 0),n=i.fromValues(1,s,s*s,s*s*s);return this.calculatePolynomials(t,e),this.splineLayout.forEach((t=>{let e=i.dot(this.state.layout[t.name].polynomials,n);r[P.getPropName(t.name)]=e})),r}samplePoint(t){let e=[],s=i.fromValues(1,t,t*t,t*t*t);return this.splineLayout.forEach((t=>{let r=i.dot(this.state.layout[t.name].polynomials,s);e.push(r)})),this.calculateDerivates&&(e.push(this.getDerivativeOf(this.state.layout.X.polynomials,s)),e.push(this.getDerivativeOf(this.state.layout.Y.polynomials,s))),e}getDerivativeOf(t,e){let s=i.fromValues(t[1],2*t[2],3*t[3],0);return i.dot(s,e)}static defineParameter(t,e){return t>0&&0==e?{index:t-1,t:1}:{index:t,t:e}}keepSegmentT(t,e){this.state.splineParameters&&this.state.splineParameters.push(ut.defineParameter(t,e))}resetState(){}reset(){super.reset(),this.state.ready=!1,this.state.lastPointPosition=void 0,this.state.lastPointSize=0,delete this.state.splineParameters}}class ct extends ut{constructor(t=.1,e,i){super(e,i),this.spacing=t}split(t,e=8){let i=this.spacing;this.spacing=1,this.splitCount=e;let s=this.build(t);return this.spacing=i,delete this.splitCount,s}discretize(e){let i=[],s=this.splitCount,r=Math.max(1,10*(this.spacing>1?1:this.spacing));for(let n=0;n<e.segmentsCount;n++){if(this.calculatePolynomials(e,n),isNaN(this.splitCount)){let i=e.getPoint(n+1),a=e.getPoint(n+2),o=t.distance(i.value,a.value),h=this.pathPointProps.size;this.state.layout.SIZE&&(h=Math.min(i.size,a.size)),s=Math.floor(r*(o/h)/this.spacing)+1}let a=1/s;for(let t=0;t<=s;t++){let r=!this.state.lastPointPosition,h=t/s;if(0==n&&h<e.ts){if(!(h+a>=e.ts))continue;h=e.ts,r=this.spacing<=1}if(n==e.segmentsCount-1&&h>=e.tf){if(!(h<e.tf+a))continue;h=e.tf,r=this.lastSegment&&this.spacing<=1}if(n>0&&0==h)continue;let l=this.samplePoint(h);if(!r&&this.state.lastPointPosition){let t=new o(this.getPropValue(y.Property.X,l),this.getPropValue(y.Property.Y,l),this.getPropValue(y.Property.Z,l)),e=this.state.lastPointPosition.vec.squaredDistance(this.state.lastPointPosition.value,t.value),i=(this.state.layout.SIZE?(this.state.lastPointSize+l[this.state.layout.SIZE.index])/2:this.pathPointProps.size)*this.spacing;r=e>=i*i}r&&(i.push(...l),this.storeLastPoint(l),this.keepSegmentT(n,h))}}return this.state.splineParameters&&(0!=i.length&&this.state.splineParameters.first.t==e.ts||(i.unshift(...this.samplePoint(e.ts)),this.state.splineParameters.unshift(ut.defineParameter(0,e.ts))),this.state.splineParameters.last.t!=e.tf&&(i.push(...this.samplePoint(e.tf)),this.state.splineParameters.push(ut.defineParameter(e.segmentsCount-1,e.tf)))),i}}class pt{constructor(t){this.key=t,this.height=1}leftRotate(){let t=this.right,e=t.left;return t.left=this,this.right=e,this.height=Math.max(pt.height(this.left),pt.height(this.right))+1,t.height=Math.max(pt.height(t.left),pt.height(t.right))+1,t}rightRotate(){let t=this.left,e=t.right;return t.right=this,this.left=e,this.height=Math.max(pt.height(this.left),pt.height(this.right))+1,t.height=Math.max(pt.height(t.left),pt.height(t.right))+1,t}getBalanceFactor(){return pt.height(this.left)-pt.height(this.right)}static height(t){return t?t.height:0}static minValue(t){if(!t)return;let e=t;for(;e.left;)e=e.left;return e.key}static maxValue(t){if(!t)return;let e=t;for(;e.right;)e=e.right;return e.key}}class dt{constructor(){this.count=0,this.hasKey=!1,this.root}min(){return pt.minValue(this.root)}max(){return pt.maxValue(this.root)}add(t){return this.hasKey=!1,this.root=this.insertNode(this.root,t),this.hasKey||this.count++,!this.hasKey}insertNode(t,e){if(!t)return new pt(e);if(e<t.key)t.left=this.insertNode(t.left,e);else{if(!(e>t.key))return this.hasKey=!0,t;t.right=this.insertNode(t.right,e)}if(!this.hasKey){t.height=1+Math.max(pt.height(t.left),pt.height(t.right));let i=t.getBalanceFactor();if(i>1){if(e<t.left.key)return t.rightRotate();if(e>t.left.key)return t.left=t.left.leftRotate(),t.rightRotate()}else if(i<-1){if(e>t.right.key)return t.leftRotate();if(e<t.right.key)return t.right=t.right.rightRotate(),t.leftRotate()}}return t}contains(t){return this.containsNode(this.root,t)}containsNode(t,e){return!!t&&(e<t.key?this.containsNode(t.left,e):!(e>t.key)||this.containsNode(t.right,e))}printTree(){if(!this.root)return;let t=[this.root],e=this.root.height;for(;t.length>0;){let i=t.shift();e!=i.height&&console.log("-"),console.log(`${i.key} with height: ${i.height}, balance: ${i.getBalanceFactor()}`),e=i.height;let s=i.left,r=i.right;s&&t.push(s),r&&t.push(r)}}toArray(){let t=[];return dt.fillArray(t,this.root),t}static fillArray(t,e){e&&(this.fillArray(t,e.left),t.push(e.key),this.fillArray(t,e.right))}}class ft{constructor(){this.tree=new dt,Object.defineProperty(this,"length",{get:()=>this.tree.count,enumerable:!0})}clear(){this.tree=new dt}add(t){return this.tree.add(t)}includes(t){return this.tree.contains(t)}min(){return this.tree.min()}max(){return this.tree.max()}toArray(){return this.tree.toArray()}}class mt extends ut{constructor(t,e){super(t,e),this.state.segmentIndex=-1,this.state.lastSegmentIndex=-1,this.state.lastPointRotation=0,this.state.lastPointT=0,this.state.absAccumulatedErrorPos=0,this.state.absAccumulatedErrorS=0,this.setT=new ft,Object.defineProperty(this,"errorThreshold",{get:function(){return this.error},set:function(t){this.error=t,this.errorDistSq=this.error*this.error,this.error10=10*this.error},enumerable:!0}),this.errorThreshold=.15}discretize(t){let e=[],i=t.segmentsCount,s=i-1;for(let r=0;r<i;r++){this.calculatePolynomials(t,r);let i=this.calculateTValues(r==s,t.ts,t.tf);e.push(...this.samplePoints(r,i)),i.length>0&&(this.resetAccumulatedErrors(),this.storeLastPoint(e))}return e}samplePoints(t,e){let i=[];return e.toArray().forEach((e=>{this.keepSegmentT(t,e),i.push(...this.samplePoint(e))})),i}storeLastPoint(t){let e=t.length-this.layout.length;super.storeLastPoint(t,e),this.state.lastPointRotation=this.getPropValue(y.Property.ROTATION,t,e),this.state.lastPointT=this.setT.max(),this.state.lastSegmentIndex=this.state.segmentIndex}calculateTValues(t,e,i){this.state.segmentIndex++;let s=0==this.state.segmentIndex?e:0,r=t?i:1;return this.setT.clear(),this.getTForPos(s,r),this.state.layout.SIZE&&this.getTForCubic(s,r,this.state.layout.SIZE.polynomials,this.error),this.mustAddStartT()&&this.setT.add(s),t&&this.setT.add(r),this.state.layout.ROTATION&&this.getTForRotation(s,r),this.setT}mustAddStartT(){if(this.state.lastSegmentIndex<0)return!0;let t=this.state.lastPointT-(this.state.segmentIndex-this.state.lastSegmentIndex),e=this.setT.length>0?this.setT.min():1,i=this.getPosErrorAtT0(e,this.state.lastPointPosition);if(this.state.absAccumulatedErrorPos+=Math.abs(i),this.state.layout.SIZE){let i=this.getErrorAtT0(this.state.layout.SIZE.polynomials,e,t,this.state.lastPointSize);this.state.absAccumulatedErrorS+=Math.abs(i)}return this.state.absAccumulatedErrorPos>this.errorDistSq||this.state.absAccumulatedErrorS>this.error}getPosErrorAtT0(t,e){let i=this.getTPoint(t),s=this.getTPoint(0);return this.minDistanceSq(e,i,s)}getErrorAtT0(t,e,i,s){let r=i,n=s,a=e,o=this.cubicCalc(t,a),h=this.cubicCalc(t,0),l=n+(0-r)*(o-n)/(a-r);return Math.abs(h-l)}getTForPos(t,e){let i=this.getTPoint(t),s=this.getTPoint(e),r=this.subdividePos(i,s);if(r.split)this.subdivideRecursivePos(i,r),this.setT.add(r.t),this.subdivideRecursivePos(r,s);else{let t=this.subdividePos(i,r),e=this.subdividePos(r,s);t.split&&(this.subdivideRecursivePos(i,t),this.setT.add(t.t),this.subdivideRecursivePos(t,r)),(t.split||e.split)&&this.setT.add(r.t),e.split&&(this.subdivideRecursivePos(r,e),this.setT.add(e.t),this.subdivideRecursivePos(e,s))}}subdivideRecursivePos(t,e){let i=this.subdividePos(t,e);i.split&&(this.subdivideRecursivePos(t,i),this.setT.add(i.t),this.subdivideRecursivePos(i,e))}subdividePos(t,e){let i=.5*(t.t+e.t),s=this.getTPoint(i),r=this.minDistanceSq(t,e,s),n=t.add(e).scaleSelf(.5),a=s.subtract(n).absSelf();return s.split=r>this.errorDistSq||a.x>this.error10||a.y>this.error10,this.state.layout.Z&&(s.split=s.split||a.z>this.error10),s}getTForCubic(t,e,i,s){let r={v:this.cubicCalc(i,t),t:t},n={v:this.cubicCalc(i,e),t:e},a=this.subdivide(r,n,i);if(a.diff>s)this.subdivideRecursive(r,a,i,s),this.setT.add(a.t),this.subdivideRecursive(a,n,i,s);else{let t=this.subdivide(r,a,i),e=this.subdivide(a,n,i);t.diff>s&&(this.subdivideRecursive(r,t,i,s),this.setT.add(t.t),this.subdivideRecursive(t,a,i,s)),(t.diff>s||e.diff>s)&&this.setT.add(a.t),e.diff>s&&(this.subdivideRecursive(a,e,i,s),this.setT.add(e.t),this.subdivideRecursive(e,n,i,s))}}subdivideRecursive(t,e,i,s){let r=this.subdivide(t,e,i);r.diff>s&&(this.subdivideRecursive(t,r,i,s),this.setT.add(r.t),this.subdivideRecursive(r,e,i,s))}subdivide(t,e,i){let s=.5*(t.t+e.t),r=this.cubicCalc(i,s),n=.5*(t.v+e.v);return{v:r,t:s,diff:Math.abs(r-n)}}getTForRotation(t,e){let i=this.state.layout.ROTATION.polynomials,s=this.state.lastPointRotation;this.state.lastSegmentIndex<0&&(s=this.cubicCalc(i,t));let r=.25*(e-t);for(let e=0;e<4;e++){let n=t+e*r,a=this.cubicCalc(i,n);Math.abs(a-s)>.06&&(this.setT.add(n),s=a)}}minDistanceSq(t,e,i){let s=i.vec,r=s.squaredDistance(t.value,e.value);if(0==r)return s.squaredDistance(i.value,t.value);let n=Math.max(0,Math.min(1,s.dot(i.subtract(t).value,e.subtract(t).value)/r)),a=e.subtract(t).scale(n).add(t);return s.squaredDistance(i.value,a.value)}getTPoint(t){let e=new o(this.cubicCalc(this.state.layout.X.polynomials,t),this.cubicCalc(this.state.layout.Y.polynomials,t),this.state.layout.Z?this.cubicCalc(this.state.layout.Z.polynomials,t):void 0);return e.t=t,e}cubicCalc(t,e){return t[0]+t[1]*e+t[2]*e*e+t[3]*e*e*e}resetAccumulatedErrors(){this.state.absAccumulatedErrorPos=0,this.state.absAccumulatedErrorS=0}resetState(){this.state.segmentIndex=-1,this.state.lastSegmentIndex=-1,this.state.lastPointT=0,this.state.lastPointRotation=0,this.resetAccumulatedErrors()}reset(){super.reset(),this.resetState()}}class yt extends rt{static ARRAY_TYPE=st;constructor(t){super(),this.brush=t}buildImpl(t){return this.generatePolygons(t)}generatePolygons(t){let e=new st;if(!t)return e;for(let i=0;i<t.length;i++){let s=t.getPoint(i),r=this.applyBrush(s);e.push(r)}return e}applyBrush(t){let e=this.createTransform(t),s=this.brush.selectShape(e.maxScale).shape,r=Float32Array.createSharedInstance(2*s.length);for(let t=0;t<s.length;t++){let n=t*s.stride,a=i.fromValues(s.getPointX(t),s.getPointY(t),0,1);i.transformMat4(a,a,e),r[n]=a[0]/a[3],r[n+1]=a[1]/a[3]}return U.createSharedInstance(r)}createTransform(t){if(isNaN(t.size))throw new Error("Size information not found.");let i=s.create(),r=t.size*t.scaleX,n=t.size*t.scaleY,a=t.size*t.scaleZ||0,o=Math.max(r,n,a);return s.translate(i,i,e.fromValues(t.x,t.y,t.z||0)),s.rotateZ(i,i,t.rotation),s.translate(i,i,e.fromValues(t.offsetX,t.offsetY,t.offsetZ||0)),s.scale(i,i,e.fromValues(r,n,a)),i.maxScale=o,i}}class gt extends rt{static ARRAY_TYPE=st;constructor(){super(),this.lastPolygon}add(t,e){return this.buildConvexHulls(t,!0)}buildImpl(t){if(!(t instanceof st)){if(!(t instanceof U))throw new Error("ConvexHullChainProducer build 'input' type missmatch, expected type is oneof(Polygon, InkPath2D)");t=[t]}return this.buildConvexHulls(t)}buildConvexHulls(t,e=!1){let i=new st,s=this.lastPolygon;for(let e of t){if(s||1==t.length){let t=s?s.union(e):e.convex();i.push(t)}s=e}return e&&t.length>0&&(this.lastPolygon=t.last),i}reset(){super.reset(),this.lastPolygon=null}}let Pt=!1;class bt{constructor(t,e,i=bt.WorkerType.CLASSIC){if(!Pt)throw new Error("Constructor is private, use static method getInstance instead.");this.name=t,this.type=i,e&&e.startsWith("file://")&&(e=e.replace("file://","")),this.src=e,this.workers=[],this.transferables=[],this.status=bt.Status.CLOSED,this.resolver={};let s=0;Object.defineProperty(this,"nextID",{get:()=>String(s++),enumerable:!0,configurable:!0})}async open(t=this.src){if(this.status!=bt.Status.CLOSED)throw new Error(`${this.name} worker cannot be opened. Current status is ${this.status.name}.`);if(!t)throw new Error(`${this.name} worker location is not deined.`);let e,i;if("function"==typeof Worker)e=Worker,i=navigator.hardwareConcurrency||1;else{const t=await import("os"),s=await import("worker_threads"),{Worker:r}=s;e=r,i=t.cpus().length}this.ready=0;for(let s=0;s<i;s++){let i=this.name+s,r=new e(t,{type:this.type,name:i,workerData:{name:i}});r.name=s,r.on("message",(t=>"INIT"==t.action?this.confirmWorkerReady():this.recieve(t))),r.on("error",(t=>this.recieveError(t,s))),this.workers.push(r)}return this.status=bt.Status.OPEN_IN_PROGRESS,new Promise(((t,e)=>{this.workers.forEach(((t,e)=>t.postMessage({action:"INIT",worker:e}))),this.resolve=t}))}confirmWorkerReady(){this.ready++,this.ready==this.workers.length&&(this.resolve(),delete this.ready,delete this.resolve,this.status=bt.Status.OPEN)}close(){this.workers.forEach((t=>t.terminate())),this.workers.clear(),this.status=bt.Status.CLOSED}async broadcast(t,e){if(this.status!=bt.Status.OPEN)throw new Error(`ThreadBridge is not opened yet. Current status is ${this.status.name}. Use open first.`);return new Promise(((i,s)=>{this.resolver[e]=i;for(let i of this.workers){let s=this.buildRequestMessage(t,e);if(!s)break;this.send(i.name,s)}}))}async broadcastMessage(t){if(this.status!=bt.Status.OPEN)throw new Error(`ThreadBridge is not opened yet. Current status is ${this.status.name}. Use open first.`);if(!t.actionID)throw new Error("message actionID is required");return new Promise(((e,i)=>{this.resolver[t.actionID]=e;for(let e of this.workers)this.send(e.name,t)}))}send(t,e){if(this.status!=bt.Status.OPEN)throw new Error(`ThreadBridge is not opened yet. Current status is ${this.status.name}. Use open first.`);if(!e)throw new Error("message is required");this.workers[t].postMessage(e,this.transferables),this.transferables.clear()}buildRequestMessage(t,e){throw new Error("ThreadBridge.buildRequestMessage(action, actionID) is abstract and should be implemented")}recieve(t){throw new Error("ThreadBridge.recieve(message) is abstract and should be implemented")}resolve(t,e){this.resolver[t](e),delete this.resolver[t]}recieveError(t,e){console.warn(`${this.name} worker ${e}: ${t.message}`),t.filename||console.error(t)}static getInstance(){return this.instance||(Pt=!0,this.instance=new this,Pt=!1),this.instance}}Object.defineEnum(bt,"Status",["OPEN","OPEN_IN_PROGRESS","CLOSED"]),bt.WorkerType={CLASSIC:"classic",MODULE:"module"};let Et=a?a.default||globalThis.ClipperLib:{};const{Clipper:wt,Paths:St,Path:vt,ClipType:It,PolyType:Ot,PolyFillType:Tt}=Et;class At{constructor(t){if(t instanceof U&&(t=new st(t)),!(t instanceof st))throw new Error("Unexpected path type found");let e=t.bounds,i=65534/(e.width+1e-16),s=65534/(e.height+1e-16),r=Math.floor(Math.min(i,s)),n=e.left+32767/r,a=e.top+32767/r;this.solution=new St,this.bounds=e,this.transform={scale:r,offsetX:n,offsetY:a},this.subject=this.apply(t)}convertPoint(t){let e=(t.x-this.transform.offsetX)*this.transform.scale,i=(t.y-this.transform.offsetY)*this.transform.scale;return{X:e<0?Math.ceil(e):Math.floor(e),Y:i<0?Math.ceil(i):Math.floor(i)}}containsPoint(t){return wt.PointInPolygon(this.convertPoint(t),this.solution)}apply(t){let e=new St;if(t instanceof U&&(t=new st(t)),!(t instanceof st))throw new Error("Unexpected path type found");for(let i of t){let t=new vt,s=i.shape;for(let e=0;e<s.length;e++)t.push(this.convertPoint({x:s.getPointX(e),y:s.getPointY(e)}));e.push(t)}return e}toPolygon(){let t=[];this.lastPoint={};for(let e of this.solution)0!=e.length&&t.push(this.flatPath(e));return U.createSharedInstance(t.first,t.slice(1))}flatPath(t){let e=[];for(let i of t)this.lastPoint.X!=i.X||this.lastPoint.Y!=i.Y?(e.push(i.X/this.transform.scale+this.transform.offsetX,i.Y/this.transform.scale+this.transform.offsetY),this.lastPoint=i):console.warn(`Duplicate point detected: {${i.X}, ${i.Y}}`);return e.length<6&&(console.warn(`Invalid contour found: [${e.join(", ")}]`),e.clear()),e}}class xt{static union(t){let e=new At(t);return e.subject=wt.SimplifyPolygons(e.subject,Tt.pftNonZero),e.solution=wt.CleanPolygons(e.subject,.1*e.transform.scale),1==e.subject.length&&0==e.solution.first.length&&(e.solution=e.subject),e.toPolygon()}static simplify(t){let e,i=new it,s=this.createClipperPath(t);e=wt.SimplifyPolygon(s,Tt.pftNonZero),e=wt.CleanPolygons(e,.1*s.scale);for(let t of e)0!=t.length&&i.push(U.createSharedInstance(xt.fromClipperPath(t,s.scale)));return i}static createClipperPath(t,e=32){let i=new vt;i.scale=e;for(let s=0;s<t.length;s++)i.push({X:Math.round(t.getPointX(s)*e),Y:Math.round(t.getPointY(s)*e)});return i}static fromClipperPath(t,e=t.scale||32){let i=Float32Array.createSharedInstance(2*t.length);for(let s=0;s<t.length;s++){let r=t[s],n=2*s;i[n]=r.X/e,i[n+1]=r.Y/e}return i}static containsPoint(t,e){let i={X:Math.round(e.x*t.scale),Y:Math.round(e.y*t.scale)};return 1==wt.PointInPolygon(i,t)}}class Rt extends rt{static ARRAY_TYPE=st;constructor(){super()}predict(t){return console.warn("Prediction merge is not recommended"),t}buildImpl(t){return this.merge(t)}merge(t){if(0!=t.length)return xt.union(t)}}class Nt extends rt{static ARRAY_TYPE=st;constructor(t=.1){super(),this.epsilon=t}predict(t){return console.warn("Prediction simplify is not recommended"),t}buildImpl(t){return t instanceof U?t.simplify(this.epsilon):new t.constructor(...t.map((t=>t.simplify(this.epsilon))))}}function Mt(){}Object.defineEnum(Mt,"Stage",["PATH_PRODUCER","SMOOTHER","SPLINE_PRODUCER","SPLINE_INTERPOLATOR","BRUSH_APPLIER","CONVEX_HULL_CHAIN_PRODUCER","POLYGON_MERGER","POLYGON_SIMPLIFIER"]);const Ct=Mt.Stage,Ft=tt.Phase,Lt=rt.OutputType,_t=[Ct.SMOOTHER,Ct.POLYGON_MERGER,Ct.POLYGON_SIMPLIFIER],Dt=[Ct.SPLINE_INTERPOLATOR,Ct.BRUSH_APPLIER,Ct.CONVEX_HULL_CHAIN_PRODUCER,Ct.POLYGON_MERGER,Ct.POLYGON_SIMPLIFIER];class jt{constructor(){this.layout=[y.Property.X,y.Property.Y],this.pathSegment=new et,this.pathProducer=new nt(this.layout),this.smoother=new ot(this.layout.length),this.splineProducer=new ht(this.layout),this.distanceInterpolator=new ct,this.curvatureInterpolator=new mt,this.brushApplier=new yt,this.polygonMerger=new Rt,this.polygonSimplifier=new Nt,this.splineProducer.keepAllData=!0,this.phase=void 0,this.pointerID=void 0,this.concatSegments=!1,this.lastPipelineStage=void 0,this.excludedPipelineStages=[],this.configured=!1,Object.defineProperty(this,"prediction",{get:()=>this.pathProducer.prediction,set:t=>this.pathProducer.prediction=t,enumerable:!0})}configure(t={}){if(this.reset(this.pointerID),t.onBuildComplete)throw new Error("InkBuilderSettings onBuildComplete property is deprecated. Use InkBuilder instance onComplete property to set callback.");if("mergePrediction"in t&&console.warn("InkBuilderSettings 'mergePrediction' property is deprecated. Do not affects PolygonMerger behaviour."),!t.brush)throw new Error("InkBuilderSettings brush property is required");if(t.excludedPipelineStages){if(!Array.isArray(t.excludedPipelineStages))throw new Error("Expected type of excludedPipelineStages is Array instance");let e=t.excludedPipelineStages.filter((t=>!_t.includes(t)));e.length>0&&console.warn(`excludedPipelineStages property includes steps which cannot be excluded: ${e.map((t=>t.name)).join(", ")}`),this.excludedPipelineStages=t.excludedPipelineStages}if(!this.excludedPipelineStages.includes(Ct.SMOOTHER)&&t.movingAverageWindowSize&&(this.smoother.movingAverageWindowSize=t.movingAverageWindowSize),t.lastPipelineStage){if(!Dt.includes(t.lastPipelineStage))throw new Error(`lastPipelineStage property expects one of: ${Dt.map((t=>t.name)).join(", ")}`);if(this.excludedPipelineStages.includes(t.lastPipelineStage))throw new Error(`lastPipelineStage ${t.lastPipelineStage.name} is disabled, check excludedPipelineStages configuration`);if(t.brush instanceof K&&t.lastPipelineStage!=Ct.SPLINE_INTERPOLATOR)throw new Error(`lastPipelineStage ${t.lastPipelineStage.name} is not compatible with provided brush`);this.lastPipelineStage=t.lastPipelineStage}switch(this.brush=t.brush,this.brush instanceof Z&&(this.brushApplier.brush=this.brush),this.lastPipelineStage||(this.brush instanceof Z?(this.brush.spacing>1?this.lastPipelineStage=Ct.BRUSH_APPLIER:this.excludedPipelineStages.includes(Ct.POLYGON_SIMPLIFIER)&&this.excludedPipelineStages.includes(Ct.POLYGON_MERGER)?this.lastPipelineStage=Ct.CONVEX_HULL_CHAIN_PRODUCER:this.lastPipelineStage=Ct.POLYGON_MERGER,this.lastPipelineStage==Ct.POLYGON_MERGER&&(this.concatSegments=Boolean(t.concatSegments))):this.lastPipelineStage=Ct.SPLINE_INTERPOLATOR),this.lastPipelineStage==Ct.SPLINE_INTERPOLATOR||this.lastPipelineStage==Ct.BRUSH_APPLIER?(this.splineInterpolator=this.distanceInterpolator,this.splineInterpolator.spacing=this.brush.spacing,this.splineInterpolator.scattering=this.brush.scattering,this.splineInterpolator.calculateDerivates=this.brush instanceof K):(this.splineInterpolator=this.curvatureInterpolator,this.splineInterpolator.errorThreshold=t.errorThreshold||.15),this.splineInterpolator.keepAllData=!1,this.brushApplier.keepAllData=!1,this.convexHullChainProducer.keepAllData=!1,this.polygonMerger.keepAllData=!1,this.polygonSimplifier.keepAllData=!1,this.lastPipelineStage){case Ct.SPLINE_INTERPOLATOR:this.splineInterpolator.keepAllData=!0;break;case Ct.BRUSH_APPLIER:this.brushApplier.keepAllData=!0;break;case Ct.CONVEX_HULL_CHAIN_PRODUCER:this.convexHullChainProducer.keepAllData=!0;break;case Ct.POLYGON_MERGER:this.polygonMerger.keepAllData=!0;break;case Ct.POLYGON_SIMPLIFIER:this.polygonSimplifier.keepAllData=!0;break;default:throw console.warn(this.lastPipelineStage),new Error("Invalid lastPipelineStage found")}if(this.lastPipelineStage==Ct.POLYGON_SIMPLIFIER&&(console.warn("InkBuilderSettings: Pipeline stage POLYGON_SIMPLIFIER is deprecated. POLYGON_MERGER stage is recommended as last stage."),this.polygonSimplifier.epsilon=t.epsilon||.1),t.pathPointCalculator&&(this.calculator=t.pathPointCalculator,this.pathProducer.pathPointCalculator=t.pathPointCalculator),!t.layout)throw new Error("InkBuilderSettings layout property is required");{let e=t.pathPointProps||{};if(this.layout=t.layout,this.brush instanceof Z){if(this.layout.includes(y.Property.RED))throw new Error("RED layout channel is not supported for non particles strokes");if(this.layout.includes(y.Property.GREEN))throw new Error("GREEN layout channel is not supported for non particles strokes");if(this.layout.includes(y.Property.BLUE))throw new Error("BLUE layout channel is not supported for non particles strokes");if(this.layout.includes(y.Property.ALPHA))throw new Error("ALPHA layout channel is not supported for non particles strokes")}if(!this.layout.includes(y.Property.RED)&&isNaN(e.red))throw new Error("Stroke color red channel information is required. Please provide via layout or through configure settings via pathPointProps property.");if(!this.layout.includes(y.Property.GREEN)&&isNaN(e.green))throw new Error("Stroke color green channel information is required. Please provide via layout or through configure settings via pathPointProps property.");if(!this.layout.includes(y.Property.BLUE)&&isNaN(e.blue))throw new Error("Stroke color blue channel information is required. Please provide via layout or through configure settings via pathPointProps property.");if(!this.layout.includes(y.Property.ALPHA)&&isNaN(e.alpha))throw new Error("Stroke color alpha channel information is required. Please provide via layout or through configure settings via pathPointProps property.");this.pathProducer.layout=this.layout,this.smoother.dimsCount=this.layout.length,this.splineProducer.layout=this.layout,this.splineProducer.pathPointProps=e}this.configured=!0}add(t,e){if(!this.configured)throw new Error("InkBuilder instance is not configured yet, use configure method to configure the instance.");if(!this.calculator)throw new Error("InkBuilder instance is not configured properly, pathPointCalculator property is required");if(!t.phase)throw new Error("SensorPoint phase is not found");this.phase=t.phase;let i,s=new Q(t);e&&(this.prediction?i=new Q(e):console.warn("Prediction sensor point is available, but ignored, prediction is disabled")),this.device&&(this.phase==nt.Phase.BEGIN&&this.device.openStream(t),this.device.add(s),this.phase==nt.Phase.END&&(this.sensorData=this.device.closeStream()));let r=this.pathProducer.add(this.phase,s,i);this.pathSegment.add(this.phase,r.added,r.predicted)}ignore(t){if(!t.phase)throw new Error("SensorPoint phase is not found");this.device&&t&&t.phase==nt.Phase.UPDATE&&this.device.add(new Q(t),!0)}build(){throw new Error("InkBuilderAbstract.build() is abstract and should be implemented")}processSegment(t,e,i){throw new Error("InkBuilderAbstract.processSegment(path, type, lastSegment) is abstract and should be implemented")}getSensorData(){return this.sensorData}getSpline(){return this.splineProducer.allData}getInkPath(){let t;switch(this.lastPipelineStage){case Ct.SPLINE_INTERPOLATOR:t=this.splineInterpolator.allData;break;case Ct.BRUSH_APPLIER:t=this.brushApplier.allData;break;case Ct.CONVEX_HULL_CHAIN_PRODUCER:t=this.convexHullChainProducer.allData;break;case Ct.POLYGON_MERGER:t=this.polygonMerger.allData;break;case Ct.POLYGON_SIMPLIFIER:t=this.polygonSimplifier.allData;break;default:throw console.warn(this.lastPipelineStage),new Error("Invalid lastPipelineStage found")}if(this.concatSegments){let e;this.lastPipelineStage!=Ct.POLYGON_MERGER&&this.lastPipelineStage!=Ct.POLYGON_SIMPLIFIER||(e=this.polygonMerger.build(t)),this.lastPipelineStage==Ct.POLYGON_SIMPLIFIER&&(e=this.polygonSimplifier.build(e)),e&&(t=new st(e))}return t}abort(){this.device&&this.device.closeStream(!0),this.reset()}reset(t){this.pointerID=t,this.phase=void 0,this.concatSegments=!1,this.lastPipelineStage=void 0,this.excludedPipelineStages.clear(),this.sensorData=void 0,this.pathProducer.reset(),this.smoother.reset(),this.splineProducer.reset(),this.distanceInterpolator.reset(),this.curvatureInterpolator.reset(),this.brushApplier.reset(),this.convexHullChainProducer.reset(),this.polygonMerger.reset(),this.polygonSimplifier.reset(),this.configured=!1}}jt.Phase=nt.Phase;class $t extends jt{constructor(){super(),this.convexHullChainProducer=new gt}build(){let t=this.buildSegment();return t.phase=this.phase,t.pointerID=this.pointerID,this.onComplete&&this.onComplete(t),this.phase==Ft.END&&delete this.phase,t}buildSegment(){let t={};return this.pathSegment.accumulatedAddition.length>0&&(t.added=this.processSegment(this.pathSegment.accumulatedAddition,Lt.ADDITION,this.pathSegment.last),t.added&&(t.added.segment=!0)),this.prediction&&this.pathSegment.lastPrediction.length>0&&(t.predicted=this.processSegment(this.pathSegment.lastPrediction,Lt.PREDICTION,this.pathSegment.last),t.predicted&&(t.predicted.segment=!0)),this.pathSegment.reset(),t}processSegment(t,e,i){if(this.excludedPipelineStages.includes(Ct.SMOOTHER)||(t=this.smoother.build(t,e,i)),t=this.splineProducer.build(t,e,i))return this.processSpline(t,e,i)}processSpline(t,e=Lt.PROCESSOR,i=!0){let s,r=this.splineInterpolator.build(t,e,i);if(this.lastPipelineStage==Ct.SPLINE_INTERPOLATOR)return r;if(r)return r=this.brushApplier.build(r,e,i),this.lastPipelineStage==Ct.BRUSH_APPLIER?r:(r=this.convexHullChainProducer.build(r,e,i),this.lastPipelineStage==Ct.CONVEX_HULL_CHAIN_PRODUCER||e==Lt.PREDICTION?r:this.excludedPipelineStages.includes(Ct.POLYGON_MERGER)||(s=this.polygonMerger.build(r,e,i),this.lastPipelineStage!=Ct.POLYGON_MERGER)?(this.excludedPipelineStages.includes(Ct.POLYGON_SIMPLIFIER)||(s=this.polygonSimplifier.build(s,e,i)),new st(s)):new st(s));if(e==Lt.PROCESSOR)throw new Error("InkBuilder processSpline failed for spline",t)}}(class extends class{constructor(){this.worker,this.transferables=[]}async recieve(t){let e;"INIT"==t.action?(this.worker=t.worker,e=await this.init(t)):e=await this.process(t),e.worker=this.worker,this.send(e)}send(t){self.postMessage(t,this.transferables),this.transferables.length=0}async init(t){return t}async process(t){throw new Error("ThreadProcessor.process(message) is abstract and should be implemented")}static async connect(...t){let e=new this(...t);if("undefined"==typeof self){const t=await import("worker_threads"),{parentPort:e,workerData:i}=t;global.self=e,self.name=i.name,self.data=i}self.on("message",(async t=>await e.recieve(t)))}}{constructor(){super(),this.builder=new $t,this.brushes={}}process(t){let e={action:t.action,actionID:t.actionID};switch(t.action){case"IMPORT_BRUSHES":this.importBrushes(t.brushes);break;case"BUILD":{let{splineBuffer:i,path:s}=this.build(t.brushName,t.spline);e.splineBuffer=i,e.path=s.toJSON(),e.index=t.index;break}default:throw new Error(`Unknow data action found: ${t.action}`)}return e}importBrushes(t){for(let e of t)this.brushes[e.name]||("Brush2D"==e.type?this.brushes[e.name]=Z.fromJSON(e):this.brushes[e.name]=K.fromJSON(e))}build(t,e){let i={},s=this.brushes[t],r=x.fromJSON(e);this.builder.configure({brush:s,layout:r.layout,pathPointProps:r.pointProps});let n=this.builder.processSpline(r);return r.points.buffer instanceof ArrayBuffer&&(i.splineBuffer=r.points.buffer,this.transferables.push(r.points.buffer)),n instanceof R&&(n.points.buffer instanceof ArrayBuffer&&this.transferables.push(n.points.buffer),n.encoding=I.Encoding.NONE),i.path=n,i}}).connect();
