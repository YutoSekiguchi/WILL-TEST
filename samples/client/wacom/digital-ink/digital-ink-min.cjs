"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),require("js-ext");var e=require("js-md5"),t=require("long"),r=require("gl-matrix"),i=require("poly2tri"),s=require("clipper-lib"),n=require("rbush"),o=require("jszip"),a=require("protobufjs");function l(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function h(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var i=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,i.get?i:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var d=h(e),c=h(t),u=h(i),p=h(s),f=l(n),m=h(o),g=h(a);class y{getInkBuilder(e){throw new Error("InkController.getInkBuilder(pointerID) is abstract and should be implemented")}registerInputProvider(e,t){throw new Error("InkController.registerInputProvider(pointerID, isPrimary) is abstract and should be implemented")}reset(e){throw new Error("InkController.reset(sensorPoint) is abstract and should be implemented")}begin(e){throw new Error("InkController.begin(sensorPoint) is abstract and should be implemented")}move(e,t){throw new Error("InkController.move(sensorPoint, [prediction]) is abstract and should be implemented")}end(e){throw new Error("InkController.end(sensorPoint) is abstract and should be implemented")}abort(e){throw new Error("InkController.abort(pointerID) is abstract and should be implemented")}resize(e){throw new Error("InkController.resize() is abstract and should be implemented")}}let b=d?d.default||globalThis.md5:{},E=c?c.default||globalThis.Long:{},P={mask:"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx",generate(){let e=Date.now();return this.mask.replace(/[xy]/g,(function(t){let r=(e+16*Math.random())%16|0;return e=Math.floor(e/16),("x"==t?r:3&r|8).toString(16)}))},validate:e=>"string"==typeof e&&!!e.match(/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/),format(e){let t=[],r=0;return this.mask.split("-").forEach((i=>{t.push(e.substring(r,r+i.length)),r+=i.length})),t.join("-")},fromString(e){return this.fromBytes(new Uint8Array(b.arrayBuffer(e)))},toBytes(e){let t=[];return e.split("-").map(((e,r)=>{(r<3?e.match(/.{1,2}/g).reverse():e.match(/.{1,2}/g)).map((e=>t.push(parseInt(e,16))))})),new Uint8Array(t)},fromBytes(e){let t=Array.from(e).map((e=>e.toString(16))).map((e=>(1==e.length?"0":"")+e));return t.slice(0,4).reverse().join("")+"-"+t.slice(4,6).reverse().join("")+"-"+t.slice(6,8).reverse().join("")+"-"+t.slice(8,10).join("")+"-"+t.slice(10).join("")},toUint32Array(e){let t=new Uint32Array(4),r=this.toBytes(e);return t[0]=new Uint32Array(r.slice(0,4).buffer)[0],t[1]=new Uint32Array(r.slice(4,8).buffer)[0],t[2]=new Uint32Array(r.slice(8,12).buffer)[0],t[3]=new Uint32Array(r.slice(12).buffer)[0],t},fromUint32Array(e){return this.fromBytes(new Uint8Array(e.buffer))},toUint64Array(e){let t=new BigUint64Array(2),r=this.toBytes(e);return t[0]=new BigUint64Array(r.slice(0,8).buffer)[0],t[1]=new BigUint64Array(r.slice(8).buffer)[0],t},fromUint64Array(e){return this.fromBytes(new Uint8Array(e.buffer))},toLongArray(e){let t=new Array(2),r=this.toBytes(e);return t[0]=E.fromBytes(r.slice(0,8)),t[1]=E.fromBytes(r.slice(8)),t},fromLongArray(e){let t=e[0].toBytes().concat(e[1].toBytes());return this.fromBytes(t)}};class I{static get SEPARATOR(){return"\n"}constructor(e){let t;if(t="function"==typeof this.getMD5Message?I.Algorithm.MD5:"function"==typeof this.buildURI?I.Algorithm.URI:I.Algorithm.GUID,t==I.Algorithm.MD5&&(this.invalidateID=()=>e=void 0),Object.defineProperty(this,"id",{get:function(){return e||(e=this.resolveID()),e},set:function(t){if(e)throw new Error("id is immutable");e=t},enumerable:!0}),e&&t==I.Algorithm.GUID&&!P.validate(e))throw new Error(`Identifiable ${e} is not a well formed UUID`);Object.defineProperty(this,"algorithm",{value:t})}resolveID(){if(this.algorithm==I.Algorithm.MD5){let e="",t=this.getMD5Message();for(let r of t){if(Array.isArray(r))for(let t of r)e+=t,e+="\n";else e+=r;e+="\n"}if(!e)throw new Error("Empty MD5 message container found");return b(e)}return this.algorithm==I.Algorithm.URI?this.buildURI():P.generate()}static buildMD5Tokens(e){let t=[];return Object.keys(e).sort().forEach((r=>t.push(r,e[r]))),t}}Object.defineEnum(I,"Algorithm",["GUID","MD5","URI"]);class S extends I{constructor(e,t={}){super(),this.type=e,this.props=Object.assign({},t)}getMD5Message(){if(!Object.isFrozen(this))throw new Error("ID generation failed. InkInputProvider do not belongs to any SensorChannelsContext yet");return["InkInputProvider",this.type.name,I.buildMD5Tokens(this.props)]}}Object.defineEnum(S,"Type",["PEN","TOUCH","MOUSE","CONTROLLER"]);class x{constructor(){this.phase=x.Phase.END}add(e,t,r){if(!this.move(e))throw new Error(`Cannot move from phase ${this.phase.name} to phase ${e.name}`);return this.debug&&(console.log("-------------------------------------"),console.log(this.constructor.name,e.name)),this.addImpl(t,r)}addImpl(e,t){throw new Error("Abstract method addImpl of DataProcessor should be implemented")}move(e){return(this.phase!=x.Phase.END||e==x.Phase.BEGIN)&&((this.phase!=x.Phase.BEGIN||e==x.Phase.UPDATE||e==x.Phase.END)&&((this.phase!=x.Phase.UPDATE||e==x.Phase.UPDATE||e==x.Phase.END)&&(e==x.Phase.BEGIN&&this.reset(),this.phase=e,!0)))}reset(){this.phase=x.Phase.END}}Object.defineEnum(x,"Phase",["BEGIN","UPDATE","END"]);class w{constructor(e,t,i,s){if(isNaN(e))throw new Error(`Invalid x found: ${e}`);if(isNaN(t))throw new Error(`Invalid y found: ${t}`);let n=[e,t];isFinite(i)&&(n.push(i),isFinite(s)&&n.push(s)),this.value=n.toFloat32Array(),Object.defineProperty(this,"x",{get:()=>this.value[0],set:e=>{this.value[0]=e},enumerable:!0}),Object.defineProperty(this,"y",{get:()=>this.value[1],set:e=>{this.value[1]=e},enumerable:!0}),2==n.length?this.vec=r.vec2:3==n.length?(this.vec=r.vec3,Object.defineProperty(this,"z",{get:()=>this.value[2],set:e=>{this.value[2]=e},enumerable:!0})):(this.vec=r.vec4,Object.defineProperty(this,"w",{get:()=>this.value[3],set:e=>{this.value[3]=e},enumerable:!0}))}add(e){e instanceof w||(e=w.fromPoint(e));let t=this.vec.create();return this.vec.add(t,this.value,e.value),w.fromPoint(t)}addSelf(e){return e instanceof w||(e=w.fromPoint(e)),this.vec.add(this.value,this.value,e.value),this}subtract(e){e instanceof w||(e=w.fromPoint(e));let t=this.vec.create();return this.vec.subtract(t,this.value,e.value),w.fromPoint(t)}subtractSelf(e){return e instanceof w||(e=w.fromPoint(e)),this.vec.subtract(this.value,this.value,e.value),this}multiply(e){e instanceof w||(e=w.fromPoint(e));let t=this.vec.create();return this.vec.multiply(t,this.value,e.value),w.fromPoint(t)}multiplySelf(e){return e instanceof w||(e=w.fromPoint(e)),this.vec.multiply(this.value,this.value,e.value),this}divide(e){e instanceof w||(e=w.fromPoint(e));let t=this.vec.create();return this.vec.divide(t,this.value,e.value),w.fromPoint(t)}divideSelf(e){return e instanceof w||(e=w.fromPoint(e)),this.vec.divide(this.value,this.value,e.value),this}scale(e){let t=this.vec.create();return this.vec.scale(t,this.value,e),w.fromPoint(t)}scaleSelf(e){return this.vec.scale(this.value,this.value,e),this}abs(){return new w(Math.abs(this.x),Math.abs(this.y),isFinite(this.z)?Math.abs(this.z):void 0,isFinite(this.w)?Math.abs(this.w):void 0)}absSelf(){return this.x=Math.abs(this.x),this.y=Math.abs(this.y),isFinite(this.z)&&(this.z=Math.abs(this.z)),isFinite(this.w)&&(this.w=Math.abs(this.w)),this}transform(e){if(!e)return this;let t=this.vec.create();return this.vec.transformMat4(t,this.value,e.toFloat32Array()),w.fromPoint(t)}transformSelf(e){return this.vec.transformMat4(this.value,this.value,e.toFloat32Array()),this}toFloat32Array(){return this.value}toJSON(){let e={x:this.x,y:this.y};return isFinite(this.z)&&(e.z=this.z,isFinite(this.w)&&(e.w=this.w)),e}toString(){return`point(${this.value.join(", ")})`}clone(){return w.fromPoint(this)}static fromPoint(e){return Array.isArray(e)||ArrayBuffer.isTypedArray(e)?new w(e[0],e[1],e[2],e[3]):new w(e.x,e.y,e.z,e.w)}}class T{constructor(e,t,r,i){let s=e,n=t,o=e+r,a=t+i;Object.defineProperties(this,{left:{value:s,enumerable:!0},x:{value:e,enumerable:!0},bottom:{value:n,enumerable:!0},y:{value:t,enumerable:!0},right:{value:o,enumerable:!0},top:{value:a,enumerable:!0},width:{value:r,enumerable:!0},height:{value:i,enumerable:!0}})}union(e){if(e&&!(e instanceof T))throw new TypeError("rect must be instance of RectGL");return e?T.ofEdges(Math.min(this.left,e.left),Math.min(this.bottom,e.bottom),Math.max(this.right,e.right),Math.max(this.top,e.top)):this}intersect(e){if(e&&!(e instanceof T))throw new TypeError("rect must be instance of RectGL");if(!e)return null;let t=T.ofEdges(Math.max(this.left,e.left),Math.max(this.bottom,e.bottom),Math.min(this.right,e.right),Math.min(this.top,e.top));return t.width>0&&t.height>0?t:null}ceil(){return T.ofEdges(Math.floor(this.left),Math.floor(this.bottom),Math.ceil(this.right),Math.ceil(this.top))}floor(){return T.ofEdges(Math.ceil(this.left),Math.ceil(this.bottom),Math.floor(this.right),Math.floor(this.top))}transform(e){if(!e)return this;let t=w.fromPoint({x:this.left,y:this.bottom}).transform(e),r=w.fromPoint({x:this.right,y:this.bottom}).transform(e),i=w.fromPoint({x:this.left,y:this.top}).transform(e),s=w.fromPoint({x:this.right,y:this.top}).transform(e),n=Math.min(i.x,s.x,t.x,r.x),o=Math.min(i.y,s.y,t.y,r.y),a=Math.max(i.x,s.x,t.x,r.x),l=Math.max(i.y,s.y,t.y,r.y);return T.ofEdges(n,o,a,l)}toQuad(e){let t;if(e){let i=w.fromPoint({x:this.left,y:this.bottom}).transform(e),s=w.fromPoint({x:this.right,y:this.bottom}).transform(e),n=w.fromPoint({x:this.left,y:this.top}).transform(e),o=w.fromPoint({x:this.right,y:this.top}).transform(e);t=r.quat2.fromValues(i.x,i.y,s.x,s.y,n.x,n.y,o.x,o.y)}else t=r.quat2.fromValues(this.left,this.bottom,this.right,this.bottom,this.left,this.top,this.right,this.top);return t}toString(){return`gl-rect(${this.x}, ${this.y}, ${this.width}, ${this.height})`}static ofEdges(e,t,r,i){return new T(e,t,r-e,i-t)}static calculateBrushGLSegmentBounds(e,t=0,r){let i,s=.5*e.size,n=Math.abs(t*s);if(r){i=new w(e.x,e.y,e.x,e.z).transform(r)}else i=e;let o=i.x,a=i.y,l=e.scaleX*s,h=e.scaleY*s,d=e.offsetX,c=-e.offsetY,u=Math.cos(e.rotation),p=Math.sin(e.rotation),f=Number.MAX_SAFE_INTEGER,m=Number.MIN_SAFE_INTEGER,g=Number.MAX_SAFE_INTEGER,y=Number.MIN_SAFE_INTEGER;return[{x:-1,y:-1},{x:1,y:-1},{x:-1,y:1},{x:1,y:1}].forEach((e=>{e.x=e.x*l+d,e.y=e.y*h+c;let t=u*e.x+p*e.y+o,r=-p*e.x+u*e.y+a,i=t-n;f=Math.min(f,i),m=Math.max(m,i),i=t+n,f=Math.min(f,i),m=Math.max(m,i);let s=r-n;g=Math.min(g,s),y=Math.max(y,s),s=r+n,g=Math.min(g,s),y=Math.max(y,s)})),T.ofEdges(f,g,m,y)}}Object.defineProperty(T,"SQURE",{value:Object.freeze([Object.freeze({x:-1,y:-1}),Object.freeze({x:1,y:-1}),Object.freeze({x:-1,y:1}),Object.freeze({x:1,y:1})]),enumerable:!0});class v{constructor(e,t,r,i){let s,n,o=e,a=t,l=e+r,h=t+i;Object.defineProperties(this,{left:{value:o,enumerable:!0},top:{value:a,enumerable:!0},right:{value:l,enumerable:!0},bottom:{value:h,enumerable:!0},x:{value:e,enumerable:!0},y:{value:t,enumerable:!0},width:{value:r,enumerable:!0},height:{value:i,enumerable:!0},size:{get:()=>(s||(s={width:r,height:i}),s),enumerable:!0},center:{get:()=>(n||(n={x:(o+l)/2,y:(a+h)/2}),n),enumerable:!0}})}union(e){return e?v.ofEdges(Math.min(this.left,e.left),Math.min(this.top,e.top),Math.max(this.right,e.right),Math.max(this.bottom,e.bottom)):this}intersect(e){if(!e)return null;let t=v.ofEdges(Math.max(this.left,e.left),Math.max(this.top,e.top),Math.min(this.right,e.right),Math.min(this.bottom,e.bottom));return t.width>0&&t.height>0?t:null}intersects(e){return this.left<=e.right&&this.right>=e.left&&this.top<=e.bottom&&this.bottom>=e.top}ceil(e){let t=Math.floor(this.left),r=Math.floor(this.top),i=Math.ceil(this.right),s=Math.ceil(this.bottom);if(e){let e=i-t,n=s-r;e+=e%2,n+=n%2,i=t+e,s=r+n}return v.ofEdges(t,r,i,s)}floor(e){let t=Math.ceil(this.left),r=Math.ceil(this.top),i=Math.floor(this.right),s=Math.floor(this.bottom);if(e){let e=i-t,n=s-r;e-=e%2,n-=n%2,i=t+e,s=r+n}return v.ofEdges(t,r,i,s)}contains(e){return this.left<=e.x&&this.right>=e.x&&this.top<=e.y&&this.bottom>=e.y}includes(e){return this.left<=e.left&&this.right>=e.right&&this.top<=e.top&&this.bottom>=e.bottom}transform(e){if(!e)return this;let t=w.fromPoint({x:this.left,y:this.top}).transform(e),r=w.fromPoint({x:this.right,y:this.top}).transform(e),i=w.fromPoint({x:this.left,y:this.bottom}).transform(e),s=w.fromPoint({x:this.right,y:this.bottom}).transform(e),n=Math.min(t.x,r.x,i.x,s.x),o=Math.min(t.y,r.y,i.y,s.y),a=Math.max(t.x,r.x,i.x,s.x),l=Math.max(t.y,r.y,i.y,s.y);return v.ofEdges(n,o,a,l)}toPath(e,t=1){throw new Error("Rect.toPath is deprecated. Try oneof (ArrayPath, SharedPath, Spline).fromRect(rect, pointProps)")}toGLRect(){return new T(this.x,this.y,this.width,this.height)}toString(){return`rect(${this.x}, ${this.y}, ${this.width}, ${this.height})`}toJSON(){return{x:this.left,y:this.top,width:this.width,height:this.height}}static fromGLRect(e){if(!e)return null;if(!(e instanceof T))throw new TypeError("rect must be instance of RectGL");return new v(e.left,e.bottom,e.width,e.height)}static isRect(e){return e&&isFinite(e.left)&&isFinite(e.top)&&isFinite(e.width)&&isFinite(e.height)}static fromString(e){return e=e.substring(e.indexOf("(")+1,e.indexOf(")")).split(/,\s*/g),new v(parseFloat(e[0]),parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]))}static fromRect(e){return"string"==typeof e?v.fromString(e):new v(e.x,e.y,e.width,e.height)}static ofPolygon(e){if(e.shape&&(e=e.shape),0==e.length)return null;let t=Number.MAX_SAFE_INTEGER,r=Number.MAX_SAFE_INTEGER,i=Number.MIN_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER;for(let n=0;n<e.length;n++){let o=e.getPointX(n),a=e.getPointY(n);t=Math.min(t,o),r=Math.min(r,a),i=Math.max(i,o),s=Math.max(s,a)}return v.ofEdges(t,r,i,s)}static ofSpline(e,t=0){let r;for(let i=0;i<e.length;i++)r=T.calculateBrushGLSegmentBounds(e.getPoint(i),t).union(r);return v.fromGLRect(r)}static ofEdges(e,t,r,i){return new v(e,t,r-e,i-t)}static union(e,t){return e?t?e.union(t):e:t}static intersect(e,t){return e&&t?e.intersect(t):null}}const R={m11:0,m12:1,m13:2,m14:3,m21:4,m22:5,m23:6,m24:7,m31:8,m32:9,m33:10,m34:11,m41:12,m42:13,m43:14,m44:15},A=R.m11,O=R.m12,C=R.m21,D=R.m22,k=R.m41,N=R.m42;class M{constructor(e=r.mat4.create(),t=M.MultiplicationType.PRE){Object.defineProperty(this,"value",{value:e,enumerable:!0}),Object.defineProperty(this,"multiplicationType",{value:t,enumerable:!0});let i=function(e,t){let r=R[e];this.value[r]=t};Object.defineProperty(this,"a",{get:()=>this.value[A],set:i.bind(this,"m11"),enumerable:!0}),Object.defineProperty(this,"b",{get:()=>this.value[O],set:i.bind(this,"m12"),enumerable:!0}),Object.defineProperty(this,"c",{get:()=>this.value[C],set:i.bind(this,"m21"),enumerable:!0}),Object.defineProperty(this,"d",{get:()=>this.value[D],set:i.bind(this,"m22"),enumerable:!0}),Object.defineProperty(this,"e",{get:()=>this.value[k],set:i.bind(this,"m41"),enumerable:!0}),Object.defineProperty(this,"f",{get:()=>this.value[N],set:i.bind(this,"m42"),enumerable:!0}),Object.defineProperty(this,"tx",{get:()=>this.value[k],set:i.bind(this,"m41"),enumerable:!0}),Object.defineProperty(this,"ty",{get:()=>this.value[N],set:i.bind(this,"m42"),enumerable:!0}),Object.defineProperty(this,"m11",{get:()=>this.value[0],set:i.bind(this,"m11"),enumerable:!0}),Object.defineProperty(this,"m12",{get:()=>this.value[1],set:i.bind(this,"m12"),enumerable:!0}),Object.defineProperty(this,"m13",{get:()=>this.value[2],set:i.bind(this,"m13"),enumerable:!0}),Object.defineProperty(this,"m14",{get:()=>this.value[3],set:i.bind(this,"m14"),enumerable:!0}),Object.defineProperty(this,"m21",{get:()=>this.value[4],set:i.bind(this,"m21"),enumerable:!0}),Object.defineProperty(this,"m22",{get:()=>this.value[5],set:i.bind(this,"m22"),enumerable:!0}),Object.defineProperty(this,"m23",{get:()=>this.value[6],set:i.bind(this,"m23"),enumerable:!0}),Object.defineProperty(this,"m24",{get:()=>this.value[7],set:i.bind(this,"m24"),enumerable:!0}),Object.defineProperty(this,"m31",{get:()=>this.value[8],set:i.bind(this,"m31"),enumerable:!0}),Object.defineProperty(this,"m32",{get:()=>this.value[9],set:i.bind(this,"m32"),enumerable:!0}),Object.defineProperty(this,"m33",{get:()=>this.value[10],set:i.bind(this,"m33"),enumerable:!0}),Object.defineProperty(this,"m34",{get:()=>this.value[11],set:i.bind(this,"m34"),enumerable:!0}),Object.defineProperty(this,"m41",{get:()=>this.value[12],set:i.bind(this,"m41"),enumerable:!0}),Object.defineProperty(this,"m42",{get:()=>this.value[13],set:i.bind(this,"m42"),enumerable:!0}),Object.defineProperty(this,"m43",{get:()=>this.value[14],set:i.bind(this,"m43"),enumerable:!0}),Object.defineProperty(this,"m44",{get:()=>this.value[15],set:i.bind(this,"m44"),enumerable:!0}),Object.defineProperty(this,"isIdentity",{get:()=>1==this.a&&0==this.b&&0==this.c&&1==this.d&&0==this.tx&&0==this.ty,enumerable:!0}),Object.defineProperty(this,"is2D",{get:()=>!(0!=this.m31||0!=this.m32||0!=this.m13||0!=this.m23||1!=this.m33||0!=this.m43||0!=this.m14||0!=this.m24||0!=this.m34||1!=this.m44),enumerable:!0}),Object.defineProperty(this,"translateX",{get:()=>this.tx}),Object.defineProperty(this,"translateY",{get:()=>this.ty}),Object.defineProperty(this,"skewX",{get:()=>Math.tan(this.c)}),Object.defineProperty(this,"skewY",{get:()=>Math.tan(this.b)}),Object.defineProperty(this,"scaleX",{get:()=>Math.sqrt(this.a*this.a+this.c*this.c)}),Object.defineProperty(this,"scaleY",{get:()=>Math.sqrt(this.d*this.d+this.b*this.b)}),Object.defineProperty(this,"rotation",{get:()=>Math.atan2(this.b,this.a)})}clone(){return new M(this.value.clone(),this.multiplicationType)}translate(e){return this.multiply(M.fromTranslate(e))}translateSelf(e){this.multiplySelf(M.fromTranslate(e))}rotate(e,t){return this.multiply(M.fromRotate(e,t))}rotateSelf(e,t){this.multiplySelf(M.fromRotate(e,t))}scale(e,t){return this.multiply(M.fromScale(e,t))}scaleSelf(e,t){this.multiplySelf(M.fromScale(e,t))}multiply(e){return this.multiplicationType==M.MultiplicationType.PRE?this.preMultiply(e):this.postMultiply(e)}preMultiply(e){let t=r.mat4.create();return r.mat4.multiply(t,e.toFloat32Array(),this.value),new M(t,this.multiplicationType)}postMultiply(e){let t=r.mat4.create();return r.mat4.multiply(t,this.value,e.toFloat32Array()),new M(t,this.multiplicationType)}multiplySelf(e){this.multiplicationType==M.MultiplicationType.PRE?this.preMultiplySelf(e):this.postMultiplySelf(e)}preMultiplySelf(e){r.mat4.multiply(this.value,e.toFloat32Array(),this.value)}postMultiplySelf(e){r.mat4.multiply(this.value,this.value,e.toFloat32Array())}invert(){let e=r.mat4.create();return r.mat4.invert(e,this.value),new M(e,this.multiplicationType)}invertSelf(){r.mat4.invert(this.value,this.value)}decompose(){return{translate:{x:this.tx,y:this.ty},rotate:{angle:Math.atan2(this.b,this.a)},skew:{angleX:Math.tan(this.c),angleY:Math.tan(this.b)},scale:{x:Math.sqrt(this.a*this.a+this.c*this.c),y:Math.sqrt(this.d*this.d+this.b*this.b)},matrix:this.toJSON()}}transformPoint(e){return w.fromPoint(e).transform(this)}toFloat32Array(){return this.value}toJSON(){return{a:this.a,b:this.b,c:this.c,d:this.d,tx:this.tx,ty:this.ty}}toString(e){if(e){let e=e=>((e<0?"":" ")+e.toPrecision(6)).substring(0,8);return" Matrix 4x4\n"+"-".repeat(39)+`\n${e(this.m11)}, ${e(this.m21)}, ${e(this.m31)}, ${e(this.m41)}`+`\n${e(this.m12)}, ${e(this.m22)}, ${e(this.m32)}, ${e(this.m42)}`+`\n${e(this.m13)}, ${e(this.m23)}, ${e(this.m33)}, ${e(this.m43)}`+`\n${e(this.m14)}, ${e(this.m24)}, ${e(this.m34)}, ${e(this.m44)}`}return this.is2D?`matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`:`matrix3d(${this.m11}, ${this.m12}, ${this.m13}, ${this.m14}, ${this.m21}, ${this.m22}, ${this.m23}, ${this.m24}, ${this.m31}, ${this.m32}, ${this.m33}, ${this.m34}, ${this.m41}, ${this.m42}, ${this.m43}, ${this.m44})`}static fromString(e,t){let i=r.mat4.create();if("none"!=e){let t=e.substring(0,e.indexOf("("));e=e.substring(e.indexOf("(")+1,e.indexOf(")")).split(/,\s*/g),"matrix3d"==t?(i[0]=parseFloat(e[0]),i[1]=parseFloat(e[1]),i[2]=parseFloat(e[2]),i[3]=parseFloat(e[3]),i[4]=parseFloat(e[4]),i[5]=parseFloat(e[5]),i[6]=parseFloat(e[6]),i[7]=parseFloat(e[7]),i[8]=parseFloat(e[8]),i[9]=parseFloat(e[9]),i[10]=parseFloat(e[10]),i[11]=parseFloat(e[11]),i[12]=parseFloat(e[12]),i[13]=parseFloat(e[13]),i[14]=parseFloat(e[14]),i[15]=parseFloat(e[15])):(i[A]=parseFloat(e[0]),i[O]=parseFloat(e[1]),i[C]=parseFloat(e[2]),i[D]=parseFloat(e[3]),i[k]=parseFloat(e[4]),i[N]=parseFloat(e[5]))}return new M(i,t)}static fromMatrix(e,t){if(!e)throw new Error("data not found, Matrix instance creation failed");if("function"==typeof e)throw new Error("data type function is not allowed");if(e instanceof M)return e;if(Array.isArray(e)&&(e=new Float32Array(e)),e instanceof Float32Array)return new M(e,t);if("string"==typeof e)return M.fromString(e,t);let i=r.mat4.create(),s=Object.assign({},e);return isFinite(e.a)&&(s.m11=e.a),isFinite(e.b)&&(s.m12=e.b),isFinite(e.c)&&(s.m21=e.c),isFinite(e.d)&&(s.m22=e.d),isFinite(e.tx)?s.m41=e.tx:isFinite(e.e)?s.m41=e.e:isFinite(e.dx)&&(s.m41=e.dx),isFinite(e.ty)?s.m42=e.ty:isFinite(e.f)?s.m42=e.f:isFinite(e.dy)&&(s.m42=e.dy),isFinite(s.m11)&&(i[0]=s.m11),isFinite(s.m12)&&(i[1]=s.m12),isFinite(s.m13)&&(i[2]=s.m13),isFinite(s.m14)&&(i[3]=s.m14),isFinite(s.m21)&&(i[4]=s.m21),isFinite(s.m22)&&(i[5]=s.m22),isFinite(s.m23)&&(i[6]=s.m23),isFinite(s.m24)&&(i[7]=s.m24),isFinite(s.m31)&&(i[8]=s.m31),isFinite(s.m32)&&(i[9]=s.m32),isFinite(s.m33)&&(i[10]=s.m33),isFinite(s.m34)&&(i[11]=s.m34),isFinite(s.m41)&&(i[12]=s.m41),isFinite(s.m42)&&(i[13]=s.m42),isFinite(s.m43)&&(i[14]=s.m43),isFinite(s.m44)&&(i[15]=s.m44),new M(i,t||e.multiplicationType)}static fromTranslate(e){let t=isFinite(e)?{tx:e,ty:e}:{tx:e.x,ty:e.y};return M.fromMatrix(t)}static fromRotate(e,t){let r=Math.sin(e),i=Math.cos(e),s={a:i,b:r,c:-r,d:i};return t&&(s.tx=t.x-t.x*i+t.y*r,s.ty=t.y-t.x*r-t.y*i),M.fromMatrix(s)}static fromScale(e,t){isFinite(e)&&(e={x:e,y:e});let r={a:e.x,d:e.y};return t&&(r.tx=t.x-t.x*e.x,r.ty=t.y-t.y*e.y),M.fromMatrix(r)}static fromPoints(e,t){if(!Array.isArray(e)||!Array.isArray(t))throw new Error("Expected input type Array requirement not satisfied");if(3!=e.length||3!=t.length)throw new Error("Expected input size 3 requirement not satisfied");let r=M.fromMatrix({m11:e[0].x,m21:e[1].x,m31:e[2].x,m12:e[0].y,m22:e[1].y,m32:e[2].y,m13:1,m23:1,m33:1}),i=M.fromMatrix({m11:t[0].x,m21:t[1].x,m31:t[2].x,m12:t[0].y,m22:t[1].y,m32:t[2].y,m13:1,m23:1,m33:1}),s=r.invert().preMultiply(i);return M.fromMatrix({a:s.m11,b:s.m12,c:s.m21,d:s.m22,tx:s.m31,ty:s.m32})}static multiply(e,t){let i=r.mat4.create();return r.mat4.multiply(i,e.value,t.value),new M(i)}}M.MultiplicationType=Object.freeze({PRE:"PRE",POST:"POST"});let L={longToByteArray(e){let t=[0,0,0,0,0,0,0,0];for(let r=0;r<t.length;r++){let i=255&e;t[r]=i,e=(e-i)/256}return t},byteArrayToLong(e){let t=0;for(let r=e.length-1;r>=0;r--)t=256*t+e[r];return t},crc32:function(){let e=new Uint32Array(256);for(let t=256;t--;){let r=t;for(let e=8;e--;)r=1&r?3988292384^r>>>1:r>>>1;e[t]=r}return function(t){let r=-1;for(let i=0,s=t.length;i<s;i++)r=r>>>8^e[255&r^t[i]];return(-1^r)>>>0}}(),encodeBitMask(e=[]){if(0==e.length)return 0;let t="",r=Math.max(...e);for(let i=1;i<=r;i++)t+=e.includes(i)?"1":"0";return parseInt(t.split("").reverse().join(""),2)},decodeBitMask(e){let t=[],r=e.toString(2).split("").reverse();for(let e=0;e<r.length;e++)1==r[e]&&t.push(e+1);return t},mapTo:(e,t,r)=>r.min+(L.clamp(e,t)-t.min)/(t.max-t.min)*(r.max-r.min),clamp:(e,t)=>Math.min(Math.max(e,t.min),t.max),debounce(e,t){let r=null;return function(){let i=this,s=arguments;clearTimeout(r),r=setTimeout((function(){e.apply(i,s)}),t)}},comparator(){let e=Array.prototype.slice.call(arguments),t=function(e,t,r){return t.replace("[",".").replace("]","").split(".").forEach((t=>e=e[t])),r?e.toLowerCase():e};return function(r,i){return e.map((e=>function(e,t,r){let i="asc"===r?1:-1;return e>t?1*i:e<t?-1*i:0}(t(r,e.sortBy,e.ignoreCase),t(i,e.sortBy,e.ignoreCase),e.sortOrder))).reduceRight((function(e,t){return t||e}))}},isValidURL(e){if("string"!=typeof e)return!1;try{return new URL(e),!0}catch(e){return!1}},getPropName(e,t){let r=e.split("_"),i=r.first.toLowerCase();t&&(i=i.substring(0,1).toUpperCase()+i.substring(1));for(let e=1;e<r.length;e++)i+=r[e].substring(0,1),i+=r[e].substring(1).toLowerCase();return i},getEnumValueName(e){let t="";for(let r=0;r<e.length;r++)r>0&&e[r]!=e[r].toLowerCase()&&(t+="_"),t+=e[r];return t.toUpperCase()}};class _{constructor(e){this.header=[],this.table=[],e.forEach((e=>{"string"==typeof e&&(e={name:e,title:e}),e.size=e.title.length,this.header.push(e)})),Object.defineProperty(this,"length",{get:()=>this.table.length,enumerable:!0})}insert(e){this.table.push(e),this.header.forEach((t=>{let r=e[t.name];null!=r&&(t.size=Math.max(t.size,r.toString().length))}))}build(){let e=[],t=this.header.length+1,r=[];return this.header.forEach((e=>{t+=e.size+2;let i=e.size-e.title.length,s=Math.floor(i/2),n=Math.ceil(i/2);r.push(this.getRepetedValue(s)+e.title+this.getRepetedValue(n))})),this.table.forEach((t=>{let r=[];this.header.forEach((e=>{let i=null==t[e.name]?"":t[e.name],s=e.size-i.toString().length;r.push(i+this.getRepetedValue(s))})),e.push(r)})),{delimiterLength:t,headerRow:r,content:e}}getFormattedRow(e){let t="| ";return e.forEach((e=>{t+=e,t+=" | "})),t.trim()}getRepetedValue(e,t=" "){return new Array(e+1).join(t)}clear(){this.table.clear()}toString(){let e="",{delimiterLength:t,headerRow:r,content:i}=this.build();return e+=this.getRepetedValue(t,"="),e+="\n",e+=this.getFormattedRow(r),e+="\n",e+=this.getRepetedValue(t,"="),e+="\n",i.forEach((t=>{e+=this.getFormattedRow(t),e+="\n"})),e}}if("object"==typeof window&&"undefined"==typeof TouchEvent){class e extends Event{}window.TouchEvent=e}let F={pointers:{mouse:["down","move","up"],touch:["start","move","end"]},inactive:[],open(e){if(!(e instanceof y))throw new Error("Argument doesn't implement InkController interface");this.inkController=e,this.canvas=e.canvas.surface,this.mounted||(this.mounted=!0,this.begin=this.begin.bind(this),this.move=this.move.bind(this),this.end=this.end.bind(this),this.abort=this.abort.bind(this)),addEventListener("touchcancel",this.abort,{passive:!0}),this.attachResize(),this.start()},reset(e){for(let t in this.pointers){let r=t==F.PointerType.TOUCH?{passive:!0}:void 0,i=t+this.pointers[t][0];this.canvas.removeEventListener(i,this.begin),e.canvas.surface.addEventListener(i,this.begin,r)}this.dettachResize(),this.inkController=e,this.canvas=e.canvas.surface,this.attachResize()},close(){this.stop(),this.dettachResize(),removeEventListener("touchcancel",this.abort),delete this.canvas,delete this.inkController},start(e){let t=e?{[e]:this.pointers[e]}:this.pointers;for(e in e&&this.inactive.remove(e),this.inactive.forEach((e=>delete t[e])),t){let r=e==F.PointerType.TOUCH?{passive:!0}:void 0;for(let i=0;i<t[e].length;i++){let s=e+t[e][i];0==i?this.canvas.addEventListener(s,this.begin,r):addEventListener(s,2==i?this.end:this.move,r)}}},stop(e){let t=e?{[e]:this.pointers[e]}:this.pointers;for(e in e&&!this.inactive.includes(e)&&this.inactive.push(e),this.inactive.forEach((e=>delete t[e])),e&&e!=F.PointerType.MOUSE||clearTimeout(this.timeoutID),t)for(let r=0;r<t[e].length;r++){let i=e+t[e][r];0==r?this.canvas.removeEventListener(i,this.begin):removeEventListener(i,2==r?this.end:this.move)}},isInputAllowed(e){let t=this.provider;if(e.type.endsWith("down")||e.type.endsWith("start")){if(t||(t=this.getInputProvider(e)),this.inactive.includes(t))return!1;if(t==F.PointerType.MOUSE&&0!=e.button)return!1;for(let t in this.suppressKeys)if(e[t])return!1}return t==this.getInputProvider(e)},isInputExpected(e){let t=!1,r=e.changedTouches?Array.from(e.changedTouches).map((e=>e.identifier)):[],i=this.inkController.getInkBuilder(r);return i&&(t=e.type.endsWith("down")||e.type.endsWith("start")?!i.phase:i.phase&&i.phase!=x.Phase.END),t},getSensorPoint(e){let t,r=e.changedTouches?Array.from(e.changedTouches).map((e=>e.identifier)):[],i=this.inkController.getInkBuilder(r);return i&&(t=this.createSensorPoint(e,i.pointerID)),t},createSensorPoint(e,t){let r=this.getOffset(e),i={x:r.x,y:r.y,z:void 0,timestamp:Math.floor(e.timeStamp),pressure:void 0,radiusX:void 0,radiusY:void 0,rotation:void 0},s={id:void 0,type:void 0,button:void 0,buttons:void 0};if(Object.defineProperty(i,"phase",{value:x.Phase[e.type.replace(/pointer|mouse|touch/g,"").replace(/down|start/,"BEGIN").replace(/move/,"UPDATE").replace(/up|end/,"END")],enumerable:!0}),Object.defineProperty(i,"pointer",{value:s,enumerable:!0}),Object.defineProperty(i.pointer,"provider",{get:function(){return S.Type[this.type.toUpperCase()]},enumerable:!0}),e instanceof MouseEvent)s.type=F.PointerType.MOUSE,s.button=e.button,s.buttons=e.buttons;else{if(!(e instanceof TouchEvent))throw new Error(`Unexpected event detected: ${e.constructor.name}. Expected event should be instance of MouseEvent or TouchEvent.`);if(isNaN(t))throw new Error("pointerID is required for touch event");if(!(e=Array.from(e.changedTouches).filter((e=>e.identifier==t)).first))return null;isNaN(i.x)&&(i.x=e.offsetX||e.clientX),isNaN(i.y)&&(i.y=e.offsetY||e.clientY),s.id=e.identifier,s.type=F.PointerType.TOUCH,i.pressure=e.force,i.radiusX=e.radiusX,i.radiusY=e.radiusY,i.rotation=Math.toRadians(e.rotationAngle)}return i},getOffset(e){if(e.changedTouches){let t=Array.from(e.changedTouches).map((e=>e.identifier)),r=this.inkController.getInkBuilder(t);e=r.pointerID!=e.changedTouches.item(0).identifier?Array.from(e.changedTouches).filter((e=>e.identifier==r.pointerID)).first:e.changedTouches.item(0)}let t=this.canvas.offsetParent;if(!t)return{x:0,y:0};"flex"==t.getStyle("display")&&(t=this.canvas);let r=this.inkController.transform,i=this.canvas.getStyle("transform");"none"==i?i=t.getStyle("transform"):t=this.canvas,i="none"==i?null:M.fromMatrix(i);let s=w.fromPoint({x:e.clientX,y:e.clientY}),n=t.getBoundingClientRect();if(i){let e=i.invert();s=s.transform(e),n=v.fromRect(n).transform(e)}let o={x:s.x-n.x,y:s.y-n.y};return r&&(o=w.fromPoint(o).transform(r.invert())),o},getInputProvider:e=>e.type.replace(/down|start|move|up|end/g,""),begin(e){if(this.logSampleInput(e),e instanceof MouseEvent&&0!=e.button)return;if(!this.isInputAllowed(e))return;if(e instanceof TouchEvent){let t=Array.from(e.changedTouches).map((e=>e.identifier));this.inkController.registerInputProvider(t)}if(!this.isInputExpected(e))return;this.provider||(this.provider=this.getInputProvider(e));let t=this.getSensorPoint(e);t&&this.inkController.begin(t,e)},move(e){if(!this.isInputAllowed(e)||!this.isInputExpected(e))return;this.logSampleInput(e);let t=this.getSensorPoint(e);t&&this.inkController.move(t,void 0,e)},end(e){if(!this.isInputAllowed(e)||!this.isInputExpected(e))return;this.logSampleInput(e);let t=this.getSensorPoint(e);t&&(this.inkController.end(t,e),e instanceof MouseEvent||this.inactive.includes(F.PointerType.MOUSE)||(this.stop(F.PointerType.MOUSE),this.timeoutID=setTimeout((()=>this.start(F.PointerType.MOUSE)),500))),e.touches&&0!=e.touches.length||delete this.provider},abort(e){if(delete this.provider,this.inkController.abort)if(e instanceof TouchEvent){let t=Array.from(e.changedTouches).map((e=>e.identifier));this.inkController.abort(t)}else this.inkController.abort()},logSampleInput(e){if(!this.debug)return;const t=e.type.endsWith("move"),r="mouseup"==e.type||"touchend"==e.type;t&&!this.debug.move||r&&!this.debug.end||(r&&this.table.length>0&&(console.log(this.table.toString()),this.table.clear()),this.table||(this.table=new _(["type","id","pointerType","x","y","pressure","radius","rotation","timestamp"])),this.table.insert({type:e.type,id:e.changedTouches?e.changedTouches[0].identifier:void 0,pointerType:this.getInputProvider(e),x:e.changedTouches?e.changedTouches[0].clientX.toFixed(2):e.clientX,y:e.changedTouches?e.changedTouches[0].clientY.toFixed(2):e.clientY,pressure:e.changedTouches?e.changedTouches[0].force.toFixed(2):void 0,radius:e.changedTouches?e.changedTouches[0].radiusX.toFixed(2)+" / "+e.changedTouches[0].radiusY.toFixed(2):void 0,rotation:e.changedTouches?e.changedTouches[0].rotationAngle:e.twist,timestamp:e.timeStamp.toFixed(8)}),t||(console.log(this.table.toString()),this.table.clear()))},PointerType:{MOUSE:"mouse",TOUCH:"touch"}},B={inactive:[],suppressKeys:{ctrlKey:!0,altKey:!0,shiftKey:!0,metaKey:!0},open(e){if(!(e instanceof y))throw new Error("Argument doesn't implement InkController interface");this.inkController=e,this.canvas=e.canvas.surface,this.mounted||(this.mounted=!0,this.begin=this.begin.bind(this),this.move=this.move.bind(this),this.end=this.end.bind(this),this.abort=this.abort.bind(this)),addEventListener("pointercancel",this.abort),this.attachResize(),this.start()},reset(e){this.canvas.removeEventListener("pointerdown",this.begin),e.canvas.surface.addEventListener("pointerdown",this.begin),this.dettachResize(),this.inkController=e,this.canvas=e.canvas.surface,this.attachResize()},close(){this.stop(),this.dettachResize(),removeEventListener("pointercancel",this.abort),delete this.canvas,delete this.inkController},start(e){e?this.inactive.remove(e):(this.canvas.addEventListener("pointerdown",this.begin),addEventListener("pointermove",this.move),addEventListener("pointerup",this.end))},stop(e){e?this.inactive.includes(e)||this.inactive.push(e):(this.canvas.removeEventListener("pointerdown",this.begin),removeEventListener("pointermove",this.move),removeEventListener("pointerup",this.end))},attachResize(){if(this.inkController.resize==y.prototype.resize)return;let e=B.ResizeReason.WINDOW,t=devicePixelRatio,r=screen.width;let i;matchMedia("screen and (orientation: portrait)").addListener((t=>{e=B.ResizeReason.ORIENTATION,r=screen.width})),function r(){i&&(i.removeListener(r),e=t<devicePixelRatio?B.ResizeReason.ZOOM_IN:B.ResizeReason.ZOOM_OUT,t=devicePixelRatio),i=matchMedia(`(resolution: ${devicePixelRatio}dppx)`),i.addListener(r)}(),this.resize=L.debounce((()=>{e==B.ResizeReason.WINDOW&&r!=screen.width&&(e=r<screen.width?B.ResizeReason.SCREEN_SIZE_INCREASED:B.ResizeReason.SCREEN_SIZE_DECREASED,r=screen.width),this.inkController.resize(e),e=B.ResizeReason.WINDOW}),200),addEventListener("resize",this.resize)},dettachResize(){this.inkController.resize!=y.prototype.resize&&removeEventListener("resize",this.resize)},isInputAllowed(e){if("pointerdown"!=e.type)return!0;let t=this.provider;if(t||(t=this.getInputProvider(e)),this.inactive.includes(t))return!1;if(t==B.PointerType.MOUSE){if(0!=e.button)return!1}else if(t==B.PointerType.PEN&&0==e.pressure)return!1;for(let t in this.suppressKeys)if(e[t])return!1;return!0},isInputExpected(e){let t=!1,r=this.inkController.getInkBuilder(e.pointerId);return r&&(t="pointerdown"==e.type?!r.phase:r.phase&&r.phase!=x.Phase.END),t},getSensorPoint(e){let t,r=this.inkController.getInkBuilder(e.pointerId);if(r){if(e.pointerId!=r.pointerID)throw new Error(`Create sensor point failed, expected pointer with id: ${r.pointerID}, found: ${e.pointerId}`);if("pointerdown"==e.type){let t=this.getInputProvider(e);e.pointerType!=t?r.pointerType=t:delete r.pointerType}t=this.createSensorPoint(e,r.pointerType)}return t},createSensorPoint(e,t,r){if(!(e instanceof PointerEvent))throw new Error(`Unexpected event detected: ${e.constructor.name}. Expected event should be instance of PointerEvent.`);let i,s=this.getOffset(e),n={x:s.x,y:s.y,z:void 0,timestamp:Math.floor(e.timeStamp),pressure:void 0,radiusX:void 0,radiusY:void 0,tiltX:void 0,tiltY:void 0,rotation:void 0};if(r?(Object.defineProperty(n,"phase",{value:r.phase,enumerable:!0}),i=r.pointer):(Object.defineProperty(n,"phase",{value:x.Phase[e.type.replace(/pointer|mouse|touch/g,"").replace(/down|start/,"BEGIN").replace(/move/,"UPDATE").replace(/up|end/,"END")],enumerable:!0}),i={id:e.pointerId,type:t||e.pointerType,button:void 0,buttons:void 0},Object.defineProperty(i,"provider",{get:function(){return S.Type[this.type.toUpperCase()]},enumerable:!0}),"pen"!=i.type&&"mouse"!=i.type||(i.button=e.button,i.buttons=e.buttons)),Object.defineProperty(n,"pointer",{value:i,enumerable:!0}),"pen"!=i.type&&"touch"!=i.type||(n.pressure=e.pressure,n.rotation=Math.toRadians(e.twist)),"pen"==i.type?(n.tiltX=e.tiltX,n.tiltY=e.tiltY):"touch"==i.type&&(n.radiusX=e.width/2,n.radiusY=e.height/2),!r){if(e.getPredictedEvents){let r=e.getPredictedEvents();if(r.length>0){let e;Object.defineProperty(n,"predicted",{get:()=>(e||(e=r.map((e=>this.createSensorPoint(e,t,n)))),e),enumerable:!0})}}if("pen"==i.type&&e.getCoalescedEvents){let r=e.getCoalescedEvents();if(r.length>1){let e;Object.defineProperty(n,"coalesced",{get:()=>(e||(e=r.map((e=>this.createSensorPoint(e,t,n)))),e),enumerable:!0})}}}return n},getOffset(e){let t=this.canvas.offsetParent;if(!t)return{x:0,y:0};"flex"==t.getStyle("display")&&(t=this.canvas);let r=this.inkController.transform,i=this.canvas.getStyle("transform");"none"==i?i=t.getStyle("transform"):t=this.canvas,i="none"==i?null:M.fromMatrix(i);let s=w.fromPoint({x:e.clientX,y:e.clientY}),n=t.getBoundingClientRect();if(i){let e=i.invert();s=s.transform(e),n=v.fromRect(n).transform(e)}let o={x:s.x-n.x,y:s.y-n.y};return r&&(o=w.fromPoint(o).transform(r.invert())),o},getInputProvider:e=>e.pointerType==B.PointerType.MOUSE&&e.pressure>0&&.5!==e.pressure?B.PointerType.PEN:e.pointerType,begin(e){if(this.logSampleInput(e),!this.isInputAllowed(e))return;if(this.inkController.registerInputProvider(e.pointerId,e.isPrimary),!this.isInputExpected(e))return;this.provider||(this.provider=this.getInputProvider(e));let t=this.getSensorPoint(e);t&&this.inkController.begin(t,e)},move(e){if(!this.isInputAllowed(e)||!this.isInputExpected(e))return;this.logSampleInput(e);let t=this.getSensorPoint(e);if(t){let r;if(this.inkController.getInkBuilder(e.pointerId).prediction&&e.getPredictedEvents){let i=e.getPredictedEvents();i.length>0&&(r=this.createSensorPoint(i.last,t.pointer.type,t))}this.inkController.move(t,r,e)}},end(e){if(!this.isInputAllowed(e)||!this.isInputExpected(e))return;this.logSampleInput(e);let t=this.getSensorPoint(e);t&&this.inkController.end(t,e),delete this.provider},abort(e){delete this.provider,this.inkController.abort&&this.inkController.abort(e.pointerId)},logSampleInput(e){this.debug&&(this.debug.move||this.debug.end)&&("pointermove"!=e.type||this.debug.move)&&("pointerup"!=e.type||this.debug.end)&&(e.pointerType!=this.getInputProvider(e)&&(e.pen=!0),"pointerup"==e.type&&this.table.length>0&&(console.log(this.table.toString()),this.table.clear()),this.table||(this.table=new _(["type","id","pointerType","x","y","pressure","radius","tilt","rotation","timestamp"])),this.table.insert({type:e.type,id:e.pointerId,pointerType:e.pen?`${e.pointerType} / pen`:e.pointerType,x:e.clientX.toFixed(2),y:e.clientY.toFixed(2),pressure:e.pressure.toFixed(2),radius:(e.width/2).toFixed(2)+" / "+(e.height/2).toFixed(2),rotation:e.twist,tilt:isFinite(e.tiltX)?e.tiltX+" / "+e.tiltY:"",timestamp:e.timeStamp.toFixed(8)}),"pointermove"!=e.type&&(console.log(this.table.toString()),this.table.clear()))},PointerType:{PEN:"pen",MOUSE:"mouse",TOUCH:"touch"}};Object.defineEnum(B,"ResizeReason",["WINDOW","ZOOM_IN","ZOOM_OUT","SCREEN_SIZE_INCREASED","SCREEN_SIZE_DECREASED","ORIENTATION"]),"object"==typeof window&&"undefined"==typeof PointerEvent&&(F.suppressKeys=B.suppressKeys,F.ResizeReason=B.ResizeReason,F.attachResize=B.attachResize,F.dettachResize=B.dettachResize,B=F);var U=B;class j extends w{static defaults={size:1,rotation:0,scaleX:1,scaleY:1,scaleZ:1,offsetX:0,offsetY:0,offsetZ:0};constructor(e,t,r,i={}){super(e,t,r),this.red=i.red,this.green=i.green,this.blue=i.blue,this.alpha=i.alpha,this.size=i.size||j.defaults.size,this.rotation=i.rotation||j.defaults.rotation,this.scaleX=i.scaleX||j.defaults.scaleX,this.scaleY=i.scaleY||j.defaults.scaleY,this.scaleZ=isFinite(r)?i.scaleZ||j.defaults.scaleZ:void 0,this.offsetX=i.offsetX||j.defaults.offsetX,this.offsetY=i.offsetY||j.defaults.offsetY,this.offsetZ=isFinite(r)?i.offsetZ||j.defaults.offsetZ:void 0,this.dX,this.dY}static createInstance(e,t,r,i=0){let s=new j(0,0,e.includes(j.Property.Z)?0:void 0);return r&&s.fill(i,r,e,t),s}fill(e,t,r,i={}){let s={},n=e*r.length;r.forEach(((e,r)=>j.setProperty(s,e,t[n+r]))),this.x=s.x,this.y=s.y,this.z=s.z,this.red=isFinite(s.red)?s.red:i.red,this.green=isFinite(s.green)?s.green:i.green,this.blue=isFinite(s.blue)?s.blue:i.blue,this.alpha=isFinite(s.alpha)?s.alpha:i.alpha,this.size=s.size||i.size||j.defaults.size,this.rotation=s.rotation||i.rotation||j.defaults.rotation,this.scaleX=s.scaleX||i.scaleX||j.defaults.scaleX,this.scaleY=s.scaleY||i.scaleY||j.defaults.scaleY,this.scaleZ=isFinite(s.z)?s.scaleZ||i.scaleZ||j.defaults.scaleZ:void 0,this.offsetX=s.offsetX||i.offsetX||j.defaults.offsetX,this.offsetY=s.offsetY||i.offsetY||j.defaults.offsetY,this.offsetZ=isFinite(s.z)?s.offsetZ||i.offsetZ||j.defaults.offsetZ:void 0,this.dX=s.dX,this.dY=s.dY}getProperty(e){switch(e){case j.Property.X:return this.x;case j.Property.Y:return this.y;case j.Property.Z:return this.z;case j.Property.RED:return this.red;case j.Property.GREEN:return this.green;case j.Property.BLUE:return this.blue;case j.Property.ALPHA:return this.alpha;case j.Property.SIZE:return this.size;case j.Property.ROTATION:return this.rotation;case j.Property.SCALE_X:return this.scaleX;case j.Property.SCALE_Y:return this.scaleY;case j.Property.SCALE_Z:return this.scaleZ;case j.Property.OFFSET_X:return this.offsetX;case j.Property.OFFSET_Y:return this.offsetY;case j.Property.OFFSET_Z:return this.offsetZ;case j.Property.D_X:return this.dX;case j.Property.D_Y:return this.dY;default:throw console.warn(e),new Error("Invalid property found")}}setProperty(e,t){j.setProperty(this,e,t)}static setProperty(e,t,r){switch(t){case j.Property.X:e.x=r;break;case j.Property.Y:e.y=r;break;case j.Property.Z:e.z=r;break;case j.Property.RED:e.red=r;break;case j.Property.GREEN:e.green=r;break;case j.Property.BLUE:e.blue=r;break;case j.Property.ALPHA:e.alpha=r;break;case j.Property.SIZE:e.size=r;break;case j.Property.ROTATION:e.rotation=r;break;case j.Property.SCALE_X:e.scaleX=r;break;case j.Property.SCALE_Y:e.scaleY=r;break;case j.Property.SCALE_Z:e.scaleZ=r;break;case j.Property.OFFSET_X:e.offsetX=r;break;case j.Property.OFFSET_Y:e.offsetY=r;break;case j.Property.OFFSET_Z:e.offsetZ=r;break;case j.Property.D_X:e.dX=r;break;case j.Property.D_Y:e.dY=r;break;default:throw console.warn(t),new Error("Invalid property found")}}transform(e){if(!(e instanceof M))throw new Error(`matrix is instance of ${e.constructor.name} - it should be instance of Matrix. Use Matrix.fromMatrix method to convert.`);let t=e.scaleX,r=e.rotation;this.transformSelf(e),this.size*=t,this.rotation+=r,this.scaleX*=t,this.scaleY*=t,isFinite(this.z)&&(this.scaleZ*=t),this.offsetX*=t,this.offsetY*=t,isFinite(this.z)&&(this.offsetZ*=t)}toArray(e){return e.map((e=>{let t=this.getProperty(e);if(null==t||isNaN(t))throw new Error(`Property ${e.name} has invalid value ${t}`);return t}))}toJSON(){let e={};return j.Property.values.forEach((t=>{let r=this.getProperty(t);null!=r&&isFinite(r)&&(e[t.name]=this.getProperty(t))})),e}}Object.defineEnum(j,"Property",["X","Y","Z","RED","GREEN","BLUE","ALPHA","SIZE","ROTATION","SCALE_X","SCALE_Y","SCALE_Z","OFFSET_X","OFFSET_Y","OFFSET_Z","D_X","D_Y"]);Object.defineProperty(globalThis,"DIGITAL_INK_ENV",{value:"AUTO",enumerable:!0,configurable:!0});let G,$={version:"1.4.2"};Object.defineEnum($,"Type",["WEB","WORKER","NODE","SHELL"]),Object.defineEnum($,"Type2D",["SCREEN","OFFSCREEN"]),Object.defineEnum($,"TypeGL",["WEB","STACK"]),function(e){let t,r="BROWSER"!=DIGITAL_INK_ENV&&"object"==typeof process&&"function"==typeof require;t="object"==typeof window?"WEB":"function"==typeof importScripts?"WORKER":r?"NODE":"SHELL";let i="undefined"==typeof OffscreenCanvas?"OFFSCREEN":"SCREEN",s="undefined"==typeof WebGLRenderingContext?"STACK":"WEB";Object.defineProperty($,"commonJS",{value:r,enumerable:!0}),Object.defineProperty($,"type",{value:$.Type[t],enumerable:!0}),Object.defineProperty($,"type2D",{value:$.Type2D[i],enumerable:!0}),Object.defineProperty($,"typeGL",{value:$.TypeGL[s],enumerable:!0})}(),$.commonJS&&(G=require("systeminformation"));var Y=G;class X extends I{constructor(){super(),this.props={}}getMD5Message(){if(!Object.isFrozen(this))throw new Error("ID generation failed. Environment do not belongs to any InputContext yet");return["Environment",I.buildMD5Tokens(this.props)]}static async createInstance(e={}){let t=new X;if(t.props["env.name"]=$.type.name,void 0===Y)t.props["user.agent"]=navigator.userAgent;else{let e=await Y.osInfo();t.props["os.id"]=e.serial.toLowerCase(),t.props["os.name"]=e.codename,t.props["os.version"]=e.release,t.props["os.build"]=e.build,t.props["os.platform"]=`${e.distro} (${e.platform} ${e.arch})`}return Object.keys(e).forEach((r=>t.props[r]=e[r])),t}}const z={DP:160,PICA:6,POINT:72,DIP:96,DPI:96*("undefined"==typeof window?1:window.devicePixelRatio)};class V{static Units={METER:{METER:1,CENTIMETER:100,MILLIMETER:1e3,MICROMETER:1e6,INCH:39.3700787402},CENTIMETER:{METER:.01,CENTIMETER:1,MILLIMETER:10,MICROMETER:1e4,INCH:.3937007874},MILLIMETER:{METER:.001,CENTIMETER:.1,MILLIMETER:1,MICROMETER:1e3,INCH:.0393700787},MICROMETER:{METER:1e-6,CENTIMETER:1e-4,MILLIMETER:.001,MICROMETER:1,INCH:393701e-10},INCH:{METER:.0254,CENTIMETER:2.54,MILLIMETER:25.4,MICROMETER:25400,INCH:1},SECOND:{SECOND:1,MILLISECOND:1e3,MICROSECOND:1e6,NANOSECOND:1e9},MILLISECOND:{SECOND:.001,MILLISECOND:1,MICROSECOND:1e3,NANOSECOND:1e6},MICROSECOND:{SECOND:1e-6,MILLISECOND:.001,MICROSECOND:1,NANOSECOND:1e3},NANOSECOND:{SECOND:1e-9,MILLISECOND:1e-6,MICROSECOND:.001,NANOSECOND:1},RADIAN:{RADIAN:1,DEGREE:57.2957795},DEGREE:{RADIAN:.0174532925,DEGREE:1},NEWTON:{NEWTON:1}};static getChannelResolution(e,t=1){let r=1,i=V.getUnitMetric(e);return i!=V.Metric.NORMALIZED&&i!=V.Metric.LOGICAL&&(r=V[H[i.name].name][e.name]/t),r}static convert(e,t,r,i){return t?r*V[H[e.name].name][i.name]/t:r}static convertAny(e,t,r,i){return e*V[t.name][r.name]/i}static getUnitMetric(e){switch(e){case V.Unit.METER:case V.Unit.CENTIMETER:case V.Unit.MILLIMETER:case V.Unit.MICROMETER:case V.Unit.INCH:case V.Unit.DP:case V.Unit.PICA:case V.Unit.POINT:case V.Unit.DIP:case V.Unit.DPI:return V.Metric.LENGTH;case V.Unit.SECOND:case V.Unit.MILLISECOND:case V.Unit.MICROSECOND:case V.Unit.NANOSECOND:return V.Metric.TIME;case V.Unit.RADIAN:case V.Unit.DEGREE:return V.Metric.ANGLE;case V.Unit.NEWTON:return V.Metric.FORCE;case V.Unit.NORMALIZED:return V.Metric.NORMALIZED;case V.Unit.LOGICAL:return V.Metric.LOGICAL;default:throw console.warn(e),new Error("Invalid unit found")}}static getMetricUnits(e){switch(e){case V.Metric.LENGTH:return[V.Unit.METER,V.Unit.CENTIMETER,V.Unit.MILLIMETER,V.Unit.MICROMETER,V.Unit.INCH,V.Unit.DP,V.Unit.PICA,V.Unit.POINT,V.Unit.DIP,V.Unit.DPI];case V.Metric.TIME:return[V.Unit.SECOND,V.Unit.MILLISECOND,V.Unit.MICROSECOND,V.Unit.NANOSECOND];case V.Metric.ANGLE:return[V.Unit.RADIAN,V.Unit.DEGREE];case V.Metric.FORCE:return[V.Unit.NEWTON];case V.Metric.NORMALIZED:return[V.Unit.NORMALIZED];case V.Metric.LOGICAL:return[V.Unit.LOGICAL];case V.Metric.DIMENSIONLESS:return[];default:throw console.warn(e),new Error("Invalid metric found")}}static getUnit(e){return H[e.name]}static convertValue(e,t,r){return e*V[t.name][r.name]}}Object.defineEnum(V,"Unit",["METER","CENTIMETER","MILLIMETER","MICROMETER","INCH","DP","PICA","POINT","DIP","DPI","SECOND","MILLISECOND","MICROSECOND","NANOSECOND","RADIAN","DEGREE","NEWTON","NORMALIZED","LOGICAL"]),Object.defineEnum(V,"Metric",["LENGTH","TIME","FORCE","ANGLE","NORMALIZED","LOGICAL","DIMENSIONLESS"]);const H=Object.freeze({LENGTH:V.Unit.METER,TIME:V.Unit.SECOND,FORCE:V.Unit.NEWTON,ANGLE:V.Unit.RADIAN,NORMALIZED:V.Unit.NORMALIZED,LOGICAL:V.Unit.LOGICAL});!function(){let e=V.getMetricUnits(V.Metric.LENGTH).filter((e=>!(e.name in z)));for(let t of e){let e=V.Units[t.name];for(let t in z)e[t]=e.INCH*z[t]}for(let t in z){let r={};for(let i of e)r[i.name]=V.Units.INCH[i.name]/z[t];for(let e in z)r[e]=z[e]/z[t];V.Units[t]=r}for(let e in V.Units)V[e]=V.Units[e]}(),Object.freeze(V);class Z extends I{constructor(e,t,r,i,s){if(super(),t==Z.Metric.DIMENSIONLESS)r=1;else if(isNaN(r)||!t){let n=Z.getDefaultUnitDescriptorPerType(e);if(!t){if(!n)throw new Error("metric is required");t=n.metric}if(!r){if(!n)throw new Error("resolution is required");r=V.getChannelResolution(n.unit)}isNaN(i)&&(i=n.min),isNaN(s)&&(s=n.max)}this.type=e,this.metric=t,this.resolution=r,this.min=i,this.max=s,e==Z.Type.TIMESTAMP?this.precision=0:this.precision=2,Object.defineProperty(this,"name",{get:function(){return L.getEnumValueName(this.type.substring(this.type.lastIndexOf("/")+1))}})}getMD5Message(){if(!this.context)throw new Error("ID generation failed. This channel do not belongs to SensorChannelsContext yet");if(!Object.isFrozen(this.context)&&!Object.isFrozen(this))throw new Error("ID generation failed. Underlying SensorChannelsContext do not belongs to any SensorContext yet");let e=[];return e.push("SensorChannel"),e.push(this.context.inkProvider?this.context.inkProvider.id:""),e.push(this.context.device.id),e.push(this.type),e.push(this.metric.name),e.push(this.resolution.toFixed(4)),e.push((this.min||0).toFixed(4)),e.push((this.max||0).toFixed(4)),e.push(this.precision.toString()),e}static getTypeName(e){return Object.keys(Z.Type).find((t=>Z.Type[t]==e))}static getDefaultUnitDescriptorPerType(e){let t={};switch(e){case Z.Type.X:case Z.Type.Y:case Z.Type.Z:case Z.Type.RADIUS_X:case Z.Type.RADIUS_Y:t.unit=V.Unit.DIP;break;case Z.Type.TIMESTAMP:t.unit=V.Unit.MILLISECOND;break;case Z.Type.PRESSURE:t.unit=V.Unit.NORMALIZED,t.min=0,t.max=1;break;case Z.Type.ALTITUDE:case Z.Type.AZIMUTH:case Z.Type.ROTATION:t.unit=V.Unit.RADIAN,t.min=0,t.max=2*Math.PI;break;default:t=null}return t.metric=V.getUnitMetric(t.unit),t}static createCustomChannel(e,t,r,i,s,n){let o=new Z(e,r,i,s,n);return o.precision=t,o}static createDefaultInstance(e,t){let r=Z.getDefaultUnitDescriptorPerType(e);r||console.error(`SensorChannel: createDefaultInstance failed with ${e} type`);let i=V.getChannelResolution(r.unit),s=new Z(e,r.metric,i,r.min,r.max);return s.unit=r.unit,e!=Z.Type.X&&e!=Z.Type.Y||t.type!=S.Type.MOUSE||(s.precision=0),s}}Z.defaults=Object.freeze({PEN:["X","Y","TIMESTAMP","PRESSURE","ALTITUDE","AZIMUTH","ROTATION"],TOUCH:["X","Y","TIMESTAMP","PRESSURE","RADIUS_X","RADIUS_Y","ROTATION"],MOUSE:["X","Y","TIMESTAMP"]}),Z.Type={X:"will://input/3.0/channel/X",Y:"will://input/3.0/channel/Y",Z:"will://input/3.0/channel/Z",TIMESTAMP:"will://input/3.0/channel/Timestamp",PRESSURE:"will://input/3.0/channel/Pressure",RADIUS_X:"will://input/3.0/channel/RadiusX",RADIUS_Y:"will://input/3.0/channel/RadiusY",ALTITUDE:"will://input/3.0/channel/Altitude",AZIMUTH:"will://input/3.0/channel/Azimuth",ROTATION:"will://input/3.0/channel/Rotation"},Z.Metric=V.Metric;class q extends I{constructor(e,t){super(),this.device=e.freeze(),this.inkProvider=Object.freeze(t);let r,i,s=[];Object.defineProperty(this,"channels",{get:function(){return s},set:function(e){this.invalidateID(),s=[],e.forEach((e=>this.add(e)))},enumerable:!0}),Object.defineProperty(this,"layout",{get:function(){return s.map((e=>e.name))},set:function(e){this.invalidateID(),s=s.filter((t=>e.includes(t.name)))},enumerable:!0}),Object.defineProperty(this,"samplingRate",{get:function(){return r},set:function(e){this.invalidateID(),r=e},enumerable:!0}),Object.defineProperty(this,"latency",{get:function(){return i},set:function(e){this.invalidateID(),i=e},enumerable:!0})}getMD5Message(){if(!Object.isFrozen(this))throw new Error("ID generation failed. SensorChannelsContext do not belongs to any SensorContext yet");let e=["SensorChannelsContext",...this.channels.map((e=>e.id))];return e.push(this.samplingRate||""),e.push(this.latency||""),e.push(this.inkProvider?this.inkProvider.id:""),e.push(this.device.id),e}add(e){if((e.type==Z.Type.X||e.type==Z.Type.Y)&&!this.inkProvider)throw new Error("inkProvider is not found. Required for ink group.");e.context=this,Object.freeze(e),this.channels.push(e)}get(e){return this.channels.filter((t=>t.id==e)).first}static createDefaultInstance(e,t){let r=new q(e,t);return r.channels=Z.defaults[t.type.name].map((e=>Z.createDefaultInstance(Z.Type[e],t))),r}}class W extends I{constructor(){super();let e=[];Object.defineProperty(this,"channelsContexts",{get:function(){return e},set:function(t){this.invalidateID(),e=t},enumerable:!0})}getMD5Message(){if(!Object.isFrozen(this))throw new Error("ID generation failed. SensorContext do not belongs to any InputContext yet");return["SensorContext",...this.channelsContexts.map((e=>e.id))]}addContext(e){if(!this.channelsContexts.includes(e)){if(this.channelsContexts.some((t=>t.device==e.device)))throw new Error(`Already exists channelsContext with device ${e.device.id}. Device should be unique in the scope of SensorContext.`);e.inkProvider&&(this.inkChannelsContext=e),Object.freeze(e),this.channelsContexts.push(e)}}getContext(e){return this.channelsContexts.find((t=>t.id==e))}getContextByChannelID(e){return this.channelsContexts.find((t=>t.get(e)))}static createDefaultInstance(e,t){let r=new W;return r.addContext(q.createDefaultInstance(e,t)),r}}class K extends I{constructor(e,t){super(),this.environment=Object.freeze(e),this.sensorContext=Object.freeze(t)}getMD5Message(){return["InputContext",this.environment.id,this.sensorContext.id]}addChannelsContext(e){this.sensorContext.addContext(e)}static createDefaultInstance(e,t,r){let i=W.createDefaultInstance(t,r);return new K(e,i)}}class J{static createTreeURI(e,t){return`uim:tree/${t?`${t}/`:""}${e}`}static createStrokeURI(e,t){return`uim:stroke/${t?`${t}/`:""}${e}`}static createSensorDataURI(e,t){return`uim:sensor/${t?`${t}/`:""}${e}`}static createNodeURI(e,t,r){if(!e)throw new Error("inkTree is required");let i="";return r&&(i=`#frag=${r.fromPointIndex},${r.toPointIndex}`,0==r.fromTValue&&1==r.toTValue||(i+=`,${r.fromTValue.toFixed(5)},${r.toTValue.toFixed(5)}`)),`${J.createNodeURISchema(e)}/${t}${i}`}static createNodeURISchema(e,t=e.name){return`uim:node${e.id?`/${e.id}`:""}/${t}`}static createNamedEntityURI(e,t){return`uim:ne/${t?`${t}/`:""}${e}`}}class Q extends I{constructor(e,t){let r;super(t),Object.defineProperty(this,"uri",{get:()=>(r||(r=J.createSensorDataURI(this.id)),r),enumerable:!0}),this.created=Date.now(),this.inkState=Q.InkState.PLANE,this.context=e,this.streams=[]}add(e){if(!this.context.sensorContext.getContextByChannelID(e.channels.first.id))throw new Error("SensorContext do not contains information about SensorChannelsContext corresponding with this stream");e.ink&&(this.inkStream=e),this.streams.push(e)}}Object.defineEnum(Q,"InkState",["PLANE","HOVERING","IN_VOLUME","VOLUME_HOVERING"]);class ee{constructor(e){this.channels=e,this.data=[],this.ignoredIndex=[],Object.defineProperty(this,"layout",{value:e.map((e=>e.name)),enumerable:!0}),Object.defineProperty(this,"stride",{value:this.layout.length,enumerable:!0}),Object.defineProperty(this,"length",{get:function(){return this.data.length/this.stride},enumerable:!0}),this.ink=this.layout.includes("X")&&this.layout.includes("Y")}add(e,t){t&&this.ignoredIndex.push(this.length),this.channels.forEach((t=>{let r=L.getPropName(t.name),i=e[r];if(t.type==Z.Type.ALTITUDE&&!("altitude"in e))throw new Error("SensorStream input data do not provides altitude");if(t.type==Z.Type.AZIMUTH&&!("azimuth"in e))throw new Error("SensorStream input data do not provides azimuth");this.data.push(i)}))}get(e){if(e>=this.length||e<0)throw new Error(`Index ${e} out of range - (0, ${this.length-1})`);let t={};for(let r=0;r<this.stride;r++){let i=this.channels[r],s=L.getPropName(i.name),n=e*this.stride;t[s]=this.data[n+r]}return t}getChannelData(e){let t=new Float32Array(this.length),r=this.channels.findIndex((t=>t.type==e));this.channels[r].name;for(let e=0;e<this.length;e++)t[e]=this.data[e*this.stride+r];return t}getPipelineMapping(){let e=[];if(this.ignoredIndex.length>0)for(let t=0;t<this.length;t++)this.ignoredIndex.includes(t)||e.push(t);return e}}class te extends I{constructor(){super(),this.props={},this.devices=[]}freeze(){return Object.freeze(this.props),this}getMD5Message(){if(!Object.isFrozen(this.props)&&!Object.isFrozen(this))throw new Error("ID generation failed. InputDevice do not belongs to any SensorChannelsContext yet");return["InputDevice",I.buildMD5Tokens(this.props)]}link(e){if(!(e instanceof te))throw new Error("Implementation of InputDevice is required");this.devices.push(e)}getInkInputProvider(e){return new S(e)}getInkSensorContext(e){let t=this.getInkInputProvider(e);return W.createDefaultInstance(this,t)}openStream(e){if(!this.environment)throw new Error("Environment is not configured for current InputDevice instance");let t=S.Type[e.pointer.type.toUpperCase()],r=this.getInkSensorContext(t),i=new K(this.environment,r);r.inkChannelsContext.layout=te.getLayout(e),this.sensorData=new Q(i),this.sensorData.add(new ee(r.inkChannelsContext.channels)),this.sampleTimestamp=e.timestamp,this.devices.forEach((e=>e.openStream(this.sensorData)))}add(e,t){if(!this.sensorData)throw new Error("Open ink stream not found");e.timestamp-=this.sampleTimestamp,this.sensorData.inkStream.add(e,t)}closeStream(e){let t=this.sensorData;return this.devices.forEach((t=>t.closeStream(e))),this.sensorData=null,this.sampleTimestamp=0,e?null:t}static getLayout(e){let t=[];return Object.keys(Z.Type).forEach((r=>{let i,s=Z.Type[r];i=s==Z.Type.ALTITUDE?"tiltX":s==Z.Type.AZIMUTH?"tiltY":L.getPropName(r),te.isValidInput(i,e)&&t.push(r)})),t}static isValidInput(e,t){let r=!1;return isFinite(t[e])&&(r=!0,"pressure"==e?(r=t.pressure>0,r&&t.pointer&&("mouse"==t.pointer.type?r=!1:"touch"==t.pointer.type&&(r=.5!==t.pressure&&1!==t.pressure))):"tiltX"==e||"tiltY"==e?r=0!=t.tiltX||0!=t.tiltY:"radiusX"==e||"radiusY"==e?r=t.radiusX!=t.radiusY||parseInt(t.radiusX)!=t.radiusX:"rotation"==e&&(r=0!=t.rotation)),r}static async createInstance(e){let t=new this(...Array.from(arguments).slice(1));if(void 0===Y)t.props["dev.graphics.resolution"]=`${screen.width}x${screen.height}`;else{let e=await Y.system(),r=await Y.cpu(),i=await Y.graphics(),s=i.displays.filter((e=>e.main))[0],n=i.controllers[0];t.props["dev.id"]=e.uuid.toLowerCase(),t.props["dev.manufacturer"]=e.manufacturer,t.props["dev.model"]=e.model,t.props["dev.cpu"]=`${r.manufacturer} ${r.brand} ${r.speed} - ${r.cores} core(s)`,t.props["dev.graphics.display"]=`${s.model} ${s.currentResX}x${s.currentResY} (${s.pixeldepth} bit)`,t.props["dev.graphics.adapter"]=`${n.model} ${n.vram} GB`}return t.environment=await X.createInstance(e),t}}let re;class ie{constructor(){if(re)throw new Error("URIResolver instance already available");re=this,this.init()}init(){throw new Error("URIResolver: init should be implemented")}get(e){return this[e]}register(e,t){this[e]=t}resolve(e){let t;if(e.includes("?")){let r=this[e.split("?")[0]];if(r){let i=e.split("?")[1],s=[];i.split("&").forEach((e=>{let t=e.split("=")[1],r=parseFloat(t);isFinite(r)?t=r:"true"==t?t=!0:"false"==t&&(t=!1),s.push(t)})),t=function(){return r(...Array.from(arguments).concat(s))}}}else t=this[e];if(!t)throw new Error(`Failed to resolve ${e}`);return t}}Object.defineProperty(ie,"instance",{get:()=>re});class se{static encode(e,t=se.Encoding.AUTO){let r;if(t==se.Encoding.AUTO&&(t="undefined"==typeof Buffer?"undefined"!=typeof SharedArrayBuffer&&e.buffer instanceof SharedArrayBuffer?se.Encoding.NONE:se.Encoding.ARRAY:se.Encoding.BUFFER),t==se.Encoding.NONE)r=e;else if(t==se.Encoding.ARRAY)r=e.toArray();else{if("undefined"==typeof Buffer)throw new Error("Buffer not found, unable to serialize. Please provide Buffer in global scope.");let i=Buffer.from(e.buffer);switch(t){case se.Encoding.BUFFER:r=i.toJSON();break;case se.Encoding.BASE64:r=i.toString("base64");break;default:throw new Error(`Invalid encoding provided: ${t.name}`)}}return{encoding:t.name,type:e.constructor.name,content:r}}static decode(e){let t,r=se.Encoding[e.encoding];if(r==se.Encoding.NONE)t=e.content;else if(r==se.Encoding.ARRAY)t=e.content.toFloat32Array();else{if("undefined"==typeof Buffer)throw new Error("Buffer not found, unable to deserialize. Please provide Buffer in global scope.");let i;switch(r){case se.Encoding.BUFFER:i=Buffer.from(e.content);break;case se.Encoding.BASE64:i=Buffer.from(e.content,"base64");break;default:throw new Error(`Invalid encoding provided: ${r.name}`)}let s=new Uint8Array(i);t=new globalThis[e.type](s.buffer)}return t}static isTypedArrayData(e){return e&&e.encoding&&e.type&&e.type.endsWith("Array")}}Object.defineEnum(se,"Encoding",["AUTO","NONE","ARRAY","BUFFER","BASE64"]);class ne{static repetitionsCache=new Set;constructor(e,t){this.name=e,!e||L.isValidURL(e)||ne.repetitionsCache.has(e)||(ne.repetitionsCache.add(e),console.warn(`The string ${e} is not a well formed URI`)),Object.defineProperty(this,"value",{get:function(){if(!t){if(!this.name)throw new Error("Resource descriptor identifier not found. Cannot resolve resource content.");if("function"==typeof this.resolve&&(t=this.resolve(this.name)),!t){if(!ie.instance)throw new Error(`Resource URI ${this.name} cannot be resolved. URIResolver not implemented yet. Please implement and instantiate.`);t=ie.instance.resolve(this.name)}if(!t)throw new Error(`Resource URI ${this.name} cannot be resolved. Please provide resource definition in URIResolver init implementation.`)}return t},set:function(e){t=e},enumerable:!0})}toJSON(){let e=this.value;return ArrayBuffer.isTypedArray(e)?e=se.encode(e,this.encoding):"function"==typeof e&&(e=e()),{name:this.name,value:e}}static fromJSON(e){let t=e.value;return se.isTypedArrayData(t)&&(t=se.decode(t)),new ne(e.name,t)}static getInstance(e,t){return new ne(t,e)}}class oe{constructor(e){L.isValidURL(e)||(ne.repetitionsCache.has(e)||(ne.repetitionsCache.add(e),console.warn(`Brush URI ${e} is not a well formed URI`)),e=this.constructor.onInvalidName(e)),Object.defineProperty(this,"id",{value:e}),Object.defineProperty(this,"uri",{value:e}),Object.defineProperty(this,"name",{value:e,enumerable:!0})}toJSON(){throw new Error("Brush.toJSON() should be implemented")}static fromJSON(e){throw new Error("static Brush.fromJSON() should be implemented")}static onInvalidName(e){return e}}class ae{static defaults={CIRCLE_PRECISION:20,CIRCLE_RADIUS:.5,ELLIPSE_PRECISION:20,ELLIPSE_RADIUS_X:.5,ELLIPSE_RADIUS_Y:.25,STAR_POINTS:5,STAR_RADIUS:.5,STAR_INTERNAL_RADIUS:.25};static createCircle(e=ae.defaults.CIRCLE_PRECISION,t=ae.defaults.CIRCLE_RADIUS,r={x:0,y:0}){return ae.createEllipse(e,t,t,r)}static createEllipse(e=ae.defaults.ELLIPSE_PRECISION,t=ae.defaults.ELLIPSE_RADIUS_X,r=ae.defaults.ELLIPSE_RADIUS_Y,i={x:0,y:0}){let s=[],n=2*Math.PI/e;if(t<=0)throw new Error(`Invalid radius x found ${t} > 0`);if(r<=0)throw new Error(`Invalid radius y found ${r} > 0`);for(let o=0;o<e;o++){let e=o*n,a=t*Math.cos(e),l=r*Math.sin(e);s.push(i.x+a,i.y+l)}return Float32Array.createSharedInstance(s)}static createStar(e=ae.defaults.STAR_POINTS,t=ae.defaults.STAR_INTERNAL_RADIUS,r=ae.defaults.STAR_RADIUS){let i=[];if(r<=0)throw new Error(`Invalid radius found ${r} > 0`);if(t<=0)throw new Error(`Invalid internal radius found ${t} > 0`);if(t>r)throw new Error(`Invalid internal radius found 0 < ${t} < ${r}`);let s=2*Math.PI/e;for(let n=0;n<e;n++){let e=n*s,o=r*Math.cos(e),a=r*Math.sin(e),l=t*Math.cos(e+s/2),h=t*Math.sin(e+s/2);i.push(o,a,l,h)}return Float32Array.createSharedInstance(i)}}let le=u?u.default||globalThis.poly2tri:{};const{SweepContext:he,Point:de}=le;class ce{constructor(e,t,r,i=1){if(this.red=e,this.green=t,this.blue=r,this.alpha=i,i<0||i>1)throw new Error(`Invalid alpha ${i} found. The value must be in the interval [0, 1].`);Object.defineProperty(this,"hex",{get:()=>`#${this.red.toString(16).pad(2,"0")}${this.green.toString(16).pad(2,"0")}${this.blue.toString(16).pad(2,"0")}${Math.round(255*this.alpha).toString(16).pad(2,"0")}`,enumerable:!0})}premultiply(){return{red:this.red/255*this.alpha,green:this.green/255*this.alpha,blue:this.blue/255*this.alpha,alpha:this.alpha}}static postdivide(e,t,r,i){let s=parseInt(255*e/i),n=parseInt(255*t/i),o=parseInt(255*r/i);return new ce(s,n,o,i)}equals(e){return e&&this.red==e.red&&this.green==e.green&&this.blue==e.blue&&this.alpha==e.alpha}toRGB(){return 1==this.alpha?this:new ce(this.red,this.green,this.blue)}toRGBA(e){return new ce(this.red,this.green,this.blue,e)}toHSLA(){let e=this.red/255,t=this.green/255,r=this.blue/255,i=Math.min(e,t,r),s=Math.max(e,t,r),n=0,o=0,a=(s+i)/2;if(s!=i){let l=s-i;switch(o=l/(1-Math.abs(2*a-1)),s){case e:n=(t-r)/l%6;break;case t:n=(r-e)/l+2;break;case r:n=(e-t)/l+4}}return n*=60,n<0&&(n+=360),{hue:parseFloat(n.toFixed(0)),saturation:parseFloat((100*o).toFixed(2)),lightness:parseFloat((100*a).toFixed(2)),alpha:this.alpha}}toArray(){return[this.red,this.green,this.blue,this.alpha]}toJSON(){return{red:this.red,green:this.green,blue:this.blue,alpha:this.alpha}}toString(){return 1==this.alpha?`rgb(${this.red}, ${this.green}, ${this.blue})`:`rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`}static isColor(e){return e&&isFinite(e.red)&&isFinite(e.green)&&isFinite(e.blue)}static fromColor(e){let t,r,i,s;if("string"==typeof e)if(e.startsWith("rgb"))e=e.substring(e.indexOf("(")+1,e.indexOf(")")).split(/,\s*/g),t=parseInt(e[0]),r=parseInt(e[1]),i=parseInt(e[2]),s=e[3]?parseInt(e[3]):1;else{if(!e.startsWith("#"))throw new Error(`Unknown input found: ${e}. Expected data starts with rgba, rgb or #.`);e=e.substring(1),t=parseInt(e.substring(0,2),16),r=parseInt(e.substring(2,4),16),i=parseInt(e.substring(4,6),16),s=8==e.length?parseInt(e.substring(6,8),16)/255:1}else Array.isArray(e)?(t=e[0],r=e[1],i=e[2],s=e[3]):(t=e.red,r=e.green,i=e.blue,s=e.alpha);return new ce(t,r,i,s)}static fromHSLA(e=0,t=0,r=0,i){e/=60,t/=100,r/=100;let s=(1-Math.abs(2*r-1))*t,n=s*(1-Math.abs(e%2-1)),o=0,a=0,l=0;e>=0&&e<1?(o=s,a=n):e>=1&&e<2?(o=n,a=s):e>=2&&e<3?(a=s,l=n):e>=3&&e<4?(a=n,l=s):e>=4&&e<5?(o=n,l=s):(o=s,l=n);let h=r-s/2;return o+=h,a+=h,l+=h,new ce(Math.round(255*o),Math.round(255*a),Math.round(255*l),i)}static random(e){return new ce(Math.randomInt(0,255),Math.randomInt(0,255),Math.randomInt(0,255),e?Math.random():1)}}ce.TRANSPERENT=new ce(0,0,0,0),ce.BLACK=new ce(0,0,0,1),ce.WHITE=new ce(255,255,255,1),ce.RED=new ce(255,0,0,1),ce.GREEN=new ce(0,255,0,1),ce.BLUE=new ce(0,0,255,1);class ue{constructor(e,t,r={}){this.layout=e,this.pointProps=t,this.sheet={};let i={};Object.defineProperties(i,{size:{get:this.getComputed.bind(this,"size"),set:this.setStyle.bind(this,"size"),enumerable:!0},red:{get:this.getComputed.bind(this,"red"),set:this.setStyle.bind(this,"red"),enumerable:!0},green:{get:this.getComputed.bind(this,"green"),set:this.setStyle.bind(this,"green"),enumerable:!0},blue:{get:this.getComputed.bind(this,"blue"),set:this.setStyle.bind(this,"blue"),enumerable:!0},alpha:{get:this.getComputed.bind(this,"alpha"),set:this.setStyle.bind(this,"alpha"),enumerable:!0},rotation:{get:this.getComputed.bind(this,"rotation"),set:this.setStyle.bind(this,"rotation"),enumerable:!0},scaleX:{get:this.getComputed.bind(this,"scaleX"),set:this.setStyle.bind(this,"scaleX"),enumerable:!0},scaleY:{get:this.getComputed.bind(this,"scaleY"),set:this.setStyle.bind(this,"scaleY"),enumerable:!0},scaleZ:{get:this.getComputed.bind(this,"scaleZ"),set:this.setStyle.bind(this,"scaleZ"),enumerable:!0},offsetX:{get:this.getComputed.bind(this,"offsetX"),set:this.setStyle.bind(this,"offsetX"),enumerable:!0},offsetY:{get:this.getComputed.bind(this,"offsetY"),set:this.setStyle.bind(this,"offsetY"),enumerable:!0},offsetZ:{get:this.getComputed.bind(this,"offsetZ"),set:this.setStyle.bind(this,"offsetZ"),enumerable:!0},color:{get:this.getComputed.bind(this,"color"),set:this.setStyle.bind(this,"color"),enumerable:!0},blendMode:{get:this.getComputed.bind(this,"blendMode"),set:this.setStyle.bind(this,"blendMode"),enumerable:!0},visibility:{get:this.getComputed.bind(this,"visibility"),set:this.setStyle.bind(this,"visibility"),enumerable:!0},reset:{value:e=>{e&&(r=e),this.clear(),Object.keys(r).forEach((e=>this.setStyle(e,r[e])))}},clear:{value:this.clear.bind(this)}}),this.style=Object.freeze(i),this.style.reset(r)}setStyle(e,t){if(null==t&&(t=void 0),ue.validate(this.layout,e,t),"color"==e&&t)return this.sheet.red=t.red,this.sheet.green=t.green,this.sheet.blue=t.blue,void(this.sheet.alpha=t.alpha);null==t?delete this.sheet[e]:this.sheet[e]=t}getStyle(e){let t=this.sheet[e];return"visibility"==e?"boolean"!=typeof t&&(t=!0):"color"==e&&ce.isColor(this.sheet)&&(t=ce.fromColor(this.sheet)),t}getComputed(e){let t=this.getStyle(e);if(null==t)if("color"==e){let e={red:isFinite(this.sheet.red)?this.sheet.red:this.pointProps.red,green:isFinite(this.sheet.green)?this.sheet.green:this.pointProps.green,blue:isFinite(this.sheet.blue)?this.sheet.blue:this.pointProps.blue,alpha:isFinite(this.sheet.alpha)?this.sheet.alpha:this.pointProps.alpha};ce.isColor(e)&&(t=ce.fromColor(e))}else t=this.pointProps[e];return t}clear(){this.sheet={}}static validate(e,t,r,i){let s;if(r&&e.includes(j.Property[L.getEnumValueName(t)])){if(!i)throw new Error(`Property ${t} value ${r} is not applicable. This is a dynamic property and is part of the layout.`);console.warn(`Property ${t} value ${r} is not applicable. This is a dynamic property and is part of the layout.`),r=void 0}if("color"==t)!r||r instanceof ce||(s=`Property ${t} is not an instance of Color`);else if("blendMode"==t)""==r&&(r=void 0);else if("number"==typeof r)if("size"==t)r<0?s=`Property ${t} with value ${r} is not allowed. Value should be a positive number.`:0==r&&(r=void 0);else if("red"==t||"green"==t||"blue"==t||"alpha"==t){let e="alpha"==t?{min:0,max:1}:{min:0,max:255};r>=e.min&&r<=e.max||(s=`Property ${t} with value ${r} is out of range. Allowd range: [${e.min}, ${e.max}].`)}else"rotation"==t?0==r&&(r=void 0):"scattering"==t&&r<0&&(r=void 0);if(s)throw new Error(s);return r}}const pe=[j.Property.X,j.Property.Y];class fe{constructor(e,t={},r=pe){if(fe.name==this.constructor.name)throw new Error("Path class is abstract. Constructor is not accessible.");if(e%r.length!=0)throw new Error("Points length do not matches with given layout");if(Object.defineProperties(this,{layout:{value:Object.freeze(r)},stride:{value:r.length},length:{value:e/r.length}}),!Object.isSealed(t))for(let e in t)void 0!==t[e]&&(t[e]=ue.validate(this.layout,e,t[e],!0));r.includes(j.Property.ROTATION)||"rotation"in t||(t.rotation=void 0),r.includes(j.Property.SIZE)||t.size||(t.size=1),Object.defineProperty(this,"pointProps",{value:Object.seal(t)}),r.forEach(((e,t)=>{let r=L.getPropName(e.name,!0);Object.defineProperty(this,`setPoint${r}`,{value:this.setPointPropertyValue.bind(this,t)}),Object.defineProperty(this,`getPoint${r}`,{value:this.getPointPropertyValue.bind(this,t)})}))}setPointPropertyValue(e,t,r){if(isNaN(t))throw new Error("Point index is required");if(t>=this.length||t<0)throw new Error(`Index ${e} out of range - (0, ${this.length-1})`);if(isNaN(r))throw new Error("value is required");this.points[t*this.layout.length+e]=r}getPointPropertyValue(e,t){if(isNaN(t))throw new Error("Point index is required");if(t>=this.length||t<0)throw new Error(`Index ${e} out of range - (0, ${this.length-1})`);return this.points[t*this.layout.length+e]}setPoint(e,t){let r=e*this.stride;this.layout.forEach(((e,i)=>this.points[r+i]=t.getProperty(e)))}getPoint(e,t=this.pointProps){if(e>=this.length||e<0)throw new Error(`Index ${e} out of range - (0, ${this.length-1})`);return j.createInstance(this.layout,t,this.points,e)}getChannelData(e){let t=new([j.Property.RED,j.Property.GREEN,j.Property.BLUE].includes(e)?Uint8Array:Float32Array)(this.length),r=this.layout.indexOf(e);if(-1==r)throw new Error(`Property ${e.name} is not part from the spline layout ${this.layout.map((e=>e.name)).join(", ")}`);for(let e=0;e<this.length;e++)t[e]=this.points[e*this.stride+r];return t}transform(e){let t=e.scaleX,i=e.rotation;for(let s=0;s<this.length;s++){let n=s*this.stride,o=r.vec4.fromValues(this.getPointX(s),this.getPointY(s),0,1);r.vec4.transformMat4(o,o,e.value);for(let e=0;e<this.stride;e++){let r=n+e;switch(this.layout[e]){case j.Property.X:this.points[r]=o[0]/o[3];break;case j.Property.Y:this.points[r]=o[1]/o[3];break;case j.Property.Z:this.points[r]=o[2]/o[3];break;case j.Property.ROTATION:this.points[r]+=i;break;case j.Property.SIZE:case j.Property.SCALE_X:case j.Property.SCALE_Y:case j.Property.SCALE_Z:case j.Property.OFFSET_X:case j.Property.OFFSET_Y:case j.Property.OFFSET_Z:this.points[r]*=t}}}this.layout.includes(j.Property.ROTATION)||(this.pointProps.rotation=0==i?void 0:i)}clone(){throw new Error("Path.clone()) is abstract and should be implemented")}slice(e){throw new Error("Path.slice(fragment)) is abstract and should be implemented")}slicePoints(e,t,r=0,i=1){throw new Error("Path.slicePoints(fromPointIndex, toPointIndex, fromTValue, toTValue)) is abstract and should be implemented")}toSVGPath(){let e=[];for(let t=0;t<this.length;t++)e.push(`${this.getPointX(t)},${this.getPointY(t)}`);return`M ${e.join(" L ")} Z`}toJSON(){throw new Error("Path.toJSON() is abstract and should be implemented")}static fromJSON(e){throw new Error("static Path.fromJSON(data) is abstract and should be implemented")}static fromRect(e,t){return new this([e.left,e.top,e.right,e.top,e.right,e.bottom,e.left,e.bottom,e.left,e.top],t)}}class me{constructor(e,t,r,i=0,s=1){Object.defineProperties(this,{path:{value:e,enumerable:!0},fromPointIndex:{value:t,enumerable:!0},toPointIndex:{value:r,enumerable:!0},fromTValue:{value:i,enumerable:!0},toTValue:{value:s,enumerable:!0}}),this.validate()}validate(){me.validate(this.path,this.fromPointIndex,this.toPointIndex,this.fromTValue,this.toTValue)}overlaps(e){if(e.path!=this.path)return!1;let t=e.fromPointIndex<this.toPointIndex-3||e.fromPointIndex==this.toPointIndex-3&&e.fromTValue<=this.toTValue,r=e.toPointIndex-3>this.fromPointIndex||e.toPointIndex-3==this.fromPointIndex&&e.toTValue>=this.fromTValue;return t&&r}toPath(){return this.path.slice(this)}toString(){return`fragment${this.path.id?`{${this.path.id}}`:""}(${this.fromPointIndex}, ${this.toPointIndex}, ${this.fromTValue}, ${this.toTValue})`}static validate(e,t,r,i=0,s=1){if(t<0)throw new Error(`Invalid fragment fromPointIndex ${t} found. The value must be non-negative.`);if(r>e.length-1)throw new Error(`Invalid fragment toPointIndex ${r} found. Last point in path index is ${e.length-1}.`);if(isFinite(e.ts)&&isFinite(e.tf)){if(i<0||i>=1)throw new Error(`Invalid fragment fromTValue ${i} found. The value must be in the interval [0, 1).`);if(s<=0||s>1)throw new Error(`Invalid fragment toTValue ${s} found. The value must be in the interval (0, 1].`);if(r+1-t<4)throw new Error(`Invalid fragment points range {${t}, ${r}} found. At least 4 points are needed to define spline.`);if(t==r-3&&s<=i)throw new Error(`Invalid fragment T values range {${i}, ${s}} found. The value must be in the interval (fromTValue, 1].`)}}}j.Property.X,j.Property.Y;class ge extends fe{constructor(e,t,r){super(e.length,t,r),Array.isArray(e)&&(e=Object.seal(e)),Object.defineProperty(this,"points",{get:()=>e,enumerable:!0})}clone(){return new ge(this.points.clone(),Object.clone(this.pointProps),this.layout.slice())}slice(e){let t=this.slicePoints(e.fromPointIndex,e.toPointIndex);return new ge(t,Object.clone(this.pointProps),this.layout.slice())}slicePoints(e,t,r=0,i=1){return me.validate(this,e,t,r,i),this.points.slice(e*this.stride,(t+1)*this.stride)}toJSON(){return{type:"ArrayPath",points:this.points,pointProps:this.pointProps,layout:this.layout.map((e=>e.name))}}static fromJSON(e){if("ArrayPath"!=e.type)throw new Error(`ArrayPath deserialization failed. JSON type is ${e.type}, expected ArrayPath.`);return new ge(e.points,e.pointProps,e.layout.map((e=>j.Property[e])))}}class ye extends fe{constructor(e,t,r){super(e.length,t,r),e=Float32Array.createSharedInstance(e),Object.defineProperty(this,"points",{get:()=>e,enumerable:!0}),Object.defineProperty(this,"buffer",{get:()=>e.buffer,set:t=>{if("undefined"!=typeof SharedArrayBuffer&&this.points.buffer instanceof SharedArrayBuffer)throw new Error("Underlying buffer is SharedArrayBuffer and cannot be restored");if(this.points.buffer.byteLength>0)throw new Error("Cannot restore buffer when underlying buffer is not empty");e=new Float32Array(t)}})}clone(e=!1){if(0==this.buffer.byteLength)throw new Error("Path buffer is empty. Data could be processing under some thread. Clone failed.");return e?new ge(this.points.toArray(),Object.clone(this.pointProps),this.layout.slice()):new ye(this.points.clone(),Object.clone(this.pointProps),this.layout.slice())}slice(e){let t=this.slicePoints(e.fromPointIndex,e.toPointIndex);return new ye(t,Object.clone(this.pointProps),this.layout.slice())}slicePoints(e,t,r=0,i=1){let s;if(me.validate(this,e,t,r,i),"undefined"!=typeof SharedArrayBuffer&&this.buffer instanceof SharedArrayBuffer){let r=this.points.subarray(e*this.stride,(t+1)*this.stride),i=new SharedArrayBuffer(r.length*Float32Array.BYTES_PER_ELEMENT);s=new Float32Array(i),s.set(r)}else s=this.points.slice(e*this.stride,(t+1)*this.stride);return s}toJSON(){return{type:"SharedPath",points:se.encode(this.points,this.encoding),pointProps:this.pointProps,layout:this.layout.map((e=>e.name))}}static fromJSON(e){if("SharedPath"!=e.type)throw new Error(`SharedPath deserialization failed. JSON type is ${e.type}, expected SharedPath.`);return new ye(se.decode(e.points),e.pointProps,e.layout.map((e=>j.Property[e])))}}class be{constructor(e=2){this.stride=e}sort(e,t){return this.sortArrayPart(e,0,e.length-this.stride,t),e}partition(e,t,r,i){let s=e[r],n=e[r+1],o=t-this.stride;for(let a=t;a<r;a+=2)i?i(s,n,e[a],e[a+1])&&(o+=this.stride,this.swap(e,o,a)):(s>e[a]||s==e[a]&&n>e[a+1])&&(o+=this.stride,this.swap(e,o,a));return this.swap(e,o+this.stride,r),o+this.stride}swap(e,t,r){let i=e[t],s=e[t+1];return e[t]=e[r],e[t+1]=e[r+1],e[r]=i,e[r+1]=s,e}sortArrayPart(e,t,r,i){if(t<r){let s=this.partition(e,t,r,i);this.sortArrayPart(e,t,s-this.stride,i),this.sortArrayPart(e,s+this.stride,r,i)}}}function Ee(e,t,r,i,s,n){return(r-e)*(n-t)-(i-t)*(s-e)}function Pe(e,t,r,i,s,n){let o=e-r,a=s-r,l=o*(n-i)-a*(t-i);l*=l,o=s-r,a=n-i;let h=o*o+a*a;return h>0?Math.sqrt(l/h):Math.sqrt((r-e)*(r-e)+(i-t)*(i-t))}var Ie=Object.freeze({__proto__:null,vector:function(e,t){let r,i={};return Object.defineProperty(i,"x",{value:t.x-e.x,enumerable:!0}),Object.defineProperty(i,"y",{value:t.y-e.y,enumerable:!0}),Object.defineProperty(i,"length",{get:()=>(isNaN(r)&&(r=Math.sqrt(i.x*i.x+i.y*i.y)),r),enumerable:!0}),i},angle:function(e,t){let r=e.x*t.x+e.y*t.y,i=e.x*t.y-e.y*t.x;return Math.atan2(i,r)},cross:Ee,perpendicularDistance:Pe});class Se{constructor(e=Float32Array){this.ArrayType=e,this.quickSort=new be}monotoneChain(e){if(e.length<=0)return new this.ArrayType;this.quickSort.sort(e);let t=new this.ArrayType(e.length),r=0;for(let i=0;i<e.length;i+=2){for(;r>=4&&Ee(t[r-4],t[r-3],t[r-2],t[r-1],e[i],e[i+1])<=0;)r-=2;t[r]=e[i],t[r+1]=e[i+1],r+=2}t=t.slice(0,r);let i,s=new this.ArrayType(e.length);r=0;for(let t=e.length-2;t>=0;t-=2){for(;r>=4&&Ee(s[r-4],s[r-3],s[r-2],s[r-1],e[t],e[t+1])<=0;)r-=2;s[r]=e[t],s[r+1]=e[t+1],r+=2}if(s=s.slice(0,r-2),this.ArrayType==Float32Array){let e=s.length+t.length;i=Float32Array.createSharedInstance(e),i.set(s),i.set(t,s.length)}else i=s.concat(t);return i}}class xe{constructor(e,t=[]){if(!(e instanceof fe))throw new Error("Expected shape type is Path. Use createInstance or createSharedInstance Polygon methods to allocate instance.");if(t.some((e=>!(e instanceof fe))))throw new Error("Expected hole type is Path. Use createInstance or createSharedInstance Polygon methods to allocate instance.");let r;this.holesDirection=xe.PointsDirection.CLOCKWISE,Object.defineProperty(this,"shape",{value:e,enumerable:!0}),Object.defineProperty(this,"holes",{value:t,enumerable:!0}),Object.defineProperty(this,"contours",{value:[e,...t],enumerable:!0}),Object.defineProperty(this,"ArrayType",{value:e instanceof ye?Float32Array:Array}),Object.defineProperty(this,"bounds",{get:()=>v.ofPolygon(this),enumerable:!0}),Object.defineProperty(this,"vertices",{get:()=>(r||(r=this.triangulate()),r),set:e=>r=e,enumerable:!0}),Object.defineProperty(this,"verticesValue",{get:()=>r})}clone(e=!1){let t=this.shape.clone(e),r=this.holes.map((t=>t.clone(e))),i=new xe(t,r);return this.verticesValue&&(i.vertices=this.vertices.slice()),i}fit(e){let t=this.bounds,r=e.width/t.width,i=e.height/t.height,s=r>0&&i>0?Math.min(r,i):Math.max(r,i);for(let e of this.contours)for(let t=0;t<e.length;t++)e.setPointX(t,e.getPointX(t)*s),e.setPointY(t,e.getPointY(t)*s)}center(){let e=this.bounds;for(let t of this.contours)for(let r=0;r<t.length;r++)t.setPointX(r,t.getPointX(r)-e.center.x),t.setPointY(r,t.getPointY(r)-e.center.y)}transform(e){this.contours.forEach((t=>t.transform(e)))}intersects(e){if(!(e instanceof xe))throw new Error("Expected 'poly' type is Polygon");let t=this.shape,r=e.shape;for(let e=0;e<2;e++){let i=0==e?t:r;for(let e=0;e<i.length;e++){let s=e+1==i.length?0:e+1,n=i.getPointX(e),o=i.getPointY(e),a=i.getPointX(s),l=i.getPointY(s)-o,h=n-a,d=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY;for(let e=0;e<t.length;e++){let r=l*t.getPointX(e)+h*t.getPointY(e);r<d&&(d=r),r>c&&(c=r)}let u=Number.POSITIVE_INFINITY,p=Number.NEGATIVE_INFINITY;for(let e=0;e<r.length;e++){let t=l*r.getPointX(e)+h*r.getPointY(e);t<u&&(u=t),t>p&&(p=t)}if(c<u||p<d)return!1}}return!0}triangulate(){let e,t=[];for(let e of this.contours){let r=[];for(let t=0;t<e.length;t++){let i=new de(e.getPointX(t),e.getPointY(t));if(t>0){if(r.last.x==i.x&&r.last.y==i.y)continue;if(t==e.length-1&&r.first.x==i.x&&r.first.y==i.y)continue}r.push(i)}t.push(r)}try{e=new he(t.shift())}catch(e){return console.error(e),new Float32Array}for(let r of t)try{e.addHole(r)}catch(e){return console.error(e),new Float32Array}try{e.triangulate()}catch(e){return console.warn(e),new Float32Array}let r=e.getTriangles(),i=Float32Array.createSharedInstance(6*r.length),s=0;for(let e of r){let t=e.getPoints();for(let e of t)i[s++]=e.x,i[s++]=e.y}return i}convex(){return this.buildConvex.convex(this.shape.points)}union(e){let t=Array.of(...this.shape.points,...e.shape.points);return this.buildConvex(t)}buildConvex(e){this.convexHullProducer||(this.convexHullProducer=new Se(this.ArrayType));let t=this.convexHullProducer.monotoneChain(e);return this.ArrayType==Float32Array?xe.createSharedInstance(t):xe.createInstance(t)}simplify(e=.1){if(e<=0)throw new Error("epsilon expected value > 0");this.epsilon=e;let t=this.simplifyPath(this.shape),r=[];for(let e of this.holes){let t=this.simplifyPath(e);t.length>0&&r.push(t)}return this.shape instanceof ye?xe.createSharedInstance(t,r):xe.createInstance(t,r)}simplifyPath(e){if(e.length<3)return e.points;let t=Array.of(...e.points,e.getPointX(0),e.getPointY(0)),r=this.simplifyPolyline(t);return r.length<8?t.slice(0,t.length-2):r.slice(0,r.length-2)}simplifyPolyline(e){if(e.length<4)return e;let t=0,r=0;for(let i=2;i<e.length-2;i+=2){let s=Pe(e[i],e[i+1],e[0],e[1],e[e.length-2],e[e.length-1]);s>t&&(r=i,t=s)}if(t>this.epsilon){let t=this.simplifyPolyline(e.slice(0,r+2)),i=this.simplifyPolyline(e.slice(r,e.length));return t.concat(i.slice(2,i.length))}return[e[0],e[1],e[e.length-2],e[e.length-1]]}toSVGPath(){return this.contours.map((e=>e.toSVGPath())).join(" ")}toJSON(){return{type:"Polygon",shape:this.shape.toJSON(),holes:this.holes.map((e=>e.toJSON())),holesDirection:this.holesDirection.name,vertices:this.verticesValue}}static fromJSON(e){if("Polygon"!=e.type)throw new Error(`Polygon deserialization failed. JSON type is ${e.type}, expected Polygon.`);let t="SharedPath"==e.shape.type?ye.fromJSON(e.shape):ge.fromJSON(e.shape),r=e.holes.map((e=>"SharedPath"==e.type?ye.fromJSON(e):ge.fromJSON(e))),i=new xe(t,r);return i.holesDirection=xe.PointsDirection[e.holesDirection],i.vertices=e.vertices,i}static fromRect(e){return xe.createInstance([e.left,e.top,e.right,e.top,e.right,e.bottom,e.left,e.bottom,e.left,e.top])}static createInstance(e,t=[]){return new xe(new ge(e),t.map((e=>new ge(e))))}static createSharedInstance(e,t=[]){let r=new xe(new ye(e),t.map((e=>new ye(e))));return Object.defineProperty(r,"encoding",{get:()=>r.shape.encoding,set:e=>{r.contours.forEach((t=>t.encoding=e))},enumerable:!0}),r}}Object.defineEnum(xe,"PointsDirection",["CLOCKWISE","COUNTERCLOCKWISE"]);class we{static SHAPE_FRAME=new v(-.5,-.5,1,1);constructor(e,t=1){this.size=t,Object.defineProperty(this,"descriptor",{value:{shape:void 0},enumerable:!0}),Object.defineProperty(this,"shape",{get:function(){if(!e){if("function"==typeof(e=this.descriptor.shape.value)&&(e=e()),(Array.isArray(e)||e instanceof Float32Array)&&(e=xe.createSharedInstance(e)),!(e instanceof xe))throw new Error("Expected shape type is Polygon");we.fitShape(e)}return e},set:function(t){if(!t)throw new Error("BrushPrototype: shape not found");"string"==typeof t?t=new ne(t):t instanceof xe||t instanceof Float32Array||Array.isArray(t)?t=ne.getInstance(t):t instanceof ne||(t=new ne(t.name,t.value)),e=null,this.descriptor.shape=t,this.descriptor.shape.resolve=we.resolve},enumerable:!0}),this.shape=e}toJSON(){return this.shape.encoding=this.encoding,{shape:{name:this.descriptor.shape.name,value:this.shape.toJSON()},size:this.size}}static fromJSON(e){return new we({name:e.shape.name,value:xe.fromJSON(e.shape.value)},e.size)}static create(e,t=0,...r){let i,s=e;switch(e){case we.Type.CIRCLE:i=ae.createCircle(...r),s+=`?precision=${r[0]||ae.defaults.CIRCLE_PRECISION}&radius=${r[1]||ae.defaults.CIRCLE_RADIUS}`;break;case we.Type.ELLIPSE:i=ae.createEllipse(...r),s+=`?precision=${r[0]||ae.defaults.ELLIPSE_PRECISION}&radiusX=${r[1]||ae.defaults.ELLIPSE_RADIUS_X}&radiusY=${r[2]||ae.defaults.ELLIPSE_RADIUS_Y}`;break;case we.Type.STAR:i=ae.createStar(...r),s+=`?points=${r[0]||ae.defaults.STAR_POINTS}&internalRadius=${r[1]||ae.defaults.STAR_INTERNAL_RADIUS}&radius=${r[2]||ae.defaults.STAR_RADIUS}`;break;default:console.error(`Brush2D: createShape fails with ${e} type`)}return new we({name:s,shape:i},t)}static resolve(e){let t,r=e.split("?"),i=r.first;if(Object.values(we.Type).includes(i)){let e=r.last.split("&"),s={};switch(e.forEach((e=>{s[e.substring(0,e.indexOf("="))]=e.substring(e.indexOf("=")+1)})),i){case we.Type.CIRCLE:{let e=s.precision?parseInt(s.precision):void 0,r=s.radius?parseFloat(s.radius):1;t=ae.createCircle(e,r);break}case we.Type.ELLIPSE:{let e=s.precision?parseInt(s.precision):void 0,r=s.radiusX?parseFloat(s.radiusX):void 0,i=s.radiusY?parseFloat(s.radiusY):void 0;t=ae.createEllipse(e,r,i);break}case we.Type.STAR:{let e=s.points?parseInt(s.points):void 0,r=s.radius?parseFloat(s.radius):void 0,i=s.internalRadius?parseFloat(s.internalRadius):void 0;t=ae.createStar(e,i,r);break}default:console.error(`Brush2D: createShape fails with ${i} type`)}}return t}static fitShape(e){if(!(e instanceof xe))throw new Error("Expected shape type is Polygon");e.center(),e.fit(we.SHAPE_FRAME)}}async function Te(e,t="binary",r={}){if(e instanceof Uint8Array)return e;let i,s=await fetch(e,Object.assign({mode:"no-cors"},r));if("json"==t)i=await s.json();else if("text"==t)i=await s.text();else if("binary"==t){let e=await s.arrayBuffer();i=new Uint8Array(e)}else{let e=await s.blob();i="base64"==t?await function(e){return new Promise(((t,r)=>{let i=new FileReader;i.readAsDataURL(e),i.onloadend=()=>t(i.result),i.onerror=r}))}(e):e}return i}async function ve(e,t="binary",r={}){return Te(e,t,r)}async function Re(e){let t;return t="string"==typeof e||"undefined"==typeof createImageBitmap?await function(e){return new Promise(((t,r)=>{let i,s=new Image;s.crossOrigin="anonymous",s.onload=()=>{if($.type2D==$.Type2D.OFFSCREEN){const e=new OffscreenCanvas(s.width,s.height);e.getContext("2d").drawImage(s,0,0),t(e)}else i&&URL.revokeObjectURL(i),t(s)},s.onerror=r,"string"==typeof e?s.src=e:$.type2D==$.Type2D.OFFSCREEN?e instanceof Uint8Array?s.src=Buffer.from(e):e instanceof OffscreenCanvas?t(e):s.src=e:(e instanceof Uint8Array&&(e.byteLength!=e.buffer.byteLength&&(e=e.slice()),e=e.buffer),e instanceof ArrayBuffer&&(e=new Blob([e],{type:"image/png"})),i=URL.createObjectURL(e),s.src=i)}))}(e):e instanceof ArrayBuffer||e instanceof Uint8Array?await createImageBitmap(new Blob([e],{type:"image/png"})):await createImageBitmap(e),t}we.Type={ELLIPSE:"will://brush/3.0/shape/Ellipse",CIRCLE:"will://brush/3.0/shape/Circle",STAR:"will://brush/3.0/shape/Star"};var Ae=Object.freeze({__proto__:null,readFile:Te,loadFile:ve,exists:async function(e,t={}){return 200==(await fetch(e,Object.assign({method:"HEAD",cache:"no-store"},t))).status},loadImage:Re,saveAs:function(e,t,r="application/octet-stream"){let i;if(e instanceof Blob)i=URL.createObjectURL(e);else{let t;e instanceof ArrayBuffer?t=[e]:e.buffer?(e.byteLength<e.buffer.byteLength&&(e=new Uint8Array(e)),t=[e.buffer]):e instanceof Array&&(t=e);let s=new Blob(t,{type:r});i=URL.createObjectURL(s)}let s=document.createElement("a");s.href=i,s.download=t,s.appendChild(document.createTextNode(t)),s.style.display="none",document.body.appendChild(s),s.click(),setTimeout((function(){URL.revokeObjectURL(i),s.remove()}),911)}});class Oe extends oe{constructor(e,t,r,i=1){super(e),isFinite(r)&&(i=r,r=void 0),i<=0&&(console.warn(`Invalid spacing found ${i}. It should be positive number.`),i=1),Object.defineProperty(this,"shape",{get:()=>t,set:e=>{if(e instanceof Float32Array&&(e=new we(e)),e instanceof we&&(e=[e]),e.some((e=>!(e instanceof we))))throw console.warn(e),new Error("Brush2D: Invalid shape found");e.sort(L.comparator({sortBy:"size",sortOrder:"asc"})),t=e},enumerable:!0}),this.shape=t,this.fill=r,this.spacing=i}async configure(e){if(this.pattern||!this.fill)return;if(!(e instanceof CanvasRenderingContext2D||e instanceof OffscreenCanvasRenderingContext2D))throw new Error("ctx is not instance of CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D");let t=await Re(this.fill);this.pattern=e.createPattern(t,"repeat")}selectShape(e){let t;for(let r=1;r<this.shape.length;r++)if(this.shape[r].size>e){t=this.shape[r-1];break}return t||(t=this.shape.last),t.shape}toJSON(){return{type:"Brush2D",name:this.name,spacing:this.spacing,shape:this.shape.map((e=>(e.encoding=this.encoding,e.toJSON())))}}static fromJSON(e){let t=1==e.shape.length?we.fromJSON(e.shape[0]):e.shape.map((e=>we.fromJSON(e)));return new Oe(e.name,t,e.spacing)}}class Ce{static get excludedProps(){return[j.Property.D_X,j.Property.D_Y]}static get posProps(){return[j.Property.X,j.Property.Y,j.Property.Z]}static get colorProps(){return[j.Property.RED,j.Property.GREEN,j.Property.BLUE,j.Property.ALPHA]}static get transformProps(){return[j.Property.ROTATION,j.Property.SCALE_X,j.Property.SCALE_Y,j.Property.SCALE_Z,j.Property.OFFSET_X,j.Property.OFFSET_Y,j.Property.OFFSET_Z]}constructor(){this.state={}}isLayoutPart(e){if(Ce.posProps.includes(e))return this.inputLayout.includes(e.name);if(this.brush instanceof Oe&&Ce.colorProps.includes(e))return!1;if(Ce.excludedProps.includes(e))return!1;let t=!1,r=L.getPropName(e.name),i=this.dynamics[r];if(i&&!i.disabled)if(i.dependencies&&i.dependencies.length>0){let e=this.inputLayout.map((e=>Z.Type[e]));t=i.dependencies.filter((t=>e.includes(t))).length>0}else t=!0;return t}calculate(e,t,r){return this.point=t.createPathPoint(this.statics),this.calculateProperty(j.Property.SIZE,e,t,r),Ce.colorProps.forEach((i=>this.calculateProperty(i,e,t,r))),Ce.transformProps.forEach((i=>this.calculateTransform(i,e,t,r))),this.point}calculateProperty(e,t,r,i){if(!this.layout.includes(e))return;let s,n=L.getPropName(e.name),o=this.dynamics[n],a=this.state[n];if("function"==typeof a.resolve)s=a.resolve(t,r,i);else if(this.inputLayout.includes("PRESSURE")){let e=r.pressure||t.pressure/2;s=Ce.mapTo(e,a.pressure,o.value)}else{let e=r.speed(t,i);0==e&&t&&(e=t.velocity),r.velocity=e,s=Ce.mapTo(e,a.velocity,o.value)}this.point[L.getPropName(e.name)]=s}calculateTransform(e,t,r,i){if(!this.layout.includes(e))return;let s,n=L.getPropName(e.name),o=this.dynamics[n],a=this.state[n];if("function"==typeof a.resolve)s=a.resolve(t,r,i);else{let i=o.dependencies||[];if(e==j.Property.ROTATION)if(i.includes(Z.Type.ROTATION)&&this.inputLayout.includes("ROTATION"))s=r.rotation;else{if(!i.includes(Z.Type.AZIMUTH)||!this.inputLayout.includes("AZIMUTH"))throw new Error(`Property ${e.name} is not configured properly. Dependencies are expected or resolve handler.`);s=r.computeNearestAzimuthAngle(t)}else if(i.includes(Z.Type.ALTITUDE)&&this.inputLayout.includes("ALTITUDE")){r.cosAltitude||(r.cosAltitude=Math.cos(r.altitude));let e=r.cosAltitude;s=Ce.mapTo(e,a.altitude,o.value)}else{if(e!=j.Property.SCALE_X&&e!=j.Property.SCALE_Y||!i.includes(Z.Type.RADIUS_X)&&!i.includes(Z.Type.RADIUS_Y)||!this.inputLayout.includes("RADIUS_X")||!this.inputLayout.includes("RADIUS_Y"))throw new Error(`Property ${e.name} is not configured properly. Dependencies are expected or resolve handler.`);{let t=e==j.Property.SCALE_X?"radiusX":"radiusY",i=r[t];s=Ce.mapTo(i,a[t],o.value)}}}if(isNaN(s))throw new Error(`Property ${e.name} has no value`);this.point[L.getPropName(e.name)]=s}reset(e,t,r,i={},s={}){if(this.brush=t,this.dynamics=i,this.statics={},this.color=new ce(0,0,0),this.inputLayout=te.getLayout(e),this.layout=j.Property.values.filter((e=>this.isLayoutPart(e))),this.debug&&console.log(e.pointer.type,this.inputLayout,this.layout.map((e=>e.name)),e),"size"in s){if(this.isLayoutPart(j.Property.SIZE))throw new Error("Size should exist only in dynamics or statics");this.statics.size=s.size}else{if(!this.isLayoutPart(j.Property.SIZE))throw new Error("Size not found. Should be set through dynamics or statics.");if(0==e.pressure&&"pen"==e.pointer.type)throw new Error("Hover point detected. Should be handeled manually.")}Ce.colorProps.forEach((e=>{let t=L.getPropName(e.name);this.isLayoutPart(e)?this.color[t]=r[t]:(this.statics[t]=isFinite(s[t])?s[t]:r[t],this.color[t]=this.statics[t])})),Ce.transformProps.forEach((e=>{if(this.isLayoutPart(e))return;let t=L.getPropName(e.name);isFinite(s[t])&&(this.statics[t]=s[t])})),this.resetState(e)}resetState(e){this.state={},[j.Property.SIZE].concat(Ce.colorProps).forEach((e=>{if(!this.layout.includes(e))return;let t=L.getPropName(e.name),r=this.dynamics[t],i={};if(r.resolve)i.resolve=Ce.resolveAction(r.resolve);else{if(!r.value)throw new Error(`PathPointContext: dynamics ${t} value property not found`);if(r.value.min>r.value.max)throw new Error(`PathPointContext: dynamics ${t} invalid value range found: ${r.value.min} - ${r.value.max}`);let e=this.clonePropertySettings(r.velocity,0,4e3);e.remap=Ce.resolveAction(e.remap||r.value.remap);let s=this.clonePropertySettings(r.pressure,0,1);s.remap=Ce.resolveAction(s.remap||r.value.remap),i.velocity=Ce.validateRange(t,e,{min:0,max:3e4}),i.pressure=Ce.validateRange(t,s,{min:0,max:1})}this.state[t]=i})),Ce.transformProps.forEach((t=>{if(!this.layout.includes(t))return;let r=L.getPropName(t.name),i=this.dynamics[r],s={};if(i.resolve)s.resolve=Ce.resolveAction(i.resolve);else if(i.dependencies){if(i.dependencies.includes(Z.Type.ALTITUDE)){if(!i.value)throw new Error(`PathPointContext: dynamics ${r} value property not found`);if(i.value.min>i.value.max)throw new Error(`PathPointContext: dynamics ${r} invalid value range found: ${i.value.min} - ${i.value.max}`);let e=this.clonePropertySettings(i.altitude,0,Math.PI/2);e.remap=Ce.resolveAction(e.remap||i.value.remap),s.altitude=Ce.validateRange(r,e,{min:0,max:Math.PI/2})}if(t==j.Property.SCALE_X&&i.dependencies.includes(Z.Type.RADIUS_X)||t==j.Property.SCALE_Y&&i.dependencies.includes(Z.Type.RADIUS_Y)){if(!i.value)throw new Error(`PathPointContext: dynamics ${r} value property not found`);let n=t==j.Property.SCALE_X?"radiusX":"radiusY",o=i[n]||{},a=e[n]<=1?0:1,l=e[n]<=1?1:50,h=e[n]<=1?{min:0,max:1,remap:o.remap}:o,d=this.clonePropertySettings(h,a,l);d.remap=Ce.resolveAction(d.remap||i.value.remap),s[n]=Ce.validateRange(r,d,{min:a,max:l})}}this.state[r]=s}))}clonePropertySettings(e,t,r){let i;return e?(i=Object.clone(e),"min"in i||(i.min=t),"max"in i||(i.max=r)):i={min:t,max:r},i}static resolveAction(e){if(e)return"string"==typeof e?e=new ne(e):"function"==typeof e?e=ne.getInstance(e):e instanceof ne||(e=new ne(e.name,e.value)),e.value}static validateRange(e,t,r){if(t.min<r.min||t.max>r.max)throw new Error(`${e} config is out of range - (${t.min}, ${t.max}), expected values interval - (${r.min}, ${r.max})`);if(t.min>t.max)throw new Error(`${e} min ${t.min} exceeds max ${t.max}`);return t}static mapTo(e,t,r){let i=(L.clamp(e,t)-t.min)/(t.max-t.min);return t.remap&&(i=t.remap(i)),r.min+i*(r.max-r.min)}}class De{static ARRAY_TYPE=Array;constructor(){this.keepAllData=!1,Object.defineProperty(this,"allData",{get:()=>{if(!this.keepAllData)throw new Error("All data is not accumulated. By default keepAllData property is false.");return this.path||(this.path=new this.constructor.ARRAY_TYPE),this.getOutput(this.path,De.OutputType.ALL_DATA)},enumerable:!0})}build(e,t=De.OutputType.PROCESSOR,r=!0){let i;switch(t){case De.OutputType.ADDITION:i=this.add(e,r);break;case De.OutputType.PREDICTION:i=this.predict(e);break;case De.OutputType.PROCESSOR:this.reset(),i=this.buildImpl(e,t);break;default:throw new Error("Unexpected OutputType found. Allowed type is oneof(ADDITION, PREDICTION, PROCESSOR)")}return t!=De.OutputType.PREDICTION&&this.keepAllData&&(this.path||(this.path=new this.constructor.ARRAY_TYPE),i instanceof xe?this.path.push(i):this.path.push(...i)),this.debug&&console.log(this.constructor.name,t.name,r,i),this.getOutput(i,t)}add(e,t=!1){return this.buildImpl(e,De.OutputType.ADDITION)}predict(e){return this.buildImpl(e,De.OutputType.PREDICTION)}buildImpl(e){throw new Error("Abstract method buildImpl(input) of DataSequenceProcessor should be implemented")}getOutput(e,t){return e}reset(){this.path&&(this.path=new this.constructor.ARRAY_TYPE)}}function ke(){}Object.defineEnum(De,"OutputType",["ADDITION","PREDICTION","ALL_DATA","PROCESSOR"]),ke.BlendMode={SOURCE_OVER:"source-over",DESTINATION_OVER:"destination-over",DESTINATION_IN:"destination-in",DESTINATION_OUT:"destination-out",LIGHTER:"lighter",COPY:"copy",MIN:"MIN",MAX:"MAX",DIRECT_SOURCE_OUT:"DIRECT_SOURCE_OUT",DIRECT_DESTINATION_OUT:"DIRECT_DESTINATION_OUT"};const Ne=ke.BlendMode;class Me{static ANTIALIASING={passesSqrt:4,passes:16,spread:1.25,step:.3125,weight:1.01/16};static IDENTITY_MATRIX=r.mat4.create();constructor(e){if(!e)throw new Error("GL context is not available in current environment");let t,r;this.gl=e,this.program=null,this.programs=[],Object.defineProperty(this,"blendMode",{get:()=>t,set:e=>{if(!e)throw new Error("blendMode is required");t!=e&&(this.activeBlendMode(e),t=e)},enumerable:!0}),Object.defineProperty(this,"transform",{get:()=>r&&!r.isIdentity?r:null,set:e=>{e!=r&&(r=e,this.program&&this.program.onContextChange())}}),Object.defineProperty(Me,"VERTEX_SHADER_PRECISION",{value:this.getSupportedFloatPrecision(this.gl.VERTEX_SHADER),enumerable:!0,configurable:!0}),Object.defineProperty(Me,"FRAGMENT_SHADER_PRECISION",{value:this.getSupportedFloatPrecision(this.gl.FRAGMENT_SHADER),enumerable:!0,configurable:!0}),Object.defineProperty(Me,"VERTEX_BATCH_SIZE",{value:1e3,enumerable:!0})}init(e,t){this.gl.disable(this.gl.DITHER),this.gl.disable(this.gl.BLEND),this.gl.disable(this.gl.STENCIL_TEST),this.gl.disable(this.gl.DEPTH_TEST),this.gl.disable(this.gl.SCISSOR_TEST),this.gl.activeTexture(this.gl.TEXTURE0),this.blendMinMaxExt=this.gl.getExtension("EXT_blend_minmax"),this.blendMaxFallback=!this.gl.MAX&&!this.blendMinMaxExt,this.blendMode=Ne.COPY,this.resize(e,t),this.scatterMethodRandomSeed=parseInt(Date.now()/1e3),this.onChange();for(let e=0;e<this.programs.length;e++)this.programs[e].init()}getSupportedFloatPrecision(e){return this.gl.getShaderPrecisionFormat(e,this.gl.HIGH_FLOAT).precision>0?"highp":this.gl.getShaderPrecisionFormat(e,this.gl.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}random(){return this.scatterMethodRandomSeed=1103515245*this.scatterMethodRandomSeed+12345&Number.MAX_INT32,this.scatterMethodRandomSeed/Number.MAX_INT32}static random(e){return(1103515245*e+12345&Number.MAX_INT32)/Number.MAX_INT32}setUniforms(e){let t=r.mat4.create();e?r.mat4.ortho(t,this.graphicsBox.left,this.graphicsBox.right,this.graphicsBox.top,this.graphicsBox.bottom,1,-1):r.mat4.ortho(t,this.graphicsBox.left,this.graphicsBox.right,this.graphicsBox.bottom,this.graphicsBox.top,1,-1),this.graphicsSpaceToFramebufferSpaceT=t,this.onChange()}resize(e,t){this.gl.viewport(e.x,e.y,e.width,e.height),this.bounds=e,this.graphicsBox=t,this.clipRect=t}activeBlendMode(e){switch(e){case Ne.COPY:this.gl.disable(this.gl.BLEND);break;case Ne.SOURCE_OVER:this.gl.enable(this.gl.BLEND),this.gl.blendEquation(this.gl.FUNC_ADD),this.gl.blendFunc(this.gl.ONE,this.gl.ONE_MINUS_SRC_ALPHA);break;case Ne.DESTINATION_OVER:this.gl.enable(this.gl.BLEND),this.gl.blendEquation(this.gl.FUNC_ADD),this.gl.blendFunc(this.gl.ONE_MINUS_DST_ALPHA,this.gl.ONE);break;case Ne.DESTINATION_IN:this.gl.enable(this.gl.BLEND),this.gl.blendEquation(this.gl.FUNC_ADD),this.gl.blendFunc(this.gl.ZERO,this.gl.SRC_ALPHA);break;case Ne.DESTINATION_OUT:this.gl.enable(this.gl.BLEND),this.gl.blendEquation(this.gl.FUNC_ADD),this.gl.blendFunc(this.gl.ZERO,this.gl.ONE_MINUS_SRC_ALPHA);break;case Ne.DESTINATION_IN_MULTIPLY:this.gl.enable(this.gl.BLEND),this.gl.blendEquation(this.gl.FUNC_ADD),this.gl.blendFunc(this.gl.ZERO,this.gl.SRC_COLOR);break;case Ne.DESTINATION_OUT_NO_ALPHA:this.gl.enable(this.gl.BLEND),this.gl.blendEquation(this.gl.FUNC_ADD),this.gl.blendFunc(this.gl.ZERO,this.gl.ONE_MINUS_SRC_COLOR);break;case Ne.LIGHTER:this.gl.enable(this.gl.BLEND),this.gl.blendEquation(this.gl.FUNC_ADD),this.gl.blendFunc(this.gl.ONE,this.gl.ONE);break;case Ne.MIN:this.gl.enable(this.gl.BLEND),this.gl.MIN?this.gl.blendEquation(this.gl.MIN):this.blendMinMaxExt?this.gl.blendEquation(this.blendMinMaxExt.MIN_EXT):(this.gl.blendEquation(this.gl.FUNC_ADD),this.gl.blendFunc(this.gl.ONE,this.gl.ONE_MINUS_SRC_ALPHA));break;case Ne.MAX:this.gl.enable(this.gl.BLEND),this.gl.MAX?this.gl.blendEquation(this.gl.MAX):this.blendMinMaxExt?this.gl.blendEquation(this.blendMinMaxExt.MAX_EXT):(this.gl.blendEquation(this.gl.FUNC_ADD),this.gl.blendFunc(this.gl.ONE,this.gl.ONE_MINUS_SRC_ALPHA));break;case Ne.DIRECT_SOURCE_OUT:this.gl.enable(this.gl.BLEND),this.gl.blendEquation(this.gl.FUNC_SUBTRACT),this.gl.blendFunc(this.gl.ONE,this.gl.ONE);break;case Ne.DIRECT_DESTINATION_OUT:this.gl.enable(this.gl.BLEND),this.gl.blendEquation(this.gl.FUNC_REVERSE_SUBTRACT),this.gl.blendFunc(this.gl.ONE,this.gl.ONE);break;default:throw new Error(`Unsupported blend mode: ${e}`)}}clearColorBuffer(e){this.gl.clearColor(e.red*e.alpha/255,e.green*e.alpha/255,e.blue*e.alpha/255,e.alpha),this.gl.clear(this.gl.COLOR_BUFFER_BIT)}scissors(e){if(e&&!(e instanceof T))throw new TypeError("rect must be undefined or instanceof RectGL");let t=this.gl.isEnabled(this.gl.SCISSOR_TEST);e?(t||this.gl.enable(this.gl.SCISSOR_TEST),this.gl.scissor(e.x,e.y,e.width,e.height)):t&&this.gl.disable(this.gl.SCISSOR_TEST)}isProgramActive(e){return this.program==e}activateProgram(e){this.isProgramActive(e)?e.contextChanged&&(e.onContextChange(),e.contextChanged=!1):(this.program&&this.program.onDeactivate(),this.gl.useProgram(e.program),this.program=e,e.onActivate(),e.onContextChange(),e.contextChanged=!1)}generateBuffersExt(e,t,r,i){let s=this.gl,n=s.createFramebuffer();s.bindFramebuffer(s.FRAMEBUFFER,n);let o=s.createTexture();return s.activeTexture(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,o),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MAG_FILTER,r),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MIN_FILTER,r),s.texImage2D(s.TEXTURE_2D,0,s.RGBA,e,t,0,s.RGBA,i,null),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,o,0),s.clearColor(0,0,0,0),s.clear(s.COLOR_BUFFER_BIT),{framebuffer:n,texture:o}}genFrameAndRenders(e,t,r){let i=this.gl.createFramebuffer(),s=this.gl.createRenderbuffer();return this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,i),this.gl.bindRenderbuffer(this.gl.RENDERBUFFER,s),this.gl.renderbufferStorage(this.gl.RENDERBUFFER,e,t,r),this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER,this.gl.COLOR_ATTACHMENT0,this.gl.RENDERBUFFER,s),{framebuffer:i,renderbuffer:s}}deleteBuffers(e,t){t&&this.gl.deleteTexture(t),e&&this.gl.deleteFramebuffer(e)}deleteFrameAndRender(e,t){t&&this.gl.deleteRenderbuffer(t),e&&this.gl.deleteFramebuffer(e)}onChange(){for(let e=0;e<this.programs.length;e++)this.programs[e].contextChanged=!0}enableStencilBufferForBlending(e){this.gl.enable(this.gl.STENCIL_TEST),this.gl.stencilMask(4294967295),this.gl.clearStencil(0),this.gl.clear(this.gl.STENCIL_BUFFER_BIT),this.isStencilBufferAvailable()||this.attachStencilBufferForBlending(e)}isStencilBufferAvailable(){return this.gl.getFramebufferAttachmentParameter(this.gl.FRAMEBUFFER,this.gl.STENCIL_ATTACHMENT,this.gl.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE)==this.gl.RENDERBUFFER}attachStencilBufferForBlending(e){let t=this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);if(e.framebuffer==t){let t=this.gl.createRenderbuffer();this.gl.bindRenderbuffer(this.gl.RENDERBUFFER,t),this.gl.renderbufferStorage(this.gl.RENDERBUFFER,this.gl.STENCIL_INDEX8,e.width,e.height),this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER,this.gl.STENCIL_ATTACHMENT,this.gl.RENDERBUFFER,t),e.renderbuffer=t,e.releaseRenderbuffer=!0}}drawArrays(e,t,r){this.blendMode==Ne.MAX&&this.blendMaxFallback?this.drawBlendMaxFallback(this.gl.drawArrays.bind(this.gl,e,t,r)):this.gl.drawArrays(e,t,r)}drawElements(e,t,r,i){this.blendMode==Ne.MAX&&this.blendMaxFallback?this.drawBlendMaxFallback(this.gl.drawElements.bind(this.gl,e,t,r,i)):this.gl.drawElements(e,t,r,i)}drawBlendMaxFallback(e){this.gl.enable(this.gl.STENCIL_TEST),this.gl.stencilFunc(this.gl.NOTEQUAL,1,1),this.gl.stencilOp(this.gl.REPLACE,this.gl.REPLACE,this.gl.REPLACE),this.blendMode=Ne.DIRECT_DESTINATION_OUT,e(),this.gl.stencilFunc(this.gl.NOTEQUAL,2,1),this.gl.stencilOp(this.gl.REPLACE,this.gl.REPLACE,this.gl.REPLACE),this.inkGLContext.blendMode=Ne.LIGHTER,e(),this.gl.disable(this.gl.STENCIL_TEST)}static logGLError(e,t=""){let r=e.getError();if(r>0){let i;e.constructor.prototype&&(i=Object.keys(e.constructor.prototype).filter((t=>e[t]===r)).join(" | ")),console.error(`WebGL${t?" ":""}${t}: ${r}${i?` - ${i}`:""}`)}}}class Le{constructor(){}setTransform(e){this.matrix=e}getExportCanvas(e){throw new Error("Abstract method getExportCanvas of Layer inheritor should be implemented")}async toBlob(e,t="image/png",r=.92){if("undefined"==typeof Blob)throw"undefined"==typeof Buffer?new Error("Current environment do not have neither Blob nor Buffer support."):new Error("This method is not compliant in underlying environment. Use `toBuffer` instead.");let i=this.getExportCanvas(e);return i.toBlob?new Promise(((e,s)=>i.toBlob(e,t,r))):i.convertToBlob({type:t,quality:r})}async toBuffer(e,t="image/png",r={}){if("undefined"==typeof Buffer)throw"undefined"==typeof Blob?new Error("Current environment do not have neither Blob nor Buffer support."):new Error("This method is not compliant in underlying environment. Use `toBlob` instead.");let i=this.getExportCanvas(e);if(r.filters){let e=Array.isArray(r.filters)?r.filters.slice():[r.filters],t=0;e.forEach((e=>{t|=i[`PNG_FILTER_${e.name}`]})),Object.assign({},r,{filters:t})}return new Promise(((e,s)=>i.toBuffer(((t,r)=>t?s(t):e(r)),t,r)))}static getDefaultSize(e,t){let r={};return"undefined"==typeof screen?(r.width=e,r.height=t):navigator.maxTouchPoints?(r.width=Math.max(screen.width,screen.height),r.height=r.width):(r.width=screen.width,r.height=screen.height),r}}Object.defineEnum(Le,"PNGFilterType",["NO","ALL","NONE","SUB","UP","AVG","PAETH"]);class _e{constructor(e,t){Object.defineProperty(this,"ctx",{value:e,enumerable:!0}),Object.defineProperty(this,"value",{value:t,enumerable:!0}),Object.defineProperty(this,"texture",{value:t,enumerable:!0})}async update(e,t){if(Array.isArray(e)){let r=[],i=e;for(let e of i){let t=await Re(e);r.push(t)}this.completeMipMap(r),this.fill(r,t)}else{let t=e,r=await Re(t);this.fill(r)}}completeMipMap(e){if(e.sort(((e,t)=>t.width-e.width)),1==e.last.width)return;let t=e.last.width;for(;t>1;){t/=2;let r=new OffscreenCanvas(e.last.width/2,e.last.height/2);r.getContext("2d").drawImage(e.last,0,0,r.width,r.height),e.push(r)}}fill(e,t){let r=this.ctx,i=this.value;if(r.bindTexture(r.TEXTURE_2D,i),r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),Array.isArray(e)){let i=e;this.size=[],i.forEach(((e,t)=>{r.texImage2D(r.TEXTURE_2D,t,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,e),this.size.push({width:e.width,height:e.height}),e.close&&e.close()})),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,t?r.LINEAR_MIPMAP_LINEAR:r.LINEAR_MIPMAP_NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.LINEAR)}else r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,e),this.size={width:e.width,height:e.height},e.close&&e.close();r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),r.bindTexture(r.TEXTURE_2D,null),this.logError(this.ctx,i.name)}readPixels(){let e=this.ctx,t=this.value,r=(r,i)=>{let s=new Uint8Array(r.width*r.height*4);return e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,i),e.readPixels(0,0,r.width,r.height,e.RGBA,e.UNSIGNED_BYTE,s),s},i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i);let s=Array.isArray(this.size)?this.size.map(r):r(this.size,0);return e.deleteFramebuffer(i),s}logError(){let e=this.ctx.getError();if(e>0){let t=Object.keys(this.ctx.constructor.prototype).filter((t=>this.ctx[t]===e)).join(" | ");console.error(`WebGL error - ${this.texture.name}: ${e} - ${t}`)}}static createInstance(e,t=e.CLAMP_TO_EDGE,r=e.NEAREST){let i=e.createTexture();return e.bindTexture(e.TEXTURE_2D,i),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,r),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,r),e.bindTexture(e.TEXTURE_2D,null),new _e(e,i)}}class Fe extends Le{constructor(e,t={}){if(super(),this.inkGLContext=e,this.gl=e.gl,this.scaleFactor=t.scaleFactor||1,this.flipY=!!t.flipY,this.useTextureStorage=!1,t.renderbuffer){if(!t.framebuffer)throw new Error("`framebuffer` is required when `renderbuffer` available");let e=this.initWithGLBuffers(t.framebuffer,t.renderbuffer);this.flipY=!0,this.ownGLResources=!!t.ownGLResources,this.setDimensions(e.width,e.height)}else if(t.framebuffer){let e=this.initWithGLFramebuffer(t.framebuffer);this.flipY=!0,this.ownGLResources=!!t.ownGLResources,this.setDimensions(e.width,e.height)}else if(t.texture){if(!(t.texture instanceof WebGLTexture))throw new Error("`texture` is not instance of WebGLTexture");let e;if(this.texture=t.texture,this.useTextureStorage=!0,t.width>0&&t.height>0)e={width:t.width,height:t.height};else if(this.texture.image)e={width:this.texture.image.width,height:this.texture.image.height};else{if(!this.texture.size)throw new Error("`width` and `height` are required when `texture` is available");e=this.texture.size}this.ownGLResources=!!t.ownGLResources,this.setDimensions(e.width,e.height)}else if(this.setDimensions(t.width,t.height),t.display)this.framebuffer=null,this.renderbuffer=null,this.texture=null;else if(this.useTextureStorage=!t.useBuffersStorage,this.ownGLResources=!0,this.useTextureStorage){let e=this.inkGLContext.generateBuffersExt(this.storageWidth,this.storageHeight,this.gl.LINEAR,this.gl.UNSIGNED_BYTE);this.framebuffer=e.framebuffer,this.texture=e.texture}else{let e=this.inkGLContext.genFrameAndRenders(this.gl.RGBA8||this.gl.RGBA4,this.storageWidth,this.storageHeight);this.framebuffer=e.framebuffer,this.renderbuffer=e.renderbuffer}this.releaseRenderbuffer=!1,this.deleted=!1}initWithGLFramebuffer(e){if(!(e instanceof WebGLFramebuffer))throw new Error("`framebuffer` is not instance of WebGLFramebuffer");let t,r=this.gl.getParameter(this.gl.RENDERBUFFER_BINDING);if(this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,e),this.gl.getError()==this.gl.INVALID_OPERATION)throw new Error("Invalid framebuffer");if(this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER)!=this.gl.FRAMEBUFFER_COMPLETE)throw new Error("Incomplete framebuffer");if(this.gl.getFramebufferAttachmentParameter(this.gl.FRAMEBUFFER,this.gl.COLOR_ATTACHMENT0,this.gl.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE)!=this.gl.RENDERBUFFER)throw new Error("Renderbuffer attachment not found");return t=this.gl.getFramebufferAttachmentParameter(this.gl.FRAMEBUFFER,this.gl.COLOR_ATTACHMENT0,this.gl.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME),this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,r),this.initWithGLBuffers(e,t)}initWithGLBuffers(e,t){if(!(e instanceof WebGLFramebuffer))throw new Error("`framebuffer` is not instance of WebGLFramebuffer");if(!(t instanceof WebGLRenderbuffer))throw new Error("`renderbuffer` is not instance of WebGLRenderbuffer");let r=this.gl.getParameter(this.gl.RENDERBUFFER_BINDING);this.gl.bindRenderbuffer(this.gl.RENDERBUFFER,t);let i=this.gl.getRenderbufferParameter(this.gl.RENDERBUFFER,this.gl.RENDERBUFFER_WIDTH),s=this.gl.getRenderbufferParameter(this.gl.RENDERBUFFER,this.gl.RENDERBUFFER_HEIGHT);return this.gl.bindRenderbuffer(this.gl.RENDERBUFFER,r),this.framebuffer=e,this.renderbuffer=t,{width:i,height:s}}setDimensions(e,t){let r=Math.ceil(e*this.scaleFactor),i=Math.ceil(t*this.scaleFactor),s=new T(0,0,e,t),n=new T(0,0,r,i);Object.defineProperties(this,{width:{value:e,enumerable:!0,configurable:!0},height:{value:t,enumerable:!0,configurable:!0},graphicsBounds:{value:s,enumerable:!0,configurable:!0},storageWidth:{value:r,enumerable:!0,configurable:!0},storageHeight:{value:i,enumerable:!0,configurable:!0},storageBounds:{value:n,enumerable:!0,configurable:!0}})}resize(e,t){e>0&&t>0&&(this.width!=e||this.height!=t)&&(this.setDimensions(e,t),this.useTextureStorage?(this.gl.bindTexture(this.gl.TEXTURE_2D,this.texture),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.storageWidth,this.storageHeight,0,this.gl.RGBA,this.gl.UNSIGNED_BYTE,null)):this.renderbuffer&&(this.gl.bindRenderbuffer(this.gl.RENDERBUFFER,this.renderbuffer),this.gl.renderbufferStorage(this.gl.RENDERBUFFER,this.gl.RGBA8||this.gl.RGBA4,this.storageWidth,this.storageHeight)))}fillTexture(e){if(!this.texture)throw new Error("Underlying layer is not texture based");new _e(this.gl,this.texture).fill(e)}delete(){this.ownGLResources&&(this.useTextureStorage?this.inkGLContext.deleteBuffers(this.framebuffer,this.texture):this.inkGLContext.deleteFrameAndRender(this.framebuffer,this.renderbuffer)),this.releaseRenderbuffer&&this.renderbuffer&&(this.gl.deleteRenderbuffer(this.renderbuffer),this.renderbuffer=null,this.releaseRenderbuffer=!1),this.deleted=!0}deleteLater(){setTimeout((()=>this.delete()),0)}isDeleted(){return this.deleted}}class Be{constructor(e){this.gl=e.gl,this.inkGLContext=e,this.program=this.createProgram(this.compileShader(this.constructor.getVertexShader(),this.gl.VERTEX_SHADER),this.compileShader(this.constructor.getFragmentShader(this.gl.getContextAttributes().premultipliedAlpha),this.gl.FRAGMENT_SHADER)),this.contextChanged=!0}init(){}compileShader(e,t){let r=this.gl.createShader(t);if(this.gl.shaderSource(r,e),this.gl.compileShader(r),!this.gl.getShaderParameter(r,this.gl.COMPILE_STATUS))throw new Error(`${this.constructor.name} could not compile ${t==this.gl.VERTEX_SHADER?"VERTEX":"FRAGMENT"} shader: ${this.gl.getShaderInfoLog(r)}`);return r}createProgram(e,t){let r=this.gl.createProgram();if(this.gl.attachShader(r,e),this.gl.attachShader(r,t),this.gl.linkProgram(r),!this.gl.getProgramParameter(r,this.gl.LINK_STATUS))throw new Error(`${this.constructor.name} failed to link: ${this.gl.getProgramInfoLog(r)}`);return r}onActivate(){}onDeactivate(){}onContextChange(){}activate(){this.inkGLContext.activateProgram(this)}}class Ue extends Be{constructor(e){super(e),this.buffer=this.gl.createBuffer()}init(){this.a_position=this.gl.getAttribLocation(this.program,"a_position"),this.u_color=this.gl.getUniformLocation(this.program,"u_color"),this.u_projectionMatrix=this.gl.getUniformLocation(this.program,"u_projectionMatrix"),this.u_viewMatrix=this.gl.getUniformLocation(this.program,"u_viewMatrix")}onContextChange(){this.gl.uniform4f(this.u_color,this.color.red,this.color.green,this.color.blue,this.color.alpha),this.gl.uniformMatrix4fv(this.u_projectionMatrix,!1,this.inkGLContext.graphicsSpaceToFramebufferSpaceT),this.gl.uniformMatrix4fv(this.u_viewMatrix,!1,this.inkGLContext.transform?this.inkGLContext.transform.value:Me.IDENTITY_MATRIX)}onDeactivate(){this.gl.disableVertexAttribArray(this.a_position),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,null)}drawVertices(e,t,r,i=!0,s=!1,n=!1){let o;this.color=r.premultiply(),i&&!n?(t=this.antialias(t),o=Ne.LIGHTER):(Array.isArray(t)&&(t=new Float32Array(t)),o=n?Ne.MAX:Ne.SOURCE_OVER);let a=t.length/2;this.activate(),this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,e),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.buffer),this.gl.bufferData(this.gl.ARRAY_BUFFER,t,this.gl.STATIC_DRAW),this.gl.enableVertexAttribArray(this.a_position),this.gl.vertexAttribPointer(this.a_position,2,this.gl.FLOAT,!1,0,0),s&&(this.inkGLContext.blendMode=Ne.DIRECT_DESTINATION_OUT,this.gl.drawArrays(this.gl.TRIANGLES,0,a)),this.inkGLContext.blendMode=o,this.gl.drawArrays(this.gl.TRIANGLES,0,a)}antialias(e){let{passesSqrt:t,passes:r,spread:i,step:s,weight:n}=Me.ANTIALIASING,o=new Float32Array(e.length*r),a=0;for(let r=0;r<t;r++)for(let n=0;n<t;n++){let t=r*s-(i-s)/2,l=n*s-(i-s)/2;for(let r=0;r<e.length;r+=2)o[a++]=e[r]+t,o[a++]=e[r+1]+l}return this.color={red:this.color.red*n,green:this.color.green*n,blue:this.color.blue*n,alpha:this.color.alpha*n},o}static getVertexShader(){return`\n\t\t\tprecision ${Me.VERTEX_SHADER_PRECISION} float;\n\n\t\t\tuniform mat4 u_projectionMatrix;\n\t\t\tuniform mat4 u_viewMatrix;\n\t\t\tuniform lowp vec4 u_color;\n\n\t\t\tattribute highp vec4 a_position;\n\n\t\t\tvarying lowp vec4 v_color;\n\n\t\t\tvoid main() {\n\t\t\t\tvec4 viewPosition = u_viewMatrix * a_position;\n\n\t\t\t\tgl_Position = u_projectionMatrix * viewPosition;\n\t\t\t\tv_color = u_color;\n\t\t\t}\n\t\t`}static getFragmentShader(){return"\n\t\t\tvarying lowp vec4 v_color;\n\n\t\t\tvoid main() {\n\t\t\t\tgl_FragColor = v_color;\n\t\t\t}\n\t\t"}}const je=16*Float32Array.BYTES_PER_ELEMENT;class Ge extends Be{constructor(e){super(e),this.vao=this.gl.createVertexArray(),this.positionBuffer=this.gl.createBuffer(),this.colorBuffer=this.gl.createBuffer(),this.matrixBuffer=this.gl.createBuffer()}init(){this.a_position=this.gl.getAttribLocation(this.program,"a_position"),this.a_color=this.gl.getAttribLocation(this.program,"a_color"),this.a_matrix=this.gl.getAttribLocation(this.program,"a_matrix"),this.u_viewMatrix=this.gl.getUniformLocation(this.program,"u_viewMatrix")}onContextChange(){this.gl.uniformMatrix4fv(this.u_viewMatrix,!1,this.inkGLContext.transform?this.inkGLContext.transform.value:Me.IDENTITY_MATRIX)}onDeactivate(){this.gl.disableVertexAttribArray(this.a_position),this.gl.disableVertexAttribArray(this.a_color),this.gl.disableVertexAttribArray(this.a_matrix),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,null),this.gl.bindVertexArray(null)}drawVertices(e,t,i,s=!0,n=!1,o=!1){i=i.premultiply(),Array.isArray(t)&&(t=new Float32Array(t));let a,l,h,d=1,c=t.length/2,u=this.inkGLContext.graphicsSpaceToFramebufferSpaceT;if(s&&!o){let{passesSqrt:e,passes:t,spread:s,step:n,weight:o}=Me.ANTIALIASING,c=[i.red*o,i.green*o,i.blue*o,i.alpha*o];d=t,a=new Float32Array(4*d),l=new Float32Array(16*d);for(let e=0;e<d;++e)for(let t=0;t<4;t++)a[4*e+t]=c[t];for(let t=0;t<e;t++)for(let i=0;i<e;i++){let o=16*(e*t+i),a=o*Float32Array.BYTES_PER_ELEMENT;for(let e=0;e<16;e++)l[o+e]=u[e];let h=new Float32Array(l.buffer,a,16),d=t*n-(s-n)/2,c=i*n-(s-n)/2;r.mat4.translate(h,h,r.vec4.fromValues(d,c,0,1))}h=Ne.LIGHTER}else a=new Float32Array([i.red,i.green,i.blue,i.alpha]),l=u,h=o?Ne.MAX:Ne.SOURCE_OVER;this.activate(),this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,e),this.gl.bindVertexArray(this.vao),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.positionBuffer),this.gl.bufferData(this.gl.ARRAY_BUFFER,t,this.gl.STATIC_DRAW),this.gl.enableVertexAttribArray(this.a_position),this.gl.vertexAttribPointer(this.a_position,2,this.gl.FLOAT,!1,0,0),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.colorBuffer),this.gl.bufferData(this.gl.ARRAY_BUFFER,a,this.gl.STATIC_DRAW),this.gl.enableVertexAttribArray(this.a_color),this.gl.vertexAttribPointer(this.a_color,4,this.gl.FLOAT,!1,0,0),this.gl.vertexAttribDivisor(this.a_color,1),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.matrixBuffer),this.gl.bufferData(this.gl.ARRAY_BUFFER,l,this.gl.STATIC_DRAW);for(let e=0;e<4;e++){let t=this.a_matrix+e,r=16*e;this.gl.enableVertexAttribArray(t),this.gl.vertexAttribPointer(t,4,this.gl.FLOAT,!1,je,r),this.gl.vertexAttribDivisor(t,1)}n&&(this.inkGLContext.blendMode=Ne.DIRECT_DESTINATION_OUT,this.gl.drawArraysInstanced(this.gl.TRIANGLES,0,c,d)),this.inkGLContext.blendMode=h,this.gl.drawArraysInstanced(this.gl.TRIANGLES,0,c,d)}static getVertexShader(){return"#version 300 es\n\t\t\tin vec4 a_position;\n\t\t\tin vec4 a_color;\n\t\t\tin mat4 a_matrix;\n\n\t\t\tuniform mat4 u_viewMatrix;\n\n\t\t\tout vec4 v_color;\n\n\t\t\tvoid main() {\n\t\t\t\tvec4 viewPosition = u_viewMatrix * a_position;\n\n\t\t\t\tgl_Position = a_matrix * viewPosition;\n\t\t\t\tv_color = a_color;\n\t\t\t}\n\t\t"}static getFragmentShader(){return"#version 300 es\n\t\t\tprecision highp float;\n\n\t\t\tin vec4 v_color;\n\n\t\t\tout vec4 outColor;\n\n\t\t\tvoid main() {\n\t\t\t\toutColor = v_color;\n\t\t\t}\n\t\t"}}class $e extends Be{constructor(e){super(e),this.destBuffer=this.gl.createBuffer(),this.srcBuffer=this.gl.createBuffer()}init(){this.a_position=this.gl.getAttribLocation(this.program,"a_position"),this.a_srcPosition=this.gl.getAttribLocation(this.program,"a_srcPosition"),this.u_texture=this.gl.getUniformLocation(this.program,"u_texture"),this.u_projectionMatrix=this.gl.getUniformLocation(this.program,"u_projectionMatrix"),this.u_textureMatrix=this.gl.getUniformLocation(this.program,"u_textureMatrix")}onDeactivate(){this.gl.bindBuffer(this.gl.ARRAY_BUFFER,null)}drawTexture(e,t,r,i,s){this.activate(),this.gl.disable(this.gl.DEPTH_TEST),this.gl.disable(this.gl.STENCIL_TEST),this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D,e),this.gl.uniform1i(this.u_texture,0),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.destBuffer),this.gl.bufferData(this.gl.ARRAY_BUFFER,t,this.gl.DYNAMIC_DRAW),this.gl.enableVertexAttribArray(this.a_position),this.gl.vertexAttribPointer(this.a_position,2,this.gl.FLOAT,!1,0,0),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.srcBuffer),this.gl.bufferData(this.gl.ARRAY_BUFFER,r,this.gl.DYNAMIC_DRAW),this.gl.enableVertexAttribArray(this.a_srcPosition),this.gl.vertexAttribPointer(this.a_srcPosition,2,this.gl.FLOAT,!1,0,0),this.gl.uniformMatrix4fv(this.u_projectionMatrix,!1,i),this.gl.uniformMatrix4fv(this.u_textureMatrix,!1,s),this.inkGLContext.drawArrays(this.gl.TRIANGLE_STRIP,0,4)}static getVertexShader(){return`\n\t\t\tprecision ${Me.VERTEX_SHADER_PRECISION} float;\n\n\t\t\tuniform mat4 u_projectionMatrix;\n\t\t\tuniform mat4 u_textureMatrix;\n\t\t\tattribute highp vec4 a_position;\n\t\t\tattribute highp vec4 a_srcPosition;\n\t\t\tvarying highp vec2 v_textureCoordinate;\n\n\t\t\tvoid main() {\n\t\t\t\tgl_Position = u_projectionMatrix * a_position;\n\t\t\t\tv_textureCoordinate = (u_textureMatrix * a_srcPosition).xy;\n\t\t\t}\n\t\t`}static getFragmentShader(){return`\n\t\t\tprecision ${Me.FRAGMENT_SHADER_PRECISION} float;\n\n\t\t\tvarying vec2 v_textureCoordinate;\n\t\t\tuniform lowp sampler2D u_texture;\n\n\t\t\tvoid main() {\n\t\t\t\tgl_FragColor = texture2D(u_texture, v_textureCoordinate);\n\t\t\t}\n\t\t`}}class Ye extends oe{constructor(e,t,r,i={},s={}){super(e),this.spacing=i.spacing||.15,this.scattering=i.scattering||0,this.rotationMode=i.rotationMode||Ye.RotationMode.RANDOM;let n=i.blendMode||Ne.SOURCE_OVER;Object.defineProperty(this,"blendMode",{get:()=>n,set:e=>{if(!e)throw new Error("BrushGL blendMode is required");n=e}}),Object.defineProperty(this,"particleSettings",{get:()=>({spacing:this.spacing,scattering:this.scattering,blendMode:this.blendMode,rotationMode:this.rotationMode}),enumerable:!0}),Object.defineProperty(this,"fillTextureSettings",{get:()=>({randomize:this.randomizeFill,size:this.fillTextureSize,offset:this.fillTextureOffset}),enumerable:!0}),Object.defineProperty(this,"descriptor",{value:{shape:void 0,fill:void 0},enumerable:!0}),Object.defineProperty(this,"shape",{get:()=>Array.isArray(this.descriptor.shape)?this.descriptor.shape.map((e=>e.value)):this.descriptor.shape.value,enumerable:!0}),Object.defineProperty(this,"fill",{get:()=>this.descriptor.fill.value,enumerable:!0}),this.updateShape(t),this.updateFill(r,s)}async updateShape(e){Array.isArray(e)?e=e.map((e=>"string"==typeof e?ne.getInstance(e):e instanceof ne?e:new ne(e.name,e.value))):"string"==typeof e?e=ne.getInstance(e):e instanceof ne||(e=new ne(e.name,e.value)),this.descriptor.shape=e,this.ctx&&await this.configureShape()}async updateFill(e,t={}){if(this.randomizeFill=!("randomize"in t)||t.randomize,this.fillTextureSize=t.size,this.fillTextureOffset=t.offset||{x:0,y:0},Array.isArray(e))throw new Error("Mipmap is not compatible whith fill texture");"string"==typeof e?e=ne.getInstance(e):e instanceof ne||(e=new ne(e.name,e.value)),this.descriptor.fill=e,this.ctx&&await this.configureFill()}async configure(e){this.ctx=e,await this.configureShape(),await this.configureFill()}async configureShape(){this.shapeTexture||(this.shapeTexture=_e.createInstance(this.ctx,this.ctx.CLAMP_TO_EDGE,this.ctx.LINEAR)),await this.shapeTexture.update(this.shape,this.spacing<=1)}async configureFill(){this.fillTexture||(this.fillTexture=_e.createInstance(this.ctx,this.ctx.REPEAT,this.ctx.NEAREST)),await this.fillTexture.update(this.fill),this.fillTextureSize||(this.fillTextureSize=this.fillTexture.size)}async getShapeBinary(){let e;if(Array.isArray(this.shape)){let t=[];for(let e of this.shape){let r=await ve(e);t.push(r)}e=t}else e=await ve(this.shape);return e}async getFillBinary(){return await ve(this.fill)}toJSON(){return{type:"BrushGL",name:this.name,shape:Array.isArray(this.descriptor.shape)?this.descriptor.shape.map((e=>e.toJSON())):this.descriptor.shape.toJSON(),fill:this.descriptor.fill.toJSON(),particleSettings:{spacing:this.spacing,scattering:this.scattering,blendMode:this.blendMode.name,rotationMode:this.rotationMode.name},fillTextureSettings:{randomize:this.randomizeFill,size:this.fillTextureSize,offset:this.fillTextureOffset}}}static fromJSON(e){e.particleSettings.blendMode=Ne[e.particleSettings.blendMode],e.particleSettings.rotationMode=Ye.RotationMode[e.particleSettings.rotationMode];let t=Array.isArray(e.shape)?e.shape.map((e=>ne.fromJSON(e))):ne.fromJSON(e.shape),r=ne.fromJSON(e.fill);return new Ye(e.name,t,r,e.particleSettings,e.fillTextureSettings)}equals(e){return e==this&&e.shapeTexture==this.shapeTexture&&e.fillTexture==this.fillTexture}delete(){this.deleteShape(),this.deleteFill()}deleteShape(){this.shapeTexture&&(this.ctx.deleteTexture(this.shapeTexture),delete this.shapeTexture)}deleteFill(){this.fillTexture&&(this.ctx.deleteTexture(this.fillTexture),delete this.fillTexture)}}Object.defineEnum(Ye,"RotationMode",["NONE","RANDOM","TRAJECTORY"]);class Xe extends Be{constructor(e){super(e),this.buffer=this.gl.createBuffer(),this.indexBuffer=this.gl.createBuffer()}init(){this.a_coordinates=this.gl.getAttribLocation(this.program,"a_coordinates"),this.a_xys=this.gl.getAttribLocation(this.program,"a_xys"),this.a_spriteRotation=this.gl.getAttribLocation(this.program,"a_spriteRotation"),this.a_spriteScaleAndOffset=this.gl.getAttribLocation(this.program,"a_spriteScaleAndOffset"),this.a_color=this.gl.getAttribLocation(this.program,"a_color"),this.a_velocity=this.gl.getAttribLocation(this.program,"a_velocity"),this.a_transformParams=this.gl.getAttribLocation(this.program,"a_transformParams"),this.u_projectionMatrix=this.gl.getUniformLocation(this.program,"u_projectionMatrix"),this.u_viewMatrix=this.gl.getUniformLocation(this.program,"u_viewMatrix"),this.u_fillTextureSize=this.gl.getUniformLocation(this.program,"u_fillTextureSize"),this.u_fillTextureOffset=this.gl.getUniformLocation(this.program,"u_fillTextureOffset"),this.u_shapeTexture=this.gl.getUniformLocation(this.program,"u_shapeTexture"),this.u_fillTexture=this.gl.getUniformLocation(this.program,"u_fillTexture")}setBrush(e){this.brush=e,this.brushChanged=!0}onActivate(){this.brushChanged=!0,this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.buffer),this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,this.indexBuffer);let e=19*Float32Array.BYTES_PER_ELEMENT;this.gl.vertexAttribPointer(this.a_coordinates,2,this.gl.FLOAT,!1,e,0*Float32Array.BYTES_PER_ELEMENT),this.gl.vertexAttribPointer(this.a_xys,3,this.gl.FLOAT,!1,e,2*Float32Array.BYTES_PER_ELEMENT),this.gl.vertexAttribPointer(this.a_spriteRotation,1,this.gl.FLOAT,!1,e,5*Float32Array.BYTES_PER_ELEMENT),this.gl.vertexAttribPointer(this.a_spriteScaleAndOffset,4,this.gl.FLOAT,!1,e,6*Float32Array.BYTES_PER_ELEMENT),this.gl.vertexAttribPointer(this.a_color,4,this.gl.FLOAT,!1,e,10*Float32Array.BYTES_PER_ELEMENT),this.gl.vertexAttribPointer(this.a_velocity,2,this.gl.FLOAT,!1,e,14*Float32Array.BYTES_PER_ELEMENT),this.gl.vertexAttribPointer(this.a_transformParams,3,this.gl.FLOAT,!1,e,16*Float32Array.BYTES_PER_ELEMENT),this.gl.enableVertexAttribArray(this.a_coordinates),this.gl.enableVertexAttribArray(this.a_xys),this.gl.enableVertexAttribArray(this.a_spriteRotation),this.gl.enableVertexAttribArray(this.a_spriteScaleAndOffset),this.gl.enableVertexAttribArray(this.a_color),this.gl.enableVertexAttribArray(this.a_velocity),this.gl.enableVertexAttribArray(this.a_transformParams)}onContextChange(){this.gl.uniformMatrix4fv(this.u_projectionMatrix,!1,this.inkGLContext.graphicsSpaceToFramebufferSpaceT),this.gl.uniformMatrix4fv(this.u_viewMatrix,!1,this.inkGLContext.transform?this.inkGLContext.transform.value:Me.IDENTITY_MATRIX)}onDeactivate(){this.gl.disableVertexAttribArray(this.a_coordinates),this.gl.disableVertexAttribArray(this.a_xys),this.gl.disableVertexAttribArray(this.a_spriteRotation),this.gl.disableVertexAttribArray(this.a_spriteScaleAndOffset),this.gl.disableVertexAttribArray(this.a_color),this.gl.disableVertexAttribArray(this.a_velocity),this.gl.disableVertexAttribArray(this.a_transformParams),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,null)}updateTextures(){this.brushChanged&&(this.brushChanged=!1,this.gl.uniform2f(this.u_fillTextureOffset,this.brush.fillTextureOffset.x,this.brush.fillTextureOffset.y),this.gl.uniform2f(this.u_fillTextureSize,this.brush.fillTextureSize.width,this.brush.fillTextureSize.height),this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D,this.brush.shapeTexture.value),this.gl.uniform1i(this.u_shapeTexture,0),this.gl.activeTexture(this.gl.TEXTURE1),this.gl.bindTexture(this.gl.TEXTURE_2D,this.brush.fillTexture.value),this.gl.uniform1i(this.u_fillTexture,1))}drawSprites(e){let t;this.activate(),this.updateTextures();let r=Math.ceil(e.length/Me.VERTEX_BATCH_SIZE);for(let i=0;i<r;i++){t=this.drawSpritesBatch(e,i).union(t)}return t}drawSpritesBatch(e,t){let r,i=t*Me.VERTEX_BATCH_SIZE,s=i+Me.VERTEX_BATCH_SIZE;s>e.length&&(s=i+e.length%Me.VERTEX_BATCH_SIZE);let n=s-i,o=new Float32Array(76*n),a=new Uint16Array(6*n),l=this.brush.rotationMode==Ye.RotationMode.TRAJECTORY?1:0,h=j.createInstance(e.layout);for(let t=i;t<s;t++){h.fill(t,e.points,e.layout,e.style);let s=76*(t-i);r=T.calculateBrushGLSegmentBounds(h,this.brush.scattering).union(r);let n=h.red/255*h.alpha,a=h.green/255*h.alpha,d=h.blue/255*h.alpha;0==h.dX&&0==h.dY&&(h.dX=2*this.inkGLContext.random()-1,h.dY=2*this.inkGLContext.random()-1);let c=this.brush.rotationMode==Ye.RotationMode.RANDOM?2*this.inkGLContext.random()*Math.PI:0,u=(2*this.inkGLContext.random()-1)*this.brush.scattering;T.SQURE.forEach(((e,t)=>{let r=s+19*t;o[r]=e.x,o[r+1]=e.y,o[r+2]=h.x,o[r+3]=h.y,o[r+4]=h.size,o[r+5]=h.rotation,o[r+6]=h.scaleX,o[r+7]=h.scaleY,o[r+8]=h.offsetX,o[r+9]=h.offsetY,o[r+10]=n,o[r+11]=a,o[r+12]=d,o[r+13]=h.alpha,o[r+14]=h.dX,o[r+15]=h.dY,o[r+16]=l,o[r+17]=c,o[r+18]=u}))}let d=0;for(let e=0;e<a.length;e+=6)a[e]=d,a[e+1]=d+1,a[e+2]=d+2,a[e+3]=d+2,a[e+4]=d+1,a[e+5]=d+3,d+=4;return this.gl.bufferData(this.gl.ARRAY_BUFFER,o,this.gl.STATIC_DRAW),this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,a,this.gl.STATIC_DRAW),this.inkGLContext.drawElements(this.gl.TRIANGLES,a.length,this.gl.UNSIGNED_SHORT,0),r}static getVertexShader(){return`\n\t\t\tprecision ${Me.VERTEX_SHADER_PRECISION} float;\n\n\t\t\tuniform mat4 u_projectionMatrix;\n\t\t\tuniform mat4 u_viewMatrix;\n\t\t\tuniform vec2 u_fillTextureSize;\n\t\t\tuniform vec2 u_fillTextureOffset;\n\n\t\t\tattribute lowp vec4 a_color;\n\t\t\t/* (x,y) is the center. z is the offset by x, w is the offset by y */\n\t\t\tattribute highp vec2 a_coordinates;\n\t\t\t/* the velocity at that point. It is the derivative of the function */\n\t\t\tattribute vec2 a_velocity;\n\t\t\t/* 1-shape trajectory rotation coficient, 2-shape randrom rotation angle, 3-scattering value */\n\t\t\tattribute vec3 a_transformParams;\n\n\t\t\t/* sprite rotation angle */\n\t\t\tattribute highp float a_spriteRotation;\n\t\t\t/* sprite's: 1-scaleX, 2-scaleY, 3-offsetX, 4-offsetY */\n\t\t\tattribute highp vec4 a_spriteScaleAndOffset;\n\n\t\t\tvarying lowp vec4 v_color;\n\t\t\tattribute vec3 a_xys;\n\t\t\tvarying highp vec2 v_shapeTexturePosition;\n\t\t\tvarying highp vec2 v_fillTexturePosition;\n\n\t\t\tmat2 trajectoryRotate(vec2 vNormal, float value) {\n\t\t\t\tvec2 base = vec2(1.0, 0.0);\n\n\t\t\t\tvec2 vNormalR = mix(base, vNormal, value);\n\t\t\t\tvNormalR = normalize(vNormalR);\n\n\t\t\t\tfloat cosfi = dot(vNormalR, base);\n\t\t\t\tfloat sinfi = vNormalR.x * base.y - vNormalR.y * base.x;\n\n\t\t\t\treturn mat2(\n\t\t\t\t\tcosfi, -sinfi,\n\t\t\t\t\tsinfi, cosfi\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tmat2 angleRotate2(float fi) {\n\t\t\t\tfloat sinfi = sin(fi);\n\t\t\t\tfloat cosfi = cos(fi);\n\n\t\t\t\treturn mat2(\n\t\t\t\t\tcosfi, -sinfi,\n\t\t\t\t\tsinfi, cosfi\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tmat2 scale2(float sx, float sy) {\n\t\t\t\treturn mat2(sx, 0.0, 0.0, sy);\n\t\t\t}\n\n\t\t\tmat3 rotate2h(float fi) {\n\t\t\t\tfloat sinfi = sin(fi);\n\t\t\t\tfloat cosfi = cos(fi);\n\n\t\t\t\treturn mat3(\n\t\t\t\t\tcosfi,  sinfi, 0.0,\n\t\t\t\t\t-sinfi, cosfi, 0.0,\n\t\t\t\t\t0.0,    0.0,   1.0\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tmat3 scale2h(float sx, float sy) {\n\t\t\t\treturn mat3(\n\t\t\t\t\tsx,  0.0, 0.0,\n\t\t\t\t\t0.0, sy,  0.0,\n\t\t\t\t\t0.0, 0.0, 1.0\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tmat3 translate2h(float tx, float ty) {\n\t\t\t\treturn mat3(\n\t\t\t\t\t1.0, 0.0, 0.0,\n\t\t\t\t\t0.0, 1.0, 0.0,\n\t\t\t\t\ttx,  ty,  1.0\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tvec2 orthoOffset(vec2 vNormal, float value) {\n\t\t\t\tvec2 vno = vec2(vNormal.y * value, vNormal.x * value);\n\t\t\t\treturn vno;\n\t\t\t}\n\n\t\t\tvoid main() {\n\t\t\t\t// Calculate radius from size\n\t\t\t\tfloat halfSize = a_xys.z / 2.0;\n\n\t\t\t\tvec2 vNormal = normalize(a_velocity);\n\n\t\t\t\t// Because this applied to the texture, the y reversed because the texture coordinate system y is increasing downwards.\n\t\t\t\tvNormal.y = -vNormal.y;\n\n\t\t\t\tfloat spriteRotation = a_spriteRotation;\n\t\t\t\tvec4 spriteScaleAndOffset = a_spriteScaleAndOffset;\n\t\t\t\tspriteScaleAndOffset.y = -spriteScaleAndOffset.y;\n\t\t\t\tspriteScaleAndOffset.w = -spriteScaleAndOffset.w;\n\n\t\t\t\tmat2 productRotateMatrix = angleRotate2(a_transformParams.y) * trajectoryRotate(vNormal, a_transformParams.x);\n\t\t\t\tvec2 scatterOffset = orthoOffset(vNormal, a_transformParams.z * halfSize);\n\t\t\t\tvec2 transformedCoordinates = productRotateMatrix * a_coordinates;\n\n\t\t\t\tvec3 coordinatesH = vec3(transformedCoordinates.x, transformedCoordinates.y, 1.0);\n\t\t\t\tcoordinatesH = rotate2h(spriteRotation) * translate2h(spriteScaleAndOffset.z, spriteScaleAndOffset.w) * scale2h(spriteScaleAndOffset.x * halfSize, spriteScaleAndOffset.y * halfSize) * coordinatesH;\n\t\t\t\tvec2 coordinates = coordinatesH.xy;\n\n\t\t\t\tvec2 offset = coordinates + scatterOffset;\n\t\t\t\tvec4 position = vec4(a_xys.x + offset.x, a_xys.y + offset.y, 0.0, 1.0);\n\n\t\t\t\tv_color = a_color;\n\n\t\t\t\tvec4 viewPosition = u_viewMatrix * position;\n\t\t\t\tgl_Position = u_projectionMatrix * viewPosition;\n\t\t\t\tv_fillTexturePosition = position.xy / u_fillTextureSize + u_fillTextureOffset;\n\t\t\t\tv_shapeTexturePosition = (a_coordinates + 1.0) * 0.5; /* [-1;1] -> [0;1] */\n\t\t\t}\n\t\t`}static getFragmentShader(e){return`\n\t\t\tuniform lowp sampler2D u_shapeTexture;\n\t\t\tuniform lowp sampler2D u_fillTexture;\n\n\t\t\t/* lowp seems to lead to an overflow on PowerVR SGX540, so use mediump instead :)*/\n\t\t\tvarying mediump vec4 v_color;\n\t\t\tvarying highp vec2 v_shapeTexturePosition;\n\t\t\tvarying highp vec2 v_fillTexturePosition;\n\n\t\t\tvoid main() {\n\t\t\t\tlowp vec4 c = v_color * texture2D(u_shapeTexture, v_shapeTexturePosition) * texture2D(u_fillTexture, v_fillTexturePosition);\n\n\t\t\t\tgl_FragColor = ${e?"c":"vec4(c.x / c.w, c.y / c.w, c.z / c.w, c.w * 255.0)"};\n\t\t\t}\n\t\t`}}class ze{constructor(e,t){let r=e.getContext("webgl2",t)||e.getContext("webgl",t);if(this.debug){let e=new Proxy(r,{get:function(e,t,r){let i;return i="function"==typeof e[t]?Reflect.get(...arguments):e[t],"getError"!=t&&Me.logGLError(e,t),i}});Object.getOwnPropertyNames(r.constructor.prototype).forEach((t=>{let i=r[t];"function"==typeof i&&(e[t]=i.bind(r))})),r=e}this.gl=r,this.glVersion=r.drawArraysInstanced?2:1,this.inkGLContext=new Me(r);const i=r.drawArraysInstanced?Ge:Ue;this.simpleProgram=new i(this.inkGLContext),this.textureProgram=new $e(this.inkGLContext),this.spriteProgram=new Xe(this.inkGLContext),this.inkGLContext.programs=[this.simpleProgram,this.textureProgram,this.spriteProgram],this.currentTarget=null,this.inkGLContext.init(new T(0,0,0,0),new T(0,0,0,0))}createLayer(e,t){return new Fe(this.inkGLContext,e,t)}drawLayerWithTransform(e,t,r){if(!this.currentTarget)return;let i=e.graphicsBounds.toQuad(),s=e.graphicsBounds.toQuad(t);this.drawLayer(e,i,s,r)}drawLayer(e,t,i,s){if(!this.currentTarget)return;if(!e.useTextureStorage)return;let n=r.mat4.create(),o=r.mat4.create(),a=this.currentTarget;a.flipY?r.mat4.ortho(o,0,a.width,a.height,0,1,-1):r.mat4.ortho(o,0,a.width,0,a.height,1,-1),e.flipY?r.mat4.ortho(n,-e.width,e.width,2*e.height,0,0,1):r.mat4.ortho(n,-e.width,e.width,-e.height,e.height,0,1),this.inkGLContext.blendMode=s,this.textureProgram.drawTexture(e.texture,i,t,o,n)}setTarget(e,t){if(e&&!(e instanceof Fe))throw new TypeError("layer must be unset or instanceof InkLayer");if(t&&!(t instanceof T))throw new TypeError("clipRect must be unset or instanceof RectGL");if(e){this.currentTarget=e;let r=new T(0,0,e.storageWidth,e.storageHeight),i=new T(0,0,e.width,e.height);this.inkGLContext.resize(r,i),this.inkGLContext.setUniforms(e.flipY),t?this.setTargetClipRect(t):this.disableTargetClipRect(),this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,e.framebuffer)}}clearColor(e){this.inkGLContext.clearColorBuffer(e)}setTargetClipRect(e){if(e=e.floor().intersect(this.currentTarget.graphicsBounds),this.currentTarget.flipY)e=new T(e.x,this.currentTarget.storageHeight-e.top,e.width,e.height);else{let t=this.currentTarget.scaleFactor;e=new T(e.x*t,e.y*t,e.width*t,e.height*t)}this.inkGLContext.clipRect=e,this.inkGLContext.scissors(e)}disableTargetClipRect(){let e=this.inkGLContext;e.scissors(null),e.clipRect=e.graphicsBox}drawStroke(e,t,r){return this.currentTarget?0==t.length?null:(this.inkGLContext.blendMaxFallback&&e.blendMode==Ne.MAX&&this.inkGLContext.enableStencilBufferForBlending(this.currentTarget),this.inkGLContext.transform=this.currentTarget.matrix,e instanceof Ye?this.drawGL(e,t,r):this.draw2D(e,t,r)):null}drawGL(e,t,r){let i;r&&(i=this.inkGLContext.scatterMethodRandomSeed,this.inkGLContext.scatterMethodRandomSeed=r.randomSeed),this.spriteProgram.setBrush(e),this.inkGLContext.blendMode=e.blendMode;let s=this.spriteProgram.drawSprites(t);return r&&(r.randomSeed=this.inkGLContext.scatterMethodRandomSeed,this.inkGLContext.scatterMethodRandomSeed=i),this.clipDirtyArea(s)}draw2D(e,t,r){return this.fill(t,r,!0,t.segment)}fill(e,t,r=!0,i=!1){let s=this.clipDirtyArea(e.bounds.toGLRect());if(s){let n=e.vertices;n.length>0?this.simpleProgram.drawVertices(this.currentTarget.framebuffer,n,t,r,i):s=void 0}return s}clipDirtyArea(e){let t=e,r=this.inkGLContext.clipRect;return this.inkGLContext.transform&&(t=t.transform(this.inkGLContext.transform)),t=r.intersect(t),t&&(t=t.ceil(),1==this.glVersion&&(t=T.ofEdges(t.left-1,t.bottom-1,t.right+1,t.top+1))),t}readPixels(e){let t=this.currentTarget;if(e){if(!(e instanceof T))throw new TypeError("box must be instance of RectGL")}else e=t.graphicsBounds;t.flipY&&(e=new T(e.x,t.height-e.y-e.height,e.width,e.height)),this.setTarget(t);let r=new Uint8Array(e.width*e.height*4);return this.gl.readPixels(parseInt(e.x*t.scaleFactor),parseInt(e.y*t.scaleFactor),parseInt(e.width*t.scaleFactor),parseInt(e.height*t.scaleFactor),this.gl.RGBA,this.gl.UNSIGNED_BYTE,r),r}writePixels(e,t){if(e&&!(e instanceof T))throw new TypeError("rect must be instance of RectGL");let r=this.currentTarget;if(e||(e=new T(0,0,r.width,r.height)),!r.useTextureStorage)throw new Error("writePixels layer without texture is not supported!");{r.flipY&&(e=new T(e.x,r.height-e.y-e.height,e.width,e.height));let i=new T(e.x*r.scaleFactor,e.y*r.scaleFactor,e.width*r.scaleFactor,e.height*r.scaleFactor);this.gl.finish(),this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D,r.texture),this.gl.texSubImage2D(this.gl.TEXTURE_2D,0,parseInt(i.x),parseInt(i.y),parseInt(i.width),parseInt(i.height),this.gl.RGBA,this.gl.UNSIGNED_BYTE,t)}}}let Ve=p?p.default||globalThis.ClipperLib:{};const{Clipper:He,Paths:Ze,Path:qe,ClipType:We,PolyType:Ke,PolyFillType:Je}=Ve;class Qe extends Array{static get[Symbol.species](){return Array}constructor(...e){if(super(...e),e.some((e=>!(e instanceof xe))))throw new Error("Expected data item type is Polygon");Object.defineProperty(this,"bounds",{get:()=>{let e;return this.length>0&&(this.forEach((t=>e=t.bounds.union(e))),e=e.ceil()),e},enumerable:!0}),Object.defineProperty(this,"vertices",{get:()=>this.triangulate(),enumerable:!0})}clone(){return new this.constructor(...this.map((e=>e.clone())))}push(...e){if(e.some((e=>!(e instanceof xe))))throw new Error("Expected data item type is Polygon");super.push(...e)}triangulate(){return Float32Array.createSharedInstance().concat(...this.map((e=>e.vertices)))}transform(e){this.forEach((t=>t.transform(e)))}toJSON(){return{type:"PolygonArray",polygons:this.map((e=>e.toJSON()))}}static fromJSON(e){if("PolygonArray"!=e.type)throw new Error(`PolygonArray deserialization failed. JSON type is ${e.type}, expected PolygonArray.`);return new Qe(...e.polygons.map((e=>xe.fromJSON(e))))}}class et extends Qe{constructor(...e){let t;super(...e),Object.defineProperty(this,"encoding",{get:()=>t,set:e=>{t=e,this.forEach((t=>t.encoding=e))},enumerable:!0})}intersects(e){e instanceof xe&&(e=[e]);for(let t of this)for(let r of e)if(t.intersects(r))return{poly1:t,poly2:r};return null}toJSON(){let e=super.toJSON();return e.type="InkPath2D",e}static fromJSON(e){if("InkPath2D"!=e.type)throw new Error(`InkPath2D deserialization failed. JSON type is ${e.type}, expected InkPath2D.`);return new et(...e.polygons.map((e=>xe.fromJSON(e))))}}class tt{constructor(e){if(e instanceof xe&&(e=new et(e)),!(e instanceof et))throw new Error("Unexpected path type found");let t=e.bounds,r=65534/(t.width+1e-16),i=65534/(t.height+1e-16),s=Math.floor(Math.min(r,i)),n=t.left+32767/s,o=t.top+32767/s;this.solution=new Ze,this.bounds=t,this.transform={scale:s,offsetX:n,offsetY:o},this.subject=this.apply(e)}convertPoint(e){let t=(e.x-this.transform.offsetX)*this.transform.scale,r=(e.y-this.transform.offsetY)*this.transform.scale;return{X:t<0?Math.ceil(t):Math.floor(t),Y:r<0?Math.ceil(r):Math.floor(r)}}containsPoint(e){return He.PointInPolygon(this.convertPoint(e),this.solution)}apply(e){let t=new Ze;if(e instanceof xe&&(e=new et(e)),!(e instanceof et))throw new Error("Unexpected path type found");for(let r of e){let e=new qe,i=r.shape;for(let t=0;t<i.length;t++)e.push(this.convertPoint({x:i.getPointX(t),y:i.getPointY(t)}));t.push(e)}return t}toPolygon(){let e=[];this.lastPoint={};for(let t of this.solution)0!=t.length&&e.push(this.flatPath(t));return xe.createSharedInstance(e.first,e.slice(1))}flatPath(e){let t=[];for(let r of e)this.lastPoint.X!=r.X||this.lastPoint.Y!=r.Y?(t.push(r.X/this.transform.scale+this.transform.offsetX,r.Y/this.transform.scale+this.transform.offsetY),this.lastPoint=r):console.warn(`Duplicate point detected: {${r.X}, ${r.Y}}`);return t.length<6&&(console.warn(`Invalid contour found: [${t.join(", ")}]`),t.clear()),t}}let rt={palettes:{}};const it=["AliceBlue","#F0F8FF","AntiqueWhite","#FAEBD7","Aqua","#00FFFF","Aquamarine","#7FFFD4","Azure","#F0FFFF","Beige","#F5F5DC","Bisque","#FFE4C4","Black","#000000","BlanchedAlmond","#FFEBCD","Blue","#0000FF","BlueViolet","#8A2BE2","Brown","#A52A2A","BurlyWood","#DEB887","CadetBlue","#5F9EA0","Chartreuse","#7FFF00","Chocolate","#D2691E","Coral","#FF7F50","CornflowerBlue","#6495ED","Cornsilk","#FFF8DC","Crimson","#DC143C","Cyan","#00FFFF","DarkBlue","#00008B","DarkCyan","#008B8B","DarkGoldenRod","#B8860B","DarkGray","#A9A9A9","DarkGreen","#006400","DarkKhaki","#BDB76B","DarkMagenta","#8B008B","DarkOliveGreen","#556B2F","DarkOrange","#FF8C00","DarkOrchid","#9932CC","DarkRed","#8B0000","DarkSalmon","#E9967A","DarkSeaGreen","#8FBC8F","DarkSlateBlue","#483D8B","DarkSlateGray","#2F4F4F","DarkTurquoise","#00CED1","DarkViolet","#9400D3","DeepPink","#FF1493","DeepSkyBlue","#00BFFF","DimGray","#696969","DodgerBlue","#1E90FF","FireBrick","#B22222","FloralWhite","#FFFAF0","ForestGreen","#228B22","Fuchsia","#FF00FF","Gainsboro","#DCDCDC","GhostWhite","#F8F8FF","Gold","#FFD700","GoldenRod","#DAA520","Gray","#808080","Green","#008000","GreenYellow","#ADFF2F","HoneyDew","#F0FFF0","HotPink","#FF69B4","IndianRed","#CD5C5C","Indigo","#4B0082","Ivory","#FFFFF0","Khaki","#F0E68C","Lavender","#E6E6FA","LavenderBlush","#FFF0F5","LawnGreen","#7CFC00","LemonChiffon","#FFFACD","LightBlue","#ADD8E6","LightCoral","#F08080","LightCyan","#E0FFFF","LightGoldenRodYellow","#FAFAD2","LightGray","#D3D3D3","LightGreen","#90EE90","LightPink","#FFB6C1","LightSalmon","#FFA07A","LightSeaGreen","#20B2AA","LightSkyBlue","#87CEFA","LightSlateGray","#778899","LightSteelBlue","#B0C4DE","LightYellow","#FFFFE0","Lime","#00FF00","LimeGreen","#32CD32","Linen","#FAF0E6","Magenta","#FF00FF","Maroon","#800000","MediumAquaMarine","#66CDAA","MediumBlue","#0000CD","MediumOrchid","#BA55D3","MediumPurple","#9370DB","MediumSeaGreen","#3CB371","MediumSlateBlue","#7B68EE","MediumSpringGreen","#00FA9A","MediumTurquoise","#48D1CC","MediumVioletRed","#C71585","MidnightBlue","#191970","MintCream","#F5FFFA","MistyRose","#FFE4E1","Moccasin","#FFE4B5","NavajoWhite","#FFDEAD","Navy","#000080","OldLace","#FDF5E6","Olive","#808000","OliveDrab","#6B8E23","Orange","#FFA500","OrangeRed","#FF4500","Orchid","#DA70D6","PaleGoldenRod","#EEE8AA","PaleGreen","#98FB98","PaleTurquoise","#AFEEEE","PaleVioletRed","#DB7093","PapayaWhip","#FFEFD5","PeachPuff","#FFDAB9","Peru","#CD853F","Pink","#FFC0CB","Plum","#DDA0DD","PowderBlue","#B0E0E6","Purple","#800080","RebeccaPurple","#663399","Red","#FF0000","RosyBrown","#BC8F8F","RoyalBlue","#4169E1","SaddleBrown","#8B4513","Salmon","#FA8072","SandyBrown","#F4A460","SeaGreen","#2E8B57","SeaShell","#FFF5EE","Sienna","#A0522D","Silver","#C0C0C0","SkyBlue","#87CEEB","SlateBlue","#6A5ACD","SlateGray","#708090","Snow","#FFFAFA","SpringGreen","#00FF7F","SteelBlue","#4682B4","Tan","#D2B48C","Teal","#008080","Thistle","#D8BFD8","Tomato","#FF6347","Turquoise","#40E0D0","Violet","#EE82EE","Wheat","#F5DEB3","White","#FFFFFF","WhiteSmoke","#F5F5F5","Yellow","#FFFF00","YellowGreen","#9ACD32"],st={red:["LightSalmon","Salmon","DarkSalmon","LightCoral","IndianRed","Crimson","FireBrick","Red","DarkRed"],orange:["Coral","Tomato","OrangeRed","Gold","Orange","DarkOrange"],yellow:["LightYellow","LemonChiffon","LightGoldenRodYellow","PapayaWhip","Moccasin","PeachPuff","PaleGoldenRod","Khaki","DarkKhaki","Yellow"],green:["LawnGreen","Chartreuse","LimeGreen","Lime","ForestGreen","Green","DarkGreen","GreenYellow","YellowGreen","SpringGreen","MediumSpringGreen","LightGreen","PaleGreen","DarkSeaGreen","MediumSeaGreen","SeaGreen","Olive","DarkOliveGreen","OliveDrab"],cyan:["LightCyan","Cyan","Aqua","Aquamarine","MediumAquaMarine","PaleTurquoise","Turquoise","MediumTurquoise","DarkTurquoise","LightSeaGreen","CadetBlue","DarkCyan","Teal"],blue:["PowderBlue","LightBlue","LightSkyBlue","SkyBlue","DeepSkyBlue","LightSteelBlue","DodgerBlue","CornflowerBlue","SteelBlue","RoyalBlue","Blue","MediumBlue","DarkBlue","Navy","MidnightBlue","MediumSlateBlue","SlateBlue","DarkSlateBlue"],purple:["Lavender","Thistle","Plum","Violet","Orchid","Fuchsia","Magenta","MediumOrchid","MediumPurple","BlueViolet","DarkViolet","DarkOrchid","DarkMagenta","Purple","RebeccaPurple","Indigo"],pink:["Pink","LightPink","HotPink","DeepPink","PaleVioletRed","MediumVioletRed"],white:["White","Snow","HoneyDew","MintCream","Azure","AliceBlue","GhostWhite","WhiteSmoke","SeaShell","Beige","OldLace","FloralWhite","Ivory","AntiqueWhite","Linen","LavenderBlush","MistyRose"],gray:["Gainsboro","LightGray","Silver","DarkGray","Gray","DimGray","LightSlateGray","SlateGray","DarkSlateGray","Black"],brown:["Cornsilk","BlanchedAlmond","Bisque","NavajoWhite","Wheat","BurlyWood","Tan","RosyBrown","SandyBrown","GoldenRod","Peru","DarkGoldenRod","Chocolate","SaddleBrown","Sienna","Brown","Maroon"]};let nt={};function ot(e,t){return nt[e]||(nt[e]=ce.fromColor(t)),nt[e]}for(let e=0;e<it.length;e+=2){let t=L.getEnumValueName(it[e]);Object.defineProperty(rt,t,{get:()=>ot(t,it[e+1]),enumerable:!0})}for(let e in st){let t=st[e];rt.palettes[e]={scale:t};for(let r=0;r<t.length;r++){let i=L.getEnumValueName(t[r]);Object.defineProperty(rt.palettes[e],i,{get:()=>rt[i],enumerable:!0})}}class at{constructor(e){Object.defineProperty(this,"ctx",{value:e,enumerable:!0})}clearCanvas(){this.ctx.clearRect(0,0,this.ctx.canvas.width,this.ctx.canvas.height)}setTransform(e){this.ctx.setTransform(e.a,e.b,e.c,e.d,e.tx,e.ty)}drawRect(e,t=rt.GRAY.toRGBA(.3)){this.ctx.strokeStyle=t.toString(),this.ctx.strokeRect(e.left,e.top,e.width,e.height)}fillRect(e,t=rt.GRAY.toRGBA(.3)){this.ctx.fillStyle=t.toString(),this.ctx.fillRect(e.left,e.top,e.width,e.height)}drawPoint(e,t=5,r=rt.BLACK){this.ctx.beginPath(),this.ctx.arc(e.x,e.y,t,0,2*Math.PI),this.renderStyle({type:"stroke",style:r})}fillPoint(e,t=5,r=rt.BLACK){this.ctx.beginPath(),this.ctx.arc(e.x,e.y,t,0,2*Math.PI),this.renderStyle({type:"fill",style:r})}drawEllipse(e,t,r,i=rt.BLACK){this.ctx.beginPath(),this.ctx.ellipse(e.x,e.y,t,r,0,0,2*Math.PI),this.renderStyle({type:"stroke",style:i})}fillEllipse(e,t,r,i=rt.BLACK){this.ctx.beginPath(),this.ctx.ellipse(e.x,e.y,t,r,0,0,2*Math.PI),this.renderStyle({type:"fill",style:i})}drawShape(e,t=rt.DARK_MAGENTA.toRGBA(.5)){this.renderShape(e,{type:"stroke",style:t})}fillShape(e,t=rt.ORANGE.toRGBA(.6)){this.renderShape(e,{type:"fill",style:t})}renderShape(e,t={}){if(e instanceof fe)this.ctx.beginPath(),this.renderPath(e);else if(e instanceof xe)this.renderPolygon(e);else{if(!(e instanceof Qe))throw new Error("Unexpected shape type found");this.ctx.beginPath();for(let t of e)this.renderPolygon(t,{segment:!0})}this.renderStyle(t)}renderPolygon(e,t={}){t.segment||this.ctx.beginPath(),this.renderPath(e.shape,!0),e.holes.forEach((e=>this.renderPath(e,{holesDirection:xe.PointsDirection.CLOCKWISE}))),t.segment||this.renderStyle(t)}renderPath(e,t={}){if(!t.holesDirection||t.holesDirection==xe.PointsDirection.CLOCKWISE){this.ctx.moveTo(e.getPointX(0),e.getPointY(0));for(let t=1;t<e.length;t++)this.ctx.lineTo(e.getPointX(t),e.getPointY(t))}else{this.ctx.moveTo(e.getPointX(e.length-1),e.getPointY(e.length-1));for(let t=e.length-2;t>=0;t--)this.ctx.lineTo(e.getPointX(t),e.getPointY(t))}this.ctx.closePath(),this.renderStyle(t)}renderStyle(e){if(e.type){if("fill"!=e.type&&"stroke"!=e.type)throw new Error("Option type should be oneof(stroke, fill)");e.style&&(this.ctx[`${e.type}Style`]=e.style instanceof ce?e.style.toString():e.style),this.ctx[e.type]()}}}class lt extends ye{constructor(e,t,r,i=0,s=1){super(t,r,e),this.ts=i,this.tf=s,Object.defineProperty(this,"segmentsCount",{value:this.length-3,configurable:!0}),Object.defineProperty(this,"bounds",{get:()=>v.ofSpline(this,this.pointProps.scattering).ceil(),enumerable:!0}),Object.defineProperty(this,"color",{get:()=>ce.isColor(this.pointProps)?ce.fromColor(this.pointProps):void 0,set:e=>{if(!e)throw new Error("Spline color cannot be removed");if(!(e instanceof ce))throw new Error("Expected value should be Color instance");"red"in this.pointProps&&(this.pointProps.red=e.red),"green"in this.pointProps&&(this.pointProps.green=e.green),"blue"in this.pointProps&&(this.pointProps.blue=e.blue),"alpha"in this.pointProps&&(this.pointProps.alpha=e.alpha)},enumerable:!0}),this.validate()}validate(){if(!this.layout.includes(j.Property.X))throw new Error("Layout doesn't contains required properties X");if(!this.layout.includes(j.Property.Y))throw new Error("Layout doesn't contains required properties Y");if(0==this.points.length)throw new Error("Empty spline is not allowed");if(this.points.length%this.stride!=0)throw new Error("Path length doesn't match the stride provided via the layout");if(this.ts<0||this.ts>=1)throw new Error(`Invalid spline ts ${this.ts} found. The value must be in the interval [0, 1).`);if(this.tf<=0||this.tf>1)throw new Error(`Invalid spline tf ${this.tf} found. The value must be in the interval (0, 1].`);if(1==this.segmentsCount&&this.ts>this.tf)throw new Error(`Invalid spline t range ${this.ts} - ${this.tf} found. Spline has only one segment and ts <= tf.`);if(this.segmentsCount<1)throw new Error("Incompleted spline found. Spline is defined with at least 4 control points.")}clone(){return new lt(this.layout.slice(),this.points.clone(),Object.clone(this.pointProps),this.ts,this.tf)}getSegment(e){let t=e,r=e+3,i=0==t?this.ts:0,s=r+1==this.length?this.tf:1;return this.slice({fromPointIndex:t,toPointIndex:r,fromTValue:i,toTValue:s})}slice(e){let t=this.slicePoints(e.fromPointIndex,e.toPointIndex,e.fromTValue,e.toTValue),r=new lt(this.layout.slice(),t,Object.clone(this.pointProps),e.fromTValue,e.toTValue);return r.id=e.id,r}toPlainPath(){let e=[];for(let t=0;t<this.length;t++)e.push(this.getPointX(),this.getPointY());return new ge(e)}toJSON(){return{type:"Spline",id:this.id,layout:this.layout.map((e=>e.name)),points:se.encode(this.points,this.encoding),pointProps:this.pointProps,ts:this.ts,tf:this.tf}}static fromJSON(e){let t=se.decode(e.points),r=new lt(e.layout.map((e=>j.Property[e])),t,e.pointProps,e.ts,e.tf);return r.id=e.id,r}static fromRect(e,t){let r=[e.left,e.top,e.left,e.top,e.right,e.top,e.right,e.bottom,e.left,e.bottom,e.left,e.top,e.left,e.top];return new lt(void 0,r,t)}}class ht extends ye{constructor(e,t,r,i=[]){super(t,r,e),i.length>0&&!Object.isFrozen(i.first)&&i.forEach((e=>Object.freeze(e))),Object.defineProperty(this,"splineParameters",{value:Object.freeze(i),enumerable:!0});let s=new ue(e,r);Object.defineProperty(this,"style",{get:()=>s.style,set:e=>s.style.reset(e),enumerable:!0}),Object.defineProperty(this,"color",{get:()=>this.style.color,set:e=>{if(!e)throw new Error("Spline color cannot be removed");if(!(e instanceof ce))throw new Error("Expected value should be Color instance");"red"in this.pointProps&&(this.pointProps.red=e.red),"green"in this.pointProps&&(this.pointProps.green=e.green),"blue"in this.pointProps&&(this.pointProps.blue=e.blue),"alpha"in this.pointProps&&(this.pointProps.alpha=e.alpha)},enumerable:!0}),Object.defineProperty(this,"bounds",{get:()=>v.ofSpline(this,this.pointProps.scattering).ceil(),enumerable:!0}),this.validate()}validate(){if(!this.layout.includes(j.Property.X))throw new Error("Layout doesn't contains required properties X");if(!this.layout.includes(j.Property.Y))throw new Error("Layout doesn't contains required properties Y");if(0==this.points.length)throw new Error("Empty spline is not allowed");if(this.points.length%this.stride!=0)throw new Error("Path length doesn't match the stride provided via the layout")}clone(){return new ht(this.layout.slice(),this.points.clone(),Object.clone(this.pointProps),this.splineParameters.slice())}getPoint(e){return super.getPoint(e,this.style)}getPointSegmentIndex(e){return this.splineParameters[e]?this.splineParameters[e].index:void 0}getPointT(e){return this.splineParameters[e]?this.splineParameters[e].t:void 0}getPointParameter(e){return this.splineParameters[e]}toJSON(){return{type:"InterpolatedSpline",layout:this.layout.map((e=>e.name)),points:se.encode(this.points,this.encoding),pointProps:this.pointProps,splineParameters:this.splineParameters}}static fromJSON(e){let t=se.decode(e.points);return new ht(e.layout.map((e=>j.Property[e])),t,e.pointProps,e.splineParameters)}static fromRect(e,t){throw new Error("InterpolatedSpline.fromRect is not supported. Try Spline.fromRect and interpolate with particular Spline interpolator.")}}const dt=r.mat4.fromValues(0,-.5,1,-.5,1,0,-2.5,1.5,0,.5,2,-1.5,0,0,-.5,.5);class ct extends De{constructor(e=!1,t=!1){super(),this.calculateDerivates=e,this.keepSplineParameters=t,this.state={lastPointPosition:void 0,lastPointSize:0}}initState(e){this.state.layout={},e.layout.forEach(((e,t)=>{this.state.layout[e.name]={index:t,polynomials:r.vec4.create()}})),this.keepSplineParameters&&(this.state.splineParameters=[]),this.splineLayout=e.layout,this.pathPointProps=Object.clone(e.pointProps),this.scattering&&(this.pathPointProps.scattering=this.scattering),this.layout=this.calculateDerivates?e.layout.concat([j.Property.D_X,j.Property.D_Y]):e.layout,this.state.ready=!0}predict(e){if(!e)return[];this.state.ready||this.initState(e);let t=Object.clone(this.state);delete this.state.splineParameters,this.resetState();let r=this.discretize(e);return this.state=t,r}buildImpl(e){return e?(this.state.ready||this.initState(e),this.discretize(e)):[]}getOutput(e,t){if(0!=e.length){let r=t==ct.OutputType.ALL_DATA?void 0:this.state.splineParameters;return r&&(r=r.slice()),new ht(this.layout,e,this.pathPointProps,r)}}discretize(e){throw new Error("This method is abstract and should be implemented")}storeLastPoint(e,t=0){this.state.lastPointPosition=new w(this.getPropValue(j.Property.X,e,t),this.getPropValue(j.Property.Y,e,t),this.getPropValue(j.Property.Z,e,t)),this.state.lastPointSize=this.getPropValue(j.Property.SIZE,e,t)}getPropValue(e,t,r=0){return this.state.layout[e.name]?t[r+this.state.layout[e.name].index]:void 0}calculatePolynomials(e,t){let i=e.points,s=this.splineLayout.length*(t+0),n=this.splineLayout.length*(t+1),o=this.splineLayout.length*(t+2),a=this.splineLayout.length*(t+3);this.splineLayout.forEach(((e,t)=>{let l=r.vec4.fromValues(i[s+t],i[n+t],i[o+t],i[a+t]);r.vec4.transformMat4(this.state.layout[e.name].polynomials,l,dt)}))}calculateInterpolatedPoint(e,t,i){this.initState(e);let s=new j(0,0,this.splineLayout.includes(j.Property.Z)?0:void 0),n=r.vec4.fromValues(1,i,i*i,i*i*i);return this.calculatePolynomials(e,t),this.splineLayout.forEach((e=>{let t=r.vec4.dot(this.state.layout[e.name].polynomials,n);s[L.getPropName(e.name)]=t})),s}samplePoint(e){let t=[],i=r.vec4.fromValues(1,e,e*e,e*e*e);return this.splineLayout.forEach((e=>{let s=r.vec4.dot(this.state.layout[e.name].polynomials,i);t.push(s)})),this.calculateDerivates&&(t.push(this.getDerivativeOf(this.state.layout.X.polynomials,i)),t.push(this.getDerivativeOf(this.state.layout.Y.polynomials,i))),t}getDerivativeOf(e,t){let i=r.vec4.fromValues(e[1],2*e[2],3*e[3],0);return r.vec4.dot(i,t)}static defineParameter(e,t){return e>0&&0==t?{index:e-1,t:1}:{index:e,t:t}}keepSegmentT(e,t){this.state.splineParameters&&this.state.splineParameters.push(ct.defineParameter(e,t))}resetState(){}reset(){super.reset(),this.state.ready=!1,this.state.lastPointPosition=void 0,this.state.lastPointSize=0,delete this.state.splineParameters}}class ut extends ct{constructor(e=.1,t,r){super(t,r),this.spacing=e}split(e,t=8){let r=this.spacing;this.spacing=1,this.splitCount=t;let i=this.build(e);return this.spacing=r,delete this.splitCount,i}discretize(e){let t=[],i=this.splitCount,s=Math.max(1,10*(this.spacing>1?1:this.spacing));for(let n=0;n<e.segmentsCount;n++){if(this.calculatePolynomials(e,n),isNaN(this.splitCount)){let t=e.getPoint(n+1),o=e.getPoint(n+2),a=r.vec2.distance(t.value,o.value),l=this.pathPointProps.size;this.state.layout.SIZE&&(l=Math.min(t.size,o.size)),i=Math.floor(s*(a/l)/this.spacing)+1}let o=1/i;for(let r=0;r<=i;r++){let s=!this.state.lastPointPosition,a=r/i;if(0==n&&a<e.ts){if(!(a+o>=e.ts))continue;a=e.ts,s=this.spacing<=1}if(n==e.segmentsCount-1&&a>=e.tf){if(!(a<e.tf+o))continue;a=e.tf,s=this.lastSegment&&this.spacing<=1}if(n>0&&0==a)continue;let l=this.samplePoint(a);if(!s&&this.state.lastPointPosition){let e=new w(this.getPropValue(j.Property.X,l),this.getPropValue(j.Property.Y,l),this.getPropValue(j.Property.Z,l)),t=this.state.lastPointPosition.vec.squaredDistance(this.state.lastPointPosition.value,e.value),r=(this.state.layout.SIZE?(this.state.lastPointSize+l[this.state.layout.SIZE.index])/2:this.pathPointProps.size)*this.spacing;s=t>=r*r}s&&(t.push(...l),this.storeLastPoint(l),this.keepSegmentT(n,a))}}return this.state.splineParameters&&(0!=t.length&&this.state.splineParameters.first.t==e.ts||(t.unshift(...this.samplePoint(e.ts)),this.state.splineParameters.unshift(ct.defineParameter(0,e.ts))),this.state.splineParameters.last.t!=e.tf&&(t.push(...this.samplePoint(e.tf)),this.state.splineParameters.push(ct.defineParameter(e.segmentsCount-1,e.tf)))),t}}class pt{constructor(){this.interpolator=new ut(.1,!1,!0)}build(e,t,r){this.context=e,this.path=r,this.holesPerStroke={},this.strokeHoles=[],t.sort(L.comparator({sortBy:"strokeID",sortOrder:"asc"},{sortBy:"segmentIndex",sortOrder:"asc"},{sortBy:"splineIndex",sortOrder:"asc"},{sortBy:"pointIndex",sortOrder:"asc"})),this.debug&&(this.table=new _([{name:"strokeID",title:"Stroke ID"},{name:"segmentIndex",title:"Segment Index"},{name:"splineIndex",title:"Spline Index"},{name:"pointIndex",title:"Point Index"},{name:"prevT",title:"Prev T"},{name:"t",title:"T Value"},{name:"nextT",title:"Next T"},{name:"ts",title:"Start T"},{name:"tf",title:"End T"},{name:"size",title:"Size"},{name:"hole",title:"HolePart"},{name:"nodeIndex",title:"Node Index"}]));for(let e of t)this.isHolePart(e)?this.update(e):this.add(e),this.debug&&this.table.insert({strokeID:e.strokeID,segmentIndex:e.segmentIndex,splineIndex:e.splineIndex,pointIndex:e.pointIndex,prevT:e.prevT.toFixed(4),t:e.t.toFixed(4),nextT:e.nextT.toFixed(4),ts:e.spline.ts.toFixed(4),tf:e.spline.tf.toFixed(4),size:`${e.bounds.width.toFixed(2)} / ${e.bounds.height.toFixed(2)}`,hole:e.hole,nodeIndex:e.nodeIndex});return this.debug&&this.table.length>0&&console.log(this.table.toString()),this.narrow(),this.holesPerStroke}add(e){this.strokeHoles=this.holesPerStroke[e.strokeID],this.strokeHoles||(this.strokeHoles=[],this.holesPerStroke[e.strokeID]=this.strokeHoles);let t=this.context.getNodes(e.strokeID).indexOf(e);this.strokeHoles.push({fromPointIndex:e.segmentIndex,toPointIndex:e.segmentIndex,fromTValue:e.prevT,toTValue:e.nextT,fromNodeIndex:t,toNodeIndex:t,strokeID:e.strokeID}),this.debug&&(e.hole=!1,e.nodeIndex=t)}update(e){let t=this.strokeHoles.last;t.toPointIndex=e.segmentIndex,t.toTValue=e.nextT,t.toNodeIndex=this.context.getNodes(e.strokeID).indexOf(e),this.debug&&(e.hole=!0,e.nodeIndex=t.toNodeIndex)}isHolePart(e){let t=this.strokeHoles.last;return!(!t||t.strokeID!=e.strokeID)&&(e.segmentIndex==t.toPointIndex&&e.prevT<=t.toTValue||e.segmentIndex==t.toPointIndex+1&&1==t.toTValue&&0==e.prevT)}narrow(){let e=Object.values(this.holesPerStroke);for(let t of e)for(let e of t){let t=this.context.getNodes(e.strokeID),r=t[e.fromNodeIndex],i=t[e.toNodeIndex],s={s:this.extractT(r,"s",r.prevT,r.nextT),f:this.extractT(i,"f",i.prevT,i.nextT)};r.ts=s.s,i.tf=s.f,e.fromTValue=s.s,e.toTValue=s.f}}extractT(e,t,r,i){let s,n,o="s"==t?r:i;try{s=new lt(e.spline.layout,e.spline.points,e.spline.pointProps,r,i)}catch(e){return o}let a=this.interpolator.build(s);for(let r=0;r<a.length;r++){let i=a.getPoint(r),s=this.context.getBrushApplier(e.strokeID).applyBrush(i);if(this.path.intersects(s)){if("s"==t){o=n;break}n=a.getPointT(r)}else if("s"==t)n=a.getPointT(r);else if(n){o=a.getPointT(r);break}}return o}}class ft{constructor(e=ft.Mode.WHOLE_STROKE){this.mode=e,this.operations=Promise.resolve(),this.holesBuilder=new pt}updateSegmentation(e){if(!this.context)throw new Error("Required spatial context not found");if(!e||0==e.length)return;let t=[],r=!1;for(let i of e){let s=this.context.search(i.bounds);if(0==s.length)continue;let n=[];for(let e of s)switch(e.depth){case ft.SegmentationDepth.STROKE_BOUNDS:{let t=[],i=this.context.getStroke(e.strokeID),s=this.context.getBrushApplier(i.id);for(let e=0;e<i.segmentsCount;e++){let r=ft.buildStrokeSegment(i.id,i.spline,e,s);t.push(r)}this.context.updateTree(e,t),n=n.concat(t),r=!0;break}case ft.SegmentationDepth.STROKE_SEGMENT:{let t=[],i=this.context.getBrushApplier(e.strokeID),s=this.context.distanceInterpolator.build(e.spline),o=i.build(s),a=this.buildShapeSegment(0,e.spline,s,o);for(let r=0;r<s.length-1;r++){let i=this.buildSplineSegment(e,r,s,o,a);a=i.fPoint,t.push(i)}this.context.updateTree(e,t),n=n.concat(t),r=!0;break}case ft.SegmentationDepth.SPLINE_SEGMENT:e.convex=this.context.convexHullChainProducer.build(e.shapesPath),e.shape=e.convex.first,e.depth=ft.SegmentationDepth.CONVEX,r=!0;break;case ft.SegmentationDepth.CONVEX:if(e.convex.intersects(i))if(this.mode==ft.Mode.PARTIAL_STROKE){let t=[];t.push(this.buildPointSegment(e,0)),t.push(this.buildPointSegment(e,1)),this.context.updateTree(e,t),n=n.concat(t),r=!0}else t.push(e);break;case ft.SegmentationDepth.SHAPE:t.push(e);break;default:throw new Error(`Invalid node depth found: ${e.depth}`)}if(n.length>0&&this.context.load(n),r){this.updateSegmentation(e);break}for(let e of t)this.nodes.add(e);this.context.tree.canvas&&this.context.tree.canvas.refresh()}}async updateSegmentationAsync(e){if(!this.context)throw new Error("Required spatial context not found");if(!e||0==e.length)return;let t=!1;for(let r of e){let i=this.context.search(r.bounds);if(0==i.length)continue;let s=[];for(let e of i)switch(e.depth){case ft.SegmentationDepth.STROKE_BOUNDS:{let r=this.context.getStroke(e.strokeID),i=await this.context.segmentsProducer.buildStrokeSegments(r);this.context.updateTree(e,i),s=s.concat(i),t=!0;break}case ft.SegmentationDepth.STROKE_SEGMENT:{let r=[],i=this.context.getBrushApplier(e.strokeID),n=this.context.curvatureInterpolator.build(e.spline),o=i.build(n);for(let t=0;t<n.length-1;t++){let i=this.buildSplineSegment2(e,t,n,o);r.push(i)}this.context.updateTree(e,r),s=s.concat(r),t=!0;break}case ft.SegmentationDepth.SPLINE_SEGMENT:e.convex=this.context.convexHullChainProducer.build(e.shapesPath),e.depth=ft.SegmentationDepth.CONVEX,t=!0;break;case ft.SegmentationDepth.CONVEX:if(e.convex.intersects(r))if(this.mode==ft.Mode.PARTIAL_STROKE){let r=[],i=this.context.getBrushApplier(e.strokeID),n=this.context.distanceInterpolator.build(e.spline),o=i.build(n);for(let t=0;t<n.length;t++){let i=this.buildPointSegment2(e,t,n,o);r.push(i)}this.context.updateTree(e,r),s=s.concat(r),t=!0}else this.nodes2.push(e),this.context.unload(e);break;case ft.SegmentationDepth.SHAPE:this.nodes2.push(e),this.context.unload(e);break;default:throw new Error(`Invalid node depth found: ${e.depth}`)}if(s.length>0&&this.context.load(s),t){await this.updateSegmentationAsync(e);break}this.context.tree.canvas&&this.context.tree.canvas.refresh()}}static buildStrokeNode(e){return{strokeID:e.id,bounds:e.bounds,depth:ft.SegmentationDepth.STROKE_BOUNDS}}static buildStrokeSegment(e,t,r,i){if(r<0||r>=t.segmentsCount)throw new Error(`Invalid index ${r} found. Ensure that index range is {0, ${t.segmentsCount-1}}.`);const s=.166666666666;let n=t.getSegment(r),o=n.getPoint(0),a=n.getPoint(1),l=n.getPoint(2),h=n.getPoint(3),d=-s*o.x+a.x+s*l.x,c=-s*o.y+a.y+s*l.y,u=+s*a.x+l.x-s*h.x,p=+s*a.y+l.y-s*h.y,f=a.toArray(n.layout).concat(l.toArray(n.layout)),m=new ht(n.layout,f,n.pointProps),g=i.build(m),y=g.first.bounds,b=g.last.bounds,E=Math.max(y.width,b.height),P=Math.max(y.height,b.height),I=Math.max(E,P),S=new v(d-I/2,c-P/2,I,I),x=new v(u-I/2,p-P/2,I,I);return{strokeID:e,segmentIndex:r,bounds:y.union(b).union(S).union(x),spline:n,depth:ft.SegmentationDepth.STROKE_SEGMENT}}buildSplineSegment(e,t,r,i,s){let n=new et(i[t],i[t+1]),o=this.buildShapeSegment(t+1,e.spline,r,i);return{strokeID:e.strokeID,segmentIndex:e.segmentIndex,splineIndex:t,bounds:n.bounds,spline:new lt(e.spline.layout,e.spline.points,e.spline.pointProps,r.getPointT(t),r.getPointT(t+1)),shapesPath:n,sPoint:s,fPoint:o,depth:ft.SegmentationDepth.SPLINE_SEGMENT}}buildSplineSegment2(e,t,r,i){let s=new et(i[t],i[t+1]);return{strokeID:e.strokeID,segmentIndex:e.segmentIndex,splineIndex:t,bounds:s.bounds,spline:new lt(e.spline.layout,e.spline.points,e.spline.pointProps,r.getPointT(t),r.getPointT(t+1)),shapesPath:s,depth:ft.SegmentationDepth.SPLINE_SEGMENT}}buildShapeSegment(e,t,r,i){let s=i[e],n=s.bounds,o=r.getPointT(e),a=r.getPointT(e-1),l=r.getPointT(e+1);if(isNaN(a)&&(a=t.ts),isNaN(l)&&(l=t.tf),n.width!=n.height){let e=Math.max(n.width,n.height);n=new v(n.center.x-e/2,n.center.y-e/2,e,e)}return{shape:s,prevT:a,t:o,nextT:l,bounds:n}}buildPointSegment(e,t){let r=0==t?e.sPoint:e.fPoint;return{strokeID:e.strokeID,segmentIndex:e.segmentIndex,splineIndex:e.splineIndex,pointIndex:t,spline:e.spline,bounds:r.bounds,prevT:r.prevT,t:r.t,nextT:r.nextT,shape:r.shape,depth:ft.SegmentationDepth.SHAPE}}buildPointSegment2(e,t,r,i){let s=this.buildShapeSegment(t,e.spline,r,i);return{strokeID:e.strokeID,segmentIndex:e.segmentIndex,splineIndex:e.splineIndex,pointIndex:t,spline:e.spline,bounds:s.bounds,prevT:s.prevT,t:s.t,nextT:s.nextT,shape:s.shape,depth:ft.SegmentationDepth.SHAPE}}createIntervals(e,t){let r={intersected:{},selected:[]};if(0==t.length)return r;let i=this.holesBuilder.build(this.context,e instanceof Set?Array.from(e):e,t);for(let e in i){let s=i[e],n=this.context.getNodes(e),o=[],a=[];r.intersected[e]={intervals:o,holes:a};for(let i of s){let l,h=0==i.fromPointIndex&&i.fromTValue==n.first.ts,d=i.toPointIndex==n.last.segmentIndex&&i.toTValue==n.last.tf;h&&d?(r.selected.push(e),delete r.intersected[e]):(a.push(i),this.context.tree.canvas&&this.context.tree.canvas.addOperation("drawIntersection",t,this.context.getNodes(i.strokeID).slice(i.fromNodeIndex,i.toNodeIndex+1)),h?l={fromPointIndex:i.toPointIndex,fromTValue:i.toTValue,fromNodeIndex:i.toNodeIndex}:d?(o.last||o.push({fromPointIndex:0,fromTValue:n.first.spline.ts,fromNodeIndex:0}),o.last.toPointIndex=i.fromPointIndex+3,o.last.toTValue=i.fromTValue,o.last.toNodeIndex=i.fromNodeIndex):o.last?(o.last.toPointIndex=i.fromPointIndex+3,o.last.toTValue=i.fromTValue,o.last.toNodeIndex=i.fromNodeIndex,l={fromPointIndex:i.toPointIndex,fromTValue:i.toTValue,fromNodeIndex:i.toNodeIndex}):(o.push({fromPointIndex:0,fromTValue:n.first.spline.ts,toPointIndex:i.fromPointIndex+3,toTValue:i.fromTValue,fromNodeIndex:0,toNodeIndex:i.fromNodeIndex}),l={fromPointIndex:i.toPointIndex,fromTValue:i.toTValue,fromNodeIndex:i.toNodeIndex}),l&&o.push(l),i!=s.last||d||(o.last.toPointIndex=n.last.segmentIndex+3,o.last.toTValue=n.last.spline.tf,o.last.toNodeIndex=n.length-1))}let l=[];for(let e of o){if(1==e.fromTValue){let t=n.filter((t=>t.segmentIndex==e.fromPointIndex+1)).first,r=n.filter((t=>t.segmentIndex==e.fromPointIndex));a.push({fromNodeIndex:r.first.nodeIndex||n.indexOf(r.first),toNodeIndex:r.last.nodeIndex||n.indexOf(r.last),type:"OVERLAPPING_INC"}),e.fromPointIndex++,e.fromTValue=0,e.fromNodeIndex=n.indexOf(t)}if(0==e.toTValue){let t=e.toPointIndex-3,r=n.filter((e=>e.segmentIndex==t-1)).last,i=n.filter((e=>e.segmentIndex==t));a.push({fromNodeIndex:i.first.nodeIndex||n.indexOf(i.first),toNodeIndex:i.last.nodeIndex||n.indexOf(i.last),type:"OVERLAPPING_DEC"}),e.toPointIndex--,e.toTValue=1,e.toNodeIndex=n.indexOf(r)}if(e.toPointIndex-e.fromPointIndex<3)l.push(e);else if(e.toPointIndex-e.fromPointIndex==3&&e.fromTValue>=e.toTValue){let t=n.filter((t=>t.segmentIndex==e.fromPointIndex));a.push({fromNodeIndex:t.first.nodeIndex||n.indexOf(t.first),toNodeIndex:t.last.nodeIndex||n.indexOf(t.last),type:"INVALID"}),l.push(e)}}o.remove(...l),0==o.length&&(r.selected.includes(e)||r.selected.push(e),delete r.intersected[e])}return r}reset(e){if(!e)throw new Error("Required spatial context not found");this.context=e,this.nodes=new Set,this.nodes2=[],this.context.tree.canvas&&this.context.tree.canvas.refresh()}}ft.SegmentationDepth={STROKE_BOUNDS:0,STROKE_SEGMENT:1,SPLINE_SEGMENT:2,CONVEX:3,SHAPE:4},Object.defineEnum(ft,"Mode",["WHOLE_STROKE","PARTIAL_STROKE"]);const mt={[ft.SegmentationDepth.STROKE_BOUNDS]:rt.RED,[ft.SegmentationDepth.STROKE_SEGMENT]:rt.BLUE,[ft.SegmentationDepth.SPLINE_SEGMENT]:rt.BROWN,[ft.SegmentationDepth.CONVEX]:rt.MAGENTA,[ft.SegmentationDepth.SHAPE]:rt.GREEN};class gt extends at{constructor(e){super(e.getContext("2d")),this.operations=[];let t=this.refresh.bind(this);this.refresh=L.debounce(t,100)}addOperation(e,...t){this.operations.push({name:e,args:t})}clear(){let e=this.ctx.canvas.toRect().transform(this.ctx.getTransform().invert());this.ctx.clearRect(e.left,e.top,e.width,e.height),this.clearCanvas()}refresh(){let e=[];gt.allocateSegments(e,this.data,0),this.clear();for(let t=e.length-1;t>=0;t--){let r=e[t],i=mt[r.depth];r.depth==ft.SegmentationDepth.SHAPE?this.drawShape(r.shape,i):r.depth==ft.SegmentationDepth.CONVEX?this.drawShape(r.convex.first,i):this.drawRect(r.bounds,i)}this.operations.forEach((e=>this[e.name](...e.args))),this.operations.clear()}drawRange(e){e.forEach((e=>this.drawRect(e.bounds,rt.PURPLE)))}drawIntersection(e,t){t.forEach((e=>this.fillShape(e.shape,rt.YELLOW.toRGBA(.8)))),this.fillShape(e,rt.PINK.toRGBA(.3))}drawSelection(e,t,r){this.fillRect(e),this.fillShape(t,rt.DARK_MAGENTA.toRGBA(.5)),this.fillShape(r)}static allocateSegments(e,t,r){if(t&&(t.bounds&&e.push(t),t.children))if(10!==r)for(let i=0;i<t.children.length;i++)gt.allocateSegments(e,t.children[i],r+1);else console.warn("depth 10")}static getInstance(e,t){if(!e)return;let r=new gt(e);return Object.defineProperty(r,"data",{get:()=>t.data,enumerable:!0}),r}}class yt extends f.default{constructor(...e){let t;super(...e),"undefined"!=typeof document&&("loading"==document.readyState?addEventListener("DOMContentLoaded",(e=>t=gt.getInstance(document.getElementById("rbush"),this))):t=gt.getInstance(document.getElementById("rbush"),this)),Object.defineProperty(this,"canvas",{get:()=>this.debug?t:null,enumerable:!0})}toBBox(e){return{minX:e.bounds.left,minY:e.bounds.top,maxX:e.bounds.right,maxY:e.bounds.bottom}}compareMinX(e,t){return e.bounds.x-t.bounds.x}compareMinY(e,t){return e.bounds.y-t.bounds.y}search(e){return super.search({minX:e.left,minY:e.top,maxX:e.right,maxY:e.bottom})}find(e,t=this.data,r=0,i=[]){if(t){if(t.stroke){let r=!0;Object.keys(e).forEach((i=>{r=r&&t[i]==e[i]})),r&&i.push(t)}if(t.children){if(6!==r){for(let s=0;s<t.children.length;s++)this.find(e,t.children[s]||null,r+1,i);return i}console.warn("depth 6")}}}}let bt=m?m.default||globalThis.JSZip:{},Et=new TextEncoder,Pt={fourCCLength:4,versionLength:3,chunkDescriptorLength:8,fourCC:{RIFF:Et.encode("RIFF"),HEAD:Et.encode("HEAD"),META:Et.encode("META"),DATA:Et.encode("DATA"),TXT:Et.encode("TEXT"),JSON:Et.encode("JSON")}};Object.defineEnum(Pt,"ContentType",["BINARY","PROTO","JSON","TEXT"]),Object.defineEnum(Pt,"CompressionType",["NONE","ZIP","LZMA"]);class It{constructor(e,t=new Uint8Array([0,0,0])){this.textEncoder=new TextEncoder,Object.defineProperty(this,"format",{get:()=>e,set:t=>{if(!t)throw new Error("format is expected");if("string"==typeof t&&(t=this.textEncoder.encode(t)),!(t instanceof Uint8Array))throw new Error("format expected type is Uint8Array");if(t.length!=Pt.fourCCLength)throw new Error(`format expected length is ${Pt.fourCCLength}`);e=t}}),Object.defineProperty(this,"version",{get:()=>t,set:e=>{if(e){if("string"==typeof e&&(e=new Uint8Array(e.split("."))),!(e instanceof Uint8Array))throw new Error("version expected type is Uint8Array");if(e.length!=Pt.versionLength)throw new Error(`version expected length is ${Pt.versionLength}`)}t=e}}),Object.defineProperty(this,"length",{get:()=>this.descriptors.length}),this.format=e,this.version=t,this.reset()}add(e,t={}){if(e){if(this.validateChunkDescriptor(t),Object.equals(t.fourCC,Pt.fourCC.META)){if(e instanceof ArrayBuffer||ArrayBuffer.isTypedArray(e))throw new Error("Binary meta is not allowed");if(this.descriptors.some((e=>Object.equals(e.fourCC,Pt.fourCC.META))))throw new Error("Meta chunk is found. More than 1 meta chunk is not allowed.")}t=Object.assign({},t,{data:e}),Object.equals(t.fourCC,Pt.fourCC.META)?this.descriptors.unshift(t):this.descriptors.push(t)}}validateChunkDescriptor(e){if(e.fourCC||(e.fourCC=Pt.fourCC.DATA),e.version||(e.version=new Uint8Array([0,0,0])),e.contentType||(e.contentType=Pt.ContentType.BINARY),e.compressionType||(e.compressionType=Pt.CompressionType.NONE),"string"==typeof e.fourCC&&(e.fourCC=this.textEncoder.encode(e.fourCC)),"string"==typeof e.version&&(e.version=new Uint8Array(e.version.split("."))),!(e.fourCC instanceof Uint8Array))throw new Error(`Invalid fourCC type - ${e.fourCC}, expected string or Uint8Array`);if(e.fourCC.length!=Pt.fourCCLength)throw new Error(`Invalid fourCC: [${e.fourCC}]`);if(!(e.version instanceof Uint8Array))throw new Error(`Invalid chunk version - ${e.version}, expected string or Uint8Array`);if(e.version.length!=Pt.versionLength)throw new Error(`Invalid version: [${e.version}]`)}async encode(){if(0==this.descriptors.length)throw new Error("Chunks not found. Build process failed.");let e=await this.build();return this.reset(),e}async build(){if(0==this.descriptors.length)throw new Error("RIFF build failed. Chunks not found.");let e=0,t=[],r=0;for(let e of this.descriptors){let i=await this.buildChunk(e);t.push(i),r+=i.length}let i=this.buildHeadChunk(t);r+=i.length,t.unshift(i);let s=Pt.fourCCLength+r,n=Pt.fourCC.RIFF.length+Uint32Array.BYTES_PER_ELEMENT+s,o=new ArrayBuffer(n);return this.content=new Uint8Array(o),this.contentView=new DataView(o),this.content.set(Pt.fourCC.RIFF,e),e+=Pt.fourCC.RIFF.length,this.contentView.setUint32(e,s,!0),e+=Uint32Array.BYTES_PER_ELEMENT,this.content.set(this.format,e),e+=this.format.length,t.forEach((t=>{this.appendChunk(t,e),e+=t.length})),this.content}async buildChunk(e){let t=e.data;switch(e.contentType==Pt.ContentType.JSON&&(t=JSON.stringify(t)),e.compressionType){case Pt.CompressionType.NONE:e.contentType!=Pt.ContentType.JSON&&e.contentType!=Pt.ContentType.TEXT||(t=this.textEncoder.encode(t));break;case Pt.CompressionType.ZIP:{let e=new bt;e.file("data",t),t=await e.generateAsync({type:"uint8array",compression:"DEFLATE",compressionOptions:{level:9}});break}case Pt.CompressionType.LZMA:throw new Error("LZMA compression is not supported yet");default:throw new Error(`Invalid compression type: ${e.compressionType}`)}let r=t.length,i=r%2,s=e.fourCC.length+Uint32Array.BYTES_PER_ELEMENT+r+i;return Object.assign({},e,{data:t,size:r,length:s})}buildHeadChunk(e){let t=this.version.length+1+e.length*Pt.chunkDescriptorLength,r=t%2,i=Pt.fourCCLength+Uint32Array.BYTES_PER_ELEMENT+t+r,s=new Uint8Array(t+r),n=this.version.length+1;return s.set(this.version,0),e.forEach(((e,t)=>{let r=new Uint8Array(8);r.set(e.version,0),r.set([e.contentType.value],3),r.set([e.compressionType.value],4),s.set(r,n+t*Pt.chunkDescriptorLength)})),{fourCC:Pt.fourCC.HEAD,data:s,size:t,length:i}}appendChunk(e,t){this.content.set(e.fourCC,t),t+=e.fourCC.length,this.debug&&console.log((new TextDecoder).decode(e.fourCC),e.size),this.contentView.setUint32(t,e.size,!0),t+=Uint32Array.BYTES_PER_ELEMENT,this.content.set(e.data,t)}reset(){this.descriptors=[],this.content=null,this.contentView=null}}const St={contentType:Pt.ContentType.BINARY,compressionType:Pt.CompressionType.NONE};class xt{constructor(){this.textDecoder=new TextDecoder}async decode(e,t){t instanceof Uint8Array&&(t=this.textDecoder.decode(t));let r=0,i=r+Pt.fourCC.RIFF.length;if(this.content=e,this.contentView=new DataView(e.buffer),this.descriptor={},this.onChunkDecoded||(this.descriptor.chunks=[],this.descriptor.asProps=function(){return Object.assign({},...this.chunks.map((e=>({[e.fourCC.toLowerCase()]:e.value}))))}),!Object.equals(this.content.subarray(r,i),Pt.fourCC.RIFF))throw new Error("Invalid RIFF fourCC");r=i,i=r+Uint32Array.BYTES_PER_ELEMENT;let s,n=this.contentView.getUint32(r,!0)+i;if(n%2!=0)throw new Error("Invalid RIFF file size");if(n!=this.content.length)throw new Error("Incomplete RIFF file");r=i,i=r+Pt.fourCCLength,this.descriptor.format=this.textDecoder.decode(this.content.subarray(r,i)),r=i;let o=0;for(;r<n;){let e=this.content.subarray(r,r+Pt.fourCCLength);if(Object.equals(e,Pt.fourCC.HEAD))s=this.decodeHead(r),r+=s.length;else{let i=this.textDecoder.decode(e);if(t&&i!=t){r+=this.readChunkDimensionality(r).length}else{let e=this.readChunk(r);r+=e.length;let n=s.descriptors[o]||St,a=await this.decodeChunk(e.data,n);if(t)return a;this.onChunkDecoded?await this.onChunkDecoded(i,a,this.descriptor):this.descriptor.chunks.push({fourCC:i,value:a}),o++}}}return this.onChunkDecoded?void 0:this.descriptor}decodeHead(e){let t=this.readChunk(e),r={size:t.size,length:t.length,descriptors:[]},i=`${t.data[0]}.${t.data[1]}.${t.data[2]}`;"0.0.0"!=i&&(this.descriptor.version=i);let s=(t.size+t.size%2-4)/8;for(let e=0;e<s;e++){let s=4+e*Pt.chunkDescriptorLength,n=t.data.slice(s,s+8);i=`${n[0]}.${n[1]}.${n[2]}`;let o={contentType:Pt.ContentType[n[3]],compressionType:Pt.CompressionType[n[4]]};"0.0.0"!=i&&(o.version=i),r.descriptors.push(o)}return r}readChunk(e){let t,r=this.readChunkDimensionality(e);if(r.size>0){let e=r.byteOffset+r.size;t=this.content.subarray(r.byteOffset,e),t=new Uint8Array(t,t.byteOffset,t.length)}else t=new Uint8Array(0);return{data:t,size:r.size,length:r.length}}readChunkDimensionality(e){e+=Pt.fourCCLength;let t=this.contentView.getUint32(e,!0),r=Pt.fourCCLength+Uint32Array.BYTES_PER_ELEMENT+t,i=r%2;return{byteOffset:e+Uint32Array.BYTES_PER_ELEMENT,size:t,length:r+i}}async decodeChunk(e,t){let r;switch(t.compressionType){case Pt.CompressionType.NONE:r=t.contentType==Pt.ContentType.JSON||t.contentType==Pt.ContentType.TEXT?this.textDecoder.decode(e):e;break;case Pt.CompressionType.ZIP:{let i=await bt.loadAsync(e);r=t.contentType==Pt.ContentType.JSON||t.contentType==Pt.ContentType.TEXT?await i.file("data").async("string"):await i.file("data").async("uint8array");break}case Pt.CompressionType.LZMA:throw new Error("LZMA compression is not supported yet");default:throw new Error(`Invalid compression type: ${t.compressionType}`)}return t.contentType==Pt.ContentType.JSON&&(r=JSON.parse(r)),r}}class wt{calculatePrecision(e,t){throw new Error("PrecisionCalculator.calculatePrecision(data, property) should be implemented")}}const Tt=["position","size","rotation","scale","offset"],vt={position:0,size:4,rotation:8,scale:12,offset:16};class Rt{constructor(e=0){this.precisions=e;for(let e of Tt)Object.defineProperty(this,e,{get:()=>this.get(e),set:t=>this.set(e,t),enumerable:!0});Object.defineProperty(this,"factors",{get:()=>Object.assign({},...Tt.map((e=>({[e]:10**this[e]})))),enumerable:!0})}get(e){return this.precisions>>vt[e]&15}set(e,t){if(t>15||t<0)throw new Error(`Invalid '${e}' precision value ${t} found. The value must be in the interval [0, 15].`);if(t>this[e])throw new Error(`PrecisionSchema '${e}' update failed. Update value ${t} > ${this[e]} - update value should be less than current value.`);t!=this[e]&&(this.precisions=this.precisions&~(15<<vt[e])|t<<vt[e])}update(e){Tt.forEach((t=>{let r=e[t];r<this[t]&&(this[t]=r)}))}decode(){return Object.assign({},...Tt.map((e=>({[e]:this[e]}))))}static encode(e={}){let t=0;return Tt.forEach((r=>{let i=e[r]||0;if(i>15||i<0)throw new Error(`Invalid '${r}' precision value ${i} found. The value must be in the interval [0, 15].`);t=t&~(15<<vt[r])|i<<vt[r]})),t}}class At{static l2Norm(e){let t=0;for(let r of e)t+=r*r;return Math.sqrt(t)}static rmse(e,t){let r=0;for(let i=0;i<e.length;i++){let s=e[i]-t[i];r+=s*s}return Math.sqrt(r/e.length)}static variance(e){if(e.length<=1)return 0;let t=this.average(e),r=0;for(let i of e){let e=i-t;r+=e*e}return r/(e.length-1)}static average(e){let t=0;for(let r of e)t+=r;return t/e.length}static calculateError(e,t){let r=10**t,i=new Float32Array(e.length);for(let t=0;t<i.length;t++){let s=Math.round(e[t]*r);if(s>Number.MAX_INT32||s<-Number.MAX_INT32)return NaN;i[t]=s}let s=new Float32Array(e.length);for(let e=0;e<i.length;e++)s[e]=i[e]/r;return this.rmse(e,s)}static isZero(e){return Math.abs(e)<Number.EPSILON}}class Ot extends x{constructor(e,t){super(),this.layout=e,this.pathPointCalculator=t,this.inputBuffer=[],this.prediction=!0}togglePrediction(e){console.warn("PathProducer togglePrediction method is deprecated. Use InkBuilder instance prediction property to configure prediction behaviour."),this.prediction=e}addImpl(e,t){if(e.phase!=this.phase)throw new Error(`The phase of the addition (${e.phase.name}) doesn't match the phase of the PathProducer (${this.phase.name})`);let r=[],i=[];e&&this.inputBuffer.push(e);let s=this.inputBuffer.length>=3?this.inputBuffer[this.inputBuffer.length-3]:null,n=this.inputBuffer.length>=2?this.inputBuffer[this.inputBuffer.length-2]:null,o=this.inputBuffer.length>=1?this.inputBuffer[this.inputBuffer.length-1]:null,a=this.calculate(s,n,o);return e&&a&&r.push(...a.toArray(this.layout)),this.phase==x.Phase.END?(a=this.calculate(n,o,null),a&&r.push(...a.toArray(this.layout))):this.prediction&&(this.phase==x.Phase.UPDATE||t)&&(a=this.calculate(n,o,t),a&&(i.push(...a.toArray(this.layout)),a=this.calculate(o,t,null),a&&i.push(...a.toArray(this.layout)))),{added:r,predicted:i}}calculate(e,t,r){return t?this.pathPointCalculator(e,t,r):null}reset(){super.reset(),this.inputBuffer.clear()}}const Ct=[-6e-6,-139e-6,-185e-6,414e-6,.002357,.003357,-.003135,-.023928,-.042909,-.017858,.096525,.254692,.347072,.26881,.114933];class Dt extends De{constructor(e,t=15){super(),this.buffer=[],this.pointsCount=0,this.filter=Ct.slice(),Object.defineProperty(this,"movingAverageWindowSize",{get:function(){return t},set:function(e){t=e,this.filter.length!=e&&(this.filter=Dt.resample(Ct,e)),this.predictionPointsCount=4*e/15,this.windowSize=this.filter.length},enumerable:!0}),this.dimsCount=e,this.movingAverageWindowSize=t}add(e,t){return t?this.project(e):this.addSequence(e)}buildImpl(e){return this.project(e)}project(e){if(e.length%this.dimsCount!=0)throw new Error(`Points size ('${e.length}') must be multiple of the dimensions count ('${this.dimsCount}').`);if(0==e.length)return[];let t=[],r=this.buffer.slice(),i=e.slice(0,e.length-this.dimsCount),s=this.addSequence(i);t.push(...s);let n=e.slice(e.length-this.dimsCount,e.length),o=this.predictionPointsCount;for(let e=0;e<o;e++){let r=this.addPoint(n);o-e<=this.pointsCount&&t.push(...r)}return this.buffer=r,t}addSequence(e){if(e.length%this.dimsCount!=0)throw new Error(`Points size ('${e.length}') must be multiple of the dimensions count ('${this.dimsCount}').`);let t=[],r=e.length/this.dimsCount;for(let i=0;i<r;i++){let r=this.addPoint(e.slice(i*this.dimsCount,(i+1)*this.dimsCount));t.push(...r)}return this.pointsCount+=r,t}addPoint(e){for(this.buffer.push(...e);this.buffer.length<this.windowSize*this.dimsCount;)this.buffer.unshift(...this.buffer.slice(0,this.dimsCount));for(;this.buffer.length>this.windowSize*this.dimsCount;)this.buffer=this.buffer.slice(this.dimsCount);return this.filterBuffer()}filterBuffer(){let e=[];for(let t=0;t<this.windowSize;t++)for(let r=0;r<this.dimsCount;r++)isNaN(e[r])&&(e[r]=0),e[r]+=this.buffer[t*this.dimsCount+r]*this.filter[t];return e}reset(){super.reset(),this.pointsCount=0,this.buffer.clear()}static resample(e,t){let r=new Float32Array(t),i=e.length/t,s=0;for(let n=0;n<t;n++){let o=(e.length-1)*n/(t-1),a=Math.floor(o),l=Math.ceil(o),h=o-a,d=i*(e[a]*(1-h)+e[l]*h);s+=d,r[n]=d}let n=1/s;for(let e=0;e<t;e++)r[e]*=n;return r}}class kt extends De{constructor(e){super(),this.layout=e,this.pathPointProps={},this.lastSpline=[]}add(e,t){0==this.lastSpline.length&&e.length>0&&e.unshift(...e.slice(0,this.layout.length)),t&&(e.length>=this.layout.length?e.push(...e.slice(e.length-this.layout.length,e.length)):e.push(...this.getLastPart()));let r=this.getFirstPart();return this.lastSpline=r.concat(e),e}predict(e=[]){if(0==e.length)return e;let t=[],r=this.getFirstPart();for(t.push(...r),t.push(...e),t.push(...t.slice(t.length-this.layout.length,t.length));t.length<4*this.layout.length;)t.unshift(t.slice(0,this.layout.length));return t}buildImpl(e){let t=[];return e.length>0&&(t.push(...e.slice(0,this.layout.length)),t.push(...e),e.length>=this.layout.length&&t.push(...e.slice(e.length-this.layout.length,e.length))),e}getOutput(e,t){let r=t==kt.OutputType.ADDITION?this.lastSpline.length>=4*this.layout.length?this.lastSpline:[]:e;return 0==r.length?void 0:new lt(this.layout,r,this.pathPointProps,0,1)}getFirstPart(){return this.lastSpline.slice(Math.max(0,this.lastSpline.length-3*this.layout.length),this.lastSpline.length)}getLastPart(){return this.lastSpline.slice(this.lastSpline.length-this.layout.length,this.lastSpline.length)}reset(){super.reset(),this.lastSpline=[]}}class Nt{constructor(e){this.key=e,this.height=1}leftRotate(){let e=this.right,t=e.left;return e.left=this,this.right=t,this.height=Math.max(Nt.height(this.left),Nt.height(this.right))+1,e.height=Math.max(Nt.height(e.left),Nt.height(e.right))+1,e}rightRotate(){let e=this.left,t=e.right;return e.right=this,this.left=t,this.height=Math.max(Nt.height(this.left),Nt.height(this.right))+1,e.height=Math.max(Nt.height(e.left),Nt.height(e.right))+1,e}getBalanceFactor(){return Nt.height(this.left)-Nt.height(this.right)}static height(e){return e?e.height:0}static minValue(e){if(!e)return;let t=e;for(;t.left;)t=t.left;return t.key}static maxValue(e){if(!e)return;let t=e;for(;t.right;)t=t.right;return t.key}}class Mt{constructor(){this.count=0,this.hasKey=!1,this.root}min(){return Nt.minValue(this.root)}max(){return Nt.maxValue(this.root)}add(e){return this.hasKey=!1,this.root=this.insertNode(this.root,e),this.hasKey||this.count++,!this.hasKey}insertNode(e,t){if(!e)return new Nt(t);if(t<e.key)e.left=this.insertNode(e.left,t);else{if(!(t>e.key))return this.hasKey=!0,e;e.right=this.insertNode(e.right,t)}if(!this.hasKey){e.height=1+Math.max(Nt.height(e.left),Nt.height(e.right));let r=e.getBalanceFactor();if(r>1){if(t<e.left.key)return e.rightRotate();if(t>e.left.key)return e.left=e.left.leftRotate(),e.rightRotate()}else if(r<-1){if(t>e.right.key)return e.leftRotate();if(t<e.right.key)return e.right=e.right.rightRotate(),e.leftRotate()}}return e}contains(e){return this.containsNode(this.root,e)}containsNode(e,t){return!!e&&(t<e.key?this.containsNode(e.left,t):!(t>e.key)||this.containsNode(e.right,t))}printTree(){if(!this.root)return;let e=[this.root],t=this.root.height;for(;e.length>0;){let r=e.shift();t!=r.height&&console.log("-"),console.log(`${r.key} with height: ${r.height}, balance: ${r.getBalanceFactor()}`),t=r.height;let i=r.left,s=r.right;i&&e.push(i),s&&e.push(s)}}toArray(){let e=[];return Mt.fillArray(e,this.root),e}static fillArray(e,t){t&&(this.fillArray(e,t.left),e.push(t.key),this.fillArray(e,t.right))}}class Lt{constructor(){this.tree=new Mt,Object.defineProperty(this,"length",{get:()=>this.tree.count,enumerable:!0})}clear(){this.tree=new Mt}add(e){return this.tree.add(e)}includes(e){return this.tree.contains(e)}min(){return this.tree.min()}max(){return this.tree.max()}toArray(){return this.tree.toArray()}}class _t extends ct{constructor(e,t){super(e,t),this.state.segmentIndex=-1,this.state.lastSegmentIndex=-1,this.state.lastPointRotation=0,this.state.lastPointT=0,this.state.absAccumulatedErrorPos=0,this.state.absAccumulatedErrorS=0,this.setT=new Lt,Object.defineProperty(this,"errorThreshold",{get:function(){return this.error},set:function(e){this.error=e,this.errorDistSq=this.error*this.error,this.error10=10*this.error},enumerable:!0}),this.errorThreshold=.15}discretize(e){let t=[],r=e.segmentsCount,i=r-1;for(let s=0;s<r;s++){this.calculatePolynomials(e,s);let r=this.calculateTValues(s==i,e.ts,e.tf);t.push(...this.samplePoints(s,r)),r.length>0&&(this.resetAccumulatedErrors(),this.storeLastPoint(t))}return t}samplePoints(e,t){let r=[];return t.toArray().forEach((t=>{this.keepSegmentT(e,t),r.push(...this.samplePoint(t))})),r}storeLastPoint(e){let t=e.length-this.layout.length;super.storeLastPoint(e,t),this.state.lastPointRotation=this.getPropValue(j.Property.ROTATION,e,t),this.state.lastPointT=this.setT.max(),this.state.lastSegmentIndex=this.state.segmentIndex}calculateTValues(e,t,r){this.state.segmentIndex++;let i=0==this.state.segmentIndex?t:0,s=e?r:1;return this.setT.clear(),this.getTForPos(i,s),this.state.layout.SIZE&&this.getTForCubic(i,s,this.state.layout.SIZE.polynomials,this.error),this.mustAddStartT()&&this.setT.add(i),e&&this.setT.add(s),this.state.layout.ROTATION&&this.getTForRotation(i,s),this.setT}mustAddStartT(){if(this.state.lastSegmentIndex<0)return!0;let e=this.state.lastPointT-(this.state.segmentIndex-this.state.lastSegmentIndex),t=this.setT.length>0?this.setT.min():1,r=this.getPosErrorAtT0(t,this.state.lastPointPosition);if(this.state.absAccumulatedErrorPos+=Math.abs(r),this.state.layout.SIZE){let r=this.getErrorAtT0(this.state.layout.SIZE.polynomials,t,e,this.state.lastPointSize);this.state.absAccumulatedErrorS+=Math.abs(r)}return this.state.absAccumulatedErrorPos>this.errorDistSq||this.state.absAccumulatedErrorS>this.error}getPosErrorAtT0(e,t){let r=this.getTPoint(e),i=this.getTPoint(0);return this.minDistanceSq(t,r,i)}getErrorAtT0(e,t,r,i){let s=r,n=i,o=t,a=this.cubicCalc(e,o),l=this.cubicCalc(e,0),h=n+(0-s)*(a-n)/(o-s);return Math.abs(l-h)}getTForPos(e,t){let r=this.getTPoint(e),i=this.getTPoint(t),s=this.subdividePos(r,i);if(s.split)this.subdivideRecursivePos(r,s),this.setT.add(s.t),this.subdivideRecursivePos(s,i);else{let e=this.subdividePos(r,s),t=this.subdividePos(s,i);e.split&&(this.subdivideRecursivePos(r,e),this.setT.add(e.t),this.subdivideRecursivePos(e,s)),(e.split||t.split)&&this.setT.add(s.t),t.split&&(this.subdivideRecursivePos(s,t),this.setT.add(t.t),this.subdivideRecursivePos(t,i))}}subdivideRecursivePos(e,t){let r=this.subdividePos(e,t);r.split&&(this.subdivideRecursivePos(e,r),this.setT.add(r.t),this.subdivideRecursivePos(r,t))}subdividePos(e,t){let r=.5*(e.t+t.t),i=this.getTPoint(r),s=this.minDistanceSq(e,t,i),n=e.add(t).scaleSelf(.5),o=i.subtract(n).absSelf();return i.split=s>this.errorDistSq||o.x>this.error10||o.y>this.error10,this.state.layout.Z&&(i.split=i.split||o.z>this.error10),i}getTForCubic(e,t,r,i){let s={v:this.cubicCalc(r,e),t:e},n={v:this.cubicCalc(r,t),t:t},o=this.subdivide(s,n,r);if(o.diff>i)this.subdivideRecursive(s,o,r,i),this.setT.add(o.t),this.subdivideRecursive(o,n,r,i);else{let e=this.subdivide(s,o,r),t=this.subdivide(o,n,r);e.diff>i&&(this.subdivideRecursive(s,e,r,i),this.setT.add(e.t),this.subdivideRecursive(e,o,r,i)),(e.diff>i||t.diff>i)&&this.setT.add(o.t),t.diff>i&&(this.subdivideRecursive(o,t,r,i),this.setT.add(t.t),this.subdivideRecursive(t,n,r,i))}}subdivideRecursive(e,t,r,i){let s=this.subdivide(e,t,r);s.diff>i&&(this.subdivideRecursive(e,s,r,i),this.setT.add(s.t),this.subdivideRecursive(s,t,r,i))}subdivide(e,t,r){let i=.5*(e.t+t.t),s=this.cubicCalc(r,i),n=.5*(e.v+t.v);return{v:s,t:i,diff:Math.abs(s-n)}}getTForRotation(e,t){let r=this.state.layout.ROTATION.polynomials,i=this.state.lastPointRotation;this.state.lastSegmentIndex<0&&(i=this.cubicCalc(r,e));let s=.25*(t-e);for(let t=0;t<4;t++){let n=e+t*s,o=this.cubicCalc(r,n);Math.abs(o-i)>.06&&(this.setT.add(n),i=o)}}minDistanceSq(e,t,r){let i=r.vec,s=i.squaredDistance(e.value,t.value);if(0==s)return i.squaredDistance(r.value,e.value);let n=Math.max(0,Math.min(1,i.dot(r.subtract(e).value,t.subtract(e).value)/s)),o=t.subtract(e).scale(n).add(e);return i.squaredDistance(r.value,o.value)}getTPoint(e){let t=new w(this.cubicCalc(this.state.layout.X.polynomials,e),this.cubicCalc(this.state.layout.Y.polynomials,e),this.state.layout.Z?this.cubicCalc(this.state.layout.Z.polynomials,e):void 0);return t.t=e,t}cubicCalc(e,t){return e[0]+e[1]*t+e[2]*t*t+e[3]*t*t*t}resetAccumulatedErrors(){this.state.absAccumulatedErrorPos=0,this.state.absAccumulatedErrorS=0}resetState(){this.state.segmentIndex=-1,this.state.lastSegmentIndex=-1,this.state.lastPointT=0,this.state.lastPointRotation=0,this.resetAccumulatedErrors()}reset(){super.reset(),this.resetState()}}class Ft extends De{static ARRAY_TYPE=et;constructor(e){super(),this.brush=e}buildImpl(e){return this.generatePolygons(e)}generatePolygons(e){let t=new et;if(!e)return t;for(let r=0;r<e.length;r++){let i=e.getPoint(r),s=this.applyBrush(i);t.push(s)}return t}applyBrush(e){let t=this.createTransform(e),i=this.brush.selectShape(t.maxScale).shape,s=Float32Array.createSharedInstance(2*i.length);for(let e=0;e<i.length;e++){let n=e*i.stride,o=r.vec4.fromValues(i.getPointX(e),i.getPointY(e),0,1);r.vec4.transformMat4(o,o,t),s[n]=o[0]/o[3],s[n+1]=o[1]/o[3]}return xe.createSharedInstance(s)}createTransform(e){if(isNaN(e.size))throw new Error("Size information not found.");let t=r.mat4.create(),i=e.size*e.scaleX,s=e.size*e.scaleY,n=e.size*e.scaleZ||0,o=Math.max(i,s,n);return r.mat4.translate(t,t,r.vec3.fromValues(e.x,e.y,e.z||0)),r.mat4.rotateZ(t,t,e.rotation),r.mat4.translate(t,t,r.vec3.fromValues(e.offsetX,e.offsetY,e.offsetZ||0)),r.mat4.scale(t,t,r.vec3.fromValues(i,s,n)),t.maxScale=o,t}}class Bt extends De{static ARRAY_TYPE=et;constructor(){super(),this.lastPolygon}add(e,t){return this.buildConvexHulls(e,!0)}buildImpl(e){if(!(e instanceof et)){if(!(e instanceof xe))throw new Error("ConvexHullChainProducer build 'input' type missmatch, expected type is oneof(Polygon, InkPath2D)");e=[e]}return this.buildConvexHulls(e)}buildConvexHulls(e,t=!1){let r=new et,i=this.lastPolygon;for(let t of e){if(i||1==e.length){let e=i?i.union(t):t.convex();r.push(e)}i=t}return t&&e.length>0&&(this.lastPolygon=e.last),r}reset(){super.reset(),this.lastPolygon=null}}"function"==typeof Worker&&(Worker.prototype.on=function(e,t){this[`on${e}`]=r=>{let i="message"==e?r.data:r;t(i)}}),"function"==typeof DedicatedWorkerGlobalScope&&(DedicatedWorkerGlobalScope.prototype.on=function(e,t){this[`on${e}`]=r=>{let i="message"==e?r.data:r;t(i)}});let Ut=!1;class jt{constructor(e,t,r=jt.WorkerType.CLASSIC){if(!Ut)throw new Error("Constructor is private, use static method getInstance instead.");this.name=e,this.type=r,t&&t.startsWith("file://")&&(t=t.replace("file://","")),this.src=t,this.workers=[],this.transferables=[],this.status=jt.Status.CLOSED,this.resolver={};let i=0;Object.defineProperty(this,"nextID",{get:()=>String(i++),enumerable:!0,configurable:!0})}async open(e=this.src){if(this.status!=jt.Status.CLOSED)throw new Error(`${this.name} worker cannot be opened. Current status is ${this.status.name}.`);if(!e)throw new Error(`${this.name} worker location is not deined.`);let t,r;if("function"==typeof Worker)t=Worker,r=navigator.hardwareConcurrency||1;else{const e=await Promise.resolve().then((function(){return h(require("os"))})),i=await Promise.resolve().then((function(){return h(require("worker_threads"))})),{Worker:s}=i;t=s,r=e.cpus().length}this.ready=0;for(let i=0;i<r;i++){let r=this.name+i,s=new t(e,{type:this.type,name:r,workerData:{name:r}});s.name=i,s.on("message",(e=>"INIT"==e.action?this.confirmWorkerReady():this.recieve(e))),s.on("error",(e=>this.recieveError(e,i))),this.workers.push(s)}return this.status=jt.Status.OPEN_IN_PROGRESS,new Promise(((e,t)=>{this.workers.forEach(((e,t)=>e.postMessage({action:"INIT",worker:t}))),this.resolve=e}))}confirmWorkerReady(){this.ready++,this.ready==this.workers.length&&(this.resolve(),delete this.ready,delete this.resolve,this.status=jt.Status.OPEN)}close(){this.workers.forEach((e=>e.terminate())),this.workers.clear(),this.status=jt.Status.CLOSED}async broadcast(e,t){if(this.status!=jt.Status.OPEN)throw new Error(`ThreadBridge is not opened yet. Current status is ${this.status.name}. Use open first.`);return new Promise(((r,i)=>{this.resolver[t]=r;for(let r of this.workers){let i=this.buildRequestMessage(e,t);if(!i)break;this.send(r.name,i)}}))}async broadcastMessage(e){if(this.status!=jt.Status.OPEN)throw new Error(`ThreadBridge is not opened yet. Current status is ${this.status.name}. Use open first.`);if(!e.actionID)throw new Error("message actionID is required");return new Promise(((t,r)=>{this.resolver[e.actionID]=t;for(let t of this.workers)this.send(t.name,e)}))}send(e,t){if(this.status!=jt.Status.OPEN)throw new Error(`ThreadBridge is not opened yet. Current status is ${this.status.name}. Use open first.`);if(!t)throw new Error("message is required");this.workers[e].postMessage(t,this.transferables),this.transferables.clear()}buildRequestMessage(e,t){throw new Error("ThreadBridge.buildRequestMessage(action, actionID) is abstract and should be implemented")}recieve(e){throw new Error("ThreadBridge.recieve(message) is abstract and should be implemented")}resolve(e,t){this.resolver[e](t),delete this.resolver[e]}recieveError(e,t){console.warn(`${this.name} worker ${t}: ${e.message}`),e.filename||console.error(e)}static getInstance(){return this.instance||(Ut=!0,this.instance=new this,Ut=!1),this.instance}}Object.defineEnum(jt,"Status",["OPEN","OPEN_IN_PROGRESS","CLOSED"]),jt.WorkerType={CLASSIC:"classic",MODULE:"module"};class Gt extends jt{static WORKER_NAME="ConvexHullProvider";constructor(){super(Gt.WORKER_NAME,Gt.buildWorkerURL(),Gt.buildWorkerURL().contains("/wacom-src/")?jt.WorkerType.MODULE:jt.WorkerType.CLASSIC),this.state={}}static buildWorkerURL(){if("function"==typeof DedicatedWorkerGlobalScope)return;let e="undefined"==typeof __location?"undefined"==typeof document?new(require("url").URL)("file:"+__filename).href:document.currentScript&&document.currentScript.src||new URL("digital-ink-min.cjs",document.baseURI).href:__location;return e=e.substring(0,e.lastIndexOf("/")),e.endsWith("workers")||(e+="/workers"),e+=`/${Gt.WORKER_NAME}.js`,e}async build(e,t,r){let i=this.nextID;return this.state[i]={type:t,input:e,output:new et,queue:[...e.slice()],lastPolygon:r,expected:e.length,processed:0},await this.broadcast("BUILD",i)}buildRequestMessage(e,t){let r={action:e,actionID:t},i=this.state[t];if("BUILD"!=e)throw new Error(`Unknow data action found: ${e}`);{let e=i.queue.shift();if(!e)return;let t,s=i.input.indexOf(e),n=0==s?i.lastPolygon:i.input[s-1];n?t=Array.of(...n.shape.points,...e.shape.points):(n=e,e=i.queue.shift(),e?(t=Array.of(...n.shape.points,...e.shape.points),i.updateIndex=!0,i.expected--,s++):t=n.shape.points),r.index=s,r.data=t}return r}recieve(e){let t=this.state[e.actionID],r=t.updateIndex?e.index-1:e.index;if(t.output[r]=xe.createSharedInstance(e.data),t.processed++,t.processed==t.expected)delete this.state[e.actionID],this.keepAllData&&t.type==De.OutputType.ADDITION&&(this.path||(this.path=new et),this.path.push(...t.output)),this.resolve(e.actionID,t.output);else{let t=this.buildRequestMessage(e.action,e.actionID);t&&this.send(e.worker,t)}}}class $t extends De{static ARRAY_TYPE=et;constructor(){super(),this.lastPolygon,this.convexHullProducer=Gt.getInstance()}static buildWorkerURL(){return Gt.buildWorkerURL()}async build(e,t=$t.OutputType.PROCESSOR,r=!0){let i=this.lastPolygon;t==$t.OutputType.ADDITION&&e.length>0&&(this.lastPolygon=e.last),r&&(this.lastPolygon=null),this.convexHullProducer.status==jt.Status.CLOSED&&await this.convexHullProducer.open();let s=await this.convexHullProducer.build(e,t,i);return this.getOutput(s)}reset(){super.reset(),this.lastPolygon=null}}class Yt{static union(e){let t=new tt(e);return t.subject=He.SimplifyPolygons(t.subject,Je.pftNonZero),t.solution=He.CleanPolygons(t.subject,.1*t.transform.scale),1==t.subject.length&&0==t.solution.first.length&&(t.solution=t.subject),t.toPolygon()}static simplify(e){let t,r=new Qe,i=this.createClipperPath(e);t=He.SimplifyPolygon(i,Je.pftNonZero),t=He.CleanPolygons(t,.1*i.scale);for(let e of t)0!=e.length&&r.push(xe.createSharedInstance(Yt.fromClipperPath(e,i.scale)));return r}static createClipperPath(e,t=32){let r=new qe;r.scale=t;for(let i=0;i<e.length;i++)r.push({X:Math.round(e.getPointX(i)*t),Y:Math.round(e.getPointY(i)*t)});return r}static fromClipperPath(e,t=e.scale||32){let r=Float32Array.createSharedInstance(2*e.length);for(let i=0;i<e.length;i++){let s=e[i],n=2*i;r[n]=s.X/t,r[n+1]=s.Y/t}return r}static containsPoint(e,t){let r={X:Math.round(t.x*e.scale),Y:Math.round(t.y*e.scale)};return 1==He.PointInPolygon(r,e)}}class Xt extends De{static ARRAY_TYPE=et;constructor(){super()}predict(e){return console.warn("Prediction merge is not recommended"),e}buildImpl(e){return this.merge(e)}merge(e){if(0!=e.length)return Yt.union(e)}}class zt extends De{static ARRAY_TYPE=et;constructor(e=.1){super(),this.epsilon=e}predict(e){return console.warn("Prediction simplify is not recommended"),e}buildImpl(e){return e instanceof xe?e.simplify(this.epsilon):new e.constructor(...e.map((e=>e.simplify(this.epsilon))))}}function Vt(){}Object.defineEnum(Vt,"Stage",["PATH_PRODUCER","SMOOTHER","SPLINE_PRODUCER","SPLINE_INTERPOLATOR","BRUSH_APPLIER","CONVEX_HULL_CHAIN_PRODUCER","POLYGON_MERGER","POLYGON_SIMPLIFIER"]);const Ht=Vt.Stage,Zt=x.Phase,qt=De.OutputType;var Wt=Object.freeze({__proto__:null,Stage:Ht,Phase:Zt,OutputType:qt,PathProducer:Ot,Smoother:Dt,SplineProducer:kt,DistanceBasedInterpolator:ut,CurvatureBasedInterpolator:_t,BrushApplier:Ft,ConvexHullChainProducer:Bt,ConvexHullChainProducerAsync:$t,PolygonMerger:Xt,PolygonSimplifier:zt});class Kt{constructor(e){this.phase=e.phase;let t=isNaN(e.altitude)||isNaN(e.azimuth)?void 0:{altitude:e.altitude,azimuth:e.azimuth};Object.defineProperty(this,"x",{value:e.x,enumerable:!0}),Object.defineProperty(this,"y",{value:e.y,enumerable:!0}),Object.defineProperty(this,"z",{value:e.z,enumerable:!0}),Object.defineProperty(this,"timestamp",{value:e.timestamp,enumerable:!0,writable:!0}),Object.defineProperty(this,"force",{value:e.pressure,enumerable:!0}),Object.defineProperty(this,"pressure",{value:e.pressure,enumerable:!0}),Object.defineProperty(this,"rotation",{value:e.rotation,enumerable:!0}),Object.defineProperty(this,"radiusX",{value:e.radiusX,enumerable:!0}),Object.defineProperty(this,"radiusY",{value:e.radiusY,enumerable:!0}),Object.defineProperty(this,"altitude",{get:()=>(t||(t=this.computeTilt(e)||{}),t.altitude),enumerable:!0}),Object.defineProperty(this,"azimuth",{get:()=>(t||(t=this.computeTilt(e)||{}),t.azimuth),enumerable:!0}),e.pointer&&Object.defineProperty(this,"pointer",{value:e.pointer,enumerable:!0}),this.computedAzimuth=void 0}createPathPoint(e){return new j(this.x,this.y,this.z,e)}computeTilt(e){if(isNaN(e.tiltX)||isNaN(e.tiltY))return;let{tiltX:t,tiltY:r}=e,i=Math.tan(Math.toRadians(t)),s=Math.tan(Math.toRadians(r)),n=Math.sqrt(i*i+s*s);return{altitude:Math.atan2(1,n),azimuth:Math.atan2(s,i)}}speed(e,t){let r={x:0,y:0,time:0};return r=e&&!t?this.minus(e):t&&!e?t.minus(this):t.minus(e),r.time>0?Kt.getMagnitude(r.x,r.y)/(r.time/1e3):(0==r.time||console.warn(`Speed out of range: ${r.time}ms`),0)}computeNearestAzimuthAngle(e){let t;if(isNaN(this.azimuth))return 0;if(e){if(isNaN(e.azimuth))return 0;let r=2*Math.PI,i=e.computedAzimuth||e.azimuth,s=parseInt(i/r);t=this.azimuth+s*r;let n=t-i;n>=Math.PI?t-=r:n<-Math.PI&&(t+=r)}else t=this.azimuth;return this.computedAzimuth=t,t}minus(e){return{x:this.x-e.x,y:this.y-e.y,time:this.timestamp-e.timestamp}}static getMagnitude(e,t){return Math.sqrt(e*e+t*t)}}Object.defineEnum(Kt,"Property",["X","Y","Z","PHASE","TIMESTAMP","PRESSURE","RADIUS_X","RADIUS_Y","ALTITUDE","AZIMUTH","ROTATION"]);class Jt{constructor(e=[],t=[]){this.accumulatedAddition=e,this.lastPrediction=t,this.first=!1,this.last=!1}add(e,t,r=[]){e==x.Phase.BEGIN?this.reset(!0):e==x.Phase.END&&(this.last=!0),t&&this.accumulatedAddition.push(...t),this.lastPrediction=r}clone(){let e=new Jt(this.accumulatedAddition.slice(),this.lastPrediction.slice());return e.first=this.first,e.last=this.last,e}reset(e=!1){this.first=e,this.last=!1,this.accumulatedAddition.clear(),this.lastPrediction.clear()}}const Qt=[Ht.SMOOTHER,Ht.POLYGON_MERGER,Ht.POLYGON_SIMPLIFIER],er=[Ht.SPLINE_INTERPOLATOR,Ht.BRUSH_APPLIER,Ht.CONVEX_HULL_CHAIN_PRODUCER,Ht.POLYGON_MERGER,Ht.POLYGON_SIMPLIFIER];class tr{constructor(){this.layout=[j.Property.X,j.Property.Y],this.pathSegment=new Jt,this.pathProducer=new Ot(this.layout),this.smoother=new Dt(this.layout.length),this.splineProducer=new kt(this.layout),this.distanceInterpolator=new ut,this.curvatureInterpolator=new _t,this.brushApplier=new Ft,this.polygonMerger=new Xt,this.polygonSimplifier=new zt,this.splineProducer.keepAllData=!0,this.phase=void 0,this.pointerID=void 0,this.concatSegments=!1,this.lastPipelineStage=void 0,this.excludedPipelineStages=[],this.configured=!1,Object.defineProperty(this,"prediction",{get:()=>this.pathProducer.prediction,set:e=>this.pathProducer.prediction=e,enumerable:!0})}configure(e={}){if(this.reset(this.pointerID),e.onBuildComplete)throw new Error("InkBuilderSettings onBuildComplete property is deprecated. Use InkBuilder instance onComplete property to set callback.");if("mergePrediction"in e&&console.warn("InkBuilderSettings 'mergePrediction' property is deprecated. Do not affects PolygonMerger behaviour."),!e.brush)throw new Error("InkBuilderSettings brush property is required");if(e.excludedPipelineStages){if(!Array.isArray(e.excludedPipelineStages))throw new Error("Expected type of excludedPipelineStages is Array instance");let t=e.excludedPipelineStages.filter((e=>!Qt.includes(e)));t.length>0&&console.warn(`excludedPipelineStages property includes steps which cannot be excluded: ${t.map((e=>e.name)).join(", ")}`),this.excludedPipelineStages=e.excludedPipelineStages}if(!this.excludedPipelineStages.includes(Ht.SMOOTHER)&&e.movingAverageWindowSize&&(this.smoother.movingAverageWindowSize=e.movingAverageWindowSize),e.lastPipelineStage){if(!er.includes(e.lastPipelineStage))throw new Error(`lastPipelineStage property expects one of: ${er.map((e=>e.name)).join(", ")}`);if(this.excludedPipelineStages.includes(e.lastPipelineStage))throw new Error(`lastPipelineStage ${e.lastPipelineStage.name} is disabled, check excludedPipelineStages configuration`);if(e.brush instanceof Ye&&e.lastPipelineStage!=Ht.SPLINE_INTERPOLATOR)throw new Error(`lastPipelineStage ${e.lastPipelineStage.name} is not compatible with provided brush`);this.lastPipelineStage=e.lastPipelineStage}switch(this.brush=e.brush,this.brush instanceof Oe&&(this.brushApplier.brush=this.brush),this.lastPipelineStage||(this.brush instanceof Oe?(this.brush.spacing>1?this.lastPipelineStage=Ht.BRUSH_APPLIER:this.excludedPipelineStages.includes(Ht.POLYGON_SIMPLIFIER)&&this.excludedPipelineStages.includes(Ht.POLYGON_MERGER)?this.lastPipelineStage=Ht.CONVEX_HULL_CHAIN_PRODUCER:this.lastPipelineStage=Ht.POLYGON_MERGER,this.lastPipelineStage==Ht.POLYGON_MERGER&&(this.concatSegments=Boolean(e.concatSegments))):this.lastPipelineStage=Ht.SPLINE_INTERPOLATOR),this.lastPipelineStage==Ht.SPLINE_INTERPOLATOR||this.lastPipelineStage==Ht.BRUSH_APPLIER?(this.splineInterpolator=this.distanceInterpolator,this.splineInterpolator.spacing=this.brush.spacing,this.splineInterpolator.scattering=this.brush.scattering,this.splineInterpolator.calculateDerivates=this.brush instanceof Ye):(this.splineInterpolator=this.curvatureInterpolator,this.splineInterpolator.errorThreshold=e.errorThreshold||.15),this.splineInterpolator.keepAllData=!1,this.brushApplier.keepAllData=!1,this.convexHullChainProducer.keepAllData=!1,this.polygonMerger.keepAllData=!1,this.polygonSimplifier.keepAllData=!1,this.lastPipelineStage){case Ht.SPLINE_INTERPOLATOR:this.splineInterpolator.keepAllData=!0;break;case Ht.BRUSH_APPLIER:this.brushApplier.keepAllData=!0;break;case Ht.CONVEX_HULL_CHAIN_PRODUCER:this.convexHullChainProducer.keepAllData=!0;break;case Ht.POLYGON_MERGER:this.polygonMerger.keepAllData=!0;break;case Ht.POLYGON_SIMPLIFIER:this.polygonSimplifier.keepAllData=!0;break;default:throw console.warn(this.lastPipelineStage),new Error("Invalid lastPipelineStage found")}if(this.lastPipelineStage==Ht.POLYGON_SIMPLIFIER&&(console.warn("InkBuilderSettings: Pipeline stage POLYGON_SIMPLIFIER is deprecated. POLYGON_MERGER stage is recommended as last stage."),this.polygonSimplifier.epsilon=e.epsilon||.1),e.pathPointCalculator&&(this.calculator=e.pathPointCalculator,this.pathProducer.pathPointCalculator=e.pathPointCalculator),!e.layout)throw new Error("InkBuilderSettings layout property is required");{let t=e.pathPointProps||{};if(this.layout=e.layout,this.brush instanceof Oe){if(this.layout.includes(j.Property.RED))throw new Error("RED layout channel is not supported for non particles strokes");if(this.layout.includes(j.Property.GREEN))throw new Error("GREEN layout channel is not supported for non particles strokes");if(this.layout.includes(j.Property.BLUE))throw new Error("BLUE layout channel is not supported for non particles strokes");if(this.layout.includes(j.Property.ALPHA))throw new Error("ALPHA layout channel is not supported for non particles strokes")}if(!this.layout.includes(j.Property.RED)&&isNaN(t.red))throw new Error("Stroke color red channel information is required. Please provide via layout or through configure settings via pathPointProps property.");if(!this.layout.includes(j.Property.GREEN)&&isNaN(t.green))throw new Error("Stroke color green channel information is required. Please provide via layout or through configure settings via pathPointProps property.");if(!this.layout.includes(j.Property.BLUE)&&isNaN(t.blue))throw new Error("Stroke color blue channel information is required. Please provide via layout or through configure settings via pathPointProps property.");if(!this.layout.includes(j.Property.ALPHA)&&isNaN(t.alpha))throw new Error("Stroke color alpha channel information is required. Please provide via layout or through configure settings via pathPointProps property.");this.pathProducer.layout=this.layout,this.smoother.dimsCount=this.layout.length,this.splineProducer.layout=this.layout,this.splineProducer.pathPointProps=t}this.configured=!0}add(e,t){if(!this.configured)throw new Error("InkBuilder instance is not configured yet, use configure method to configure the instance.");if(!this.calculator)throw new Error("InkBuilder instance is not configured properly, pathPointCalculator property is required");if(!e.phase)throw new Error("SensorPoint phase is not found");this.phase=e.phase;let r,i=new Kt(e);t&&(this.prediction?r=new Kt(t):console.warn("Prediction sensor point is available, but ignored, prediction is disabled")),this.device&&(this.phase==Ot.Phase.BEGIN&&this.device.openStream(e),this.device.add(i),this.phase==Ot.Phase.END&&(this.sensorData=this.device.closeStream()));let s=this.pathProducer.add(this.phase,i,r);this.pathSegment.add(this.phase,s.added,s.predicted)}ignore(e){if(!e.phase)throw new Error("SensorPoint phase is not found");this.device&&e&&e.phase==Ot.Phase.UPDATE&&this.device.add(new Kt(e),!0)}build(){throw new Error("InkBuilderAbstract.build() is abstract and should be implemented")}processSegment(e,t,r){throw new Error("InkBuilderAbstract.processSegment(path, type, lastSegment) is abstract and should be implemented")}getSensorData(){return this.sensorData}getSpline(){return this.splineProducer.allData}getInkPath(){let e;switch(this.lastPipelineStage){case Ht.SPLINE_INTERPOLATOR:e=this.splineInterpolator.allData;break;case Ht.BRUSH_APPLIER:e=this.brushApplier.allData;break;case Ht.CONVEX_HULL_CHAIN_PRODUCER:e=this.convexHullChainProducer.allData;break;case Ht.POLYGON_MERGER:e=this.polygonMerger.allData;break;case Ht.POLYGON_SIMPLIFIER:e=this.polygonSimplifier.allData;break;default:throw console.warn(this.lastPipelineStage),new Error("Invalid lastPipelineStage found")}if(this.concatSegments){let t;this.lastPipelineStage!=Ht.POLYGON_MERGER&&this.lastPipelineStage!=Ht.POLYGON_SIMPLIFIER||(t=this.polygonMerger.build(e)),this.lastPipelineStage==Ht.POLYGON_SIMPLIFIER&&(t=this.polygonSimplifier.build(t)),t&&(e=new et(t))}return e}abort(){this.device&&this.device.closeStream(!0),this.reset()}reset(e){this.pointerID=e,this.phase=void 0,this.concatSegments=!1,this.lastPipelineStage=void 0,this.excludedPipelineStages.clear(),this.sensorData=void 0,this.pathProducer.reset(),this.smoother.reset(),this.splineProducer.reset(),this.distanceInterpolator.reset(),this.curvatureInterpolator.reset(),this.brushApplier.reset(),this.convexHullChainProducer.reset(),this.polygonMerger.reset(),this.polygonSimplifier.reset(),this.configured=!1}}tr.Phase=Ot.Phase;class rr extends tr{constructor(){super(),this.convexHullChainProducer=new Bt}build(){let e=this.buildSegment();return e.phase=this.phase,e.pointerID=this.pointerID,this.onComplete&&this.onComplete(e),this.phase==Zt.END&&delete this.phase,e}buildSegment(){let e={};return this.pathSegment.accumulatedAddition.length>0&&(e.added=this.processSegment(this.pathSegment.accumulatedAddition,qt.ADDITION,this.pathSegment.last),e.added&&(e.added.segment=!0)),this.prediction&&this.pathSegment.lastPrediction.length>0&&(e.predicted=this.processSegment(this.pathSegment.lastPrediction,qt.PREDICTION,this.pathSegment.last),e.predicted&&(e.predicted.segment=!0)),this.pathSegment.reset(),e}processSegment(e,t,r){if(this.excludedPipelineStages.includes(Ht.SMOOTHER)||(e=this.smoother.build(e,t,r)),e=this.splineProducer.build(e,t,r))return this.processSpline(e,t,r)}processSpline(e,t=qt.PROCESSOR,r=!0){let i,s=this.splineInterpolator.build(e,t,r);if(this.lastPipelineStage==Ht.SPLINE_INTERPOLATOR)return s;if(s)return s=this.brushApplier.build(s,t,r),this.lastPipelineStage==Ht.BRUSH_APPLIER?s:(s=this.convexHullChainProducer.build(s,t,r),this.lastPipelineStage==Ht.CONVEX_HULL_CHAIN_PRODUCER||t==qt.PREDICTION?s:this.excludedPipelineStages.includes(Ht.POLYGON_MERGER)||(i=this.polygonMerger.build(s,t,r),this.lastPipelineStage!=Ht.POLYGON_MERGER)?(this.excludedPipelineStages.includes(Ht.POLYGON_SIMPLIFIER)||(i=this.polygonSimplifier.build(i,t,r)),new et(i)):new et(i));if(t==qt.PROCESSOR)throw new Error("InkBuilder processSpline failed for spline",e)}}class ir{constructor(){this.queue=Promise.resolve(),this.thenables=[]}then(e,t,r){return this.thenables.push(e),this.queue=this.queue.then(((...t)=>(this.thenables.shift(),e.canceled?Promise.resolve():e(...t)))),t&&this.then((e=>t(e,r))),this}catch(e){return this.queue=this.queue.catch(e),this}cancel(){this.thenables.forEach((e=>e.canceled=!0))}isEmpty(){return 0==this.thenables.length}static async serial(e,t){let r=new ir;return e.forEach(((e,i)=>r.then(e,t,i))),r.queue}}class sr extends tr{constructor(){super(),this.convexHullChainProducer=new $t,this.queue=new ir}onComplete(e){throw new Error("InkBuilderAbstract.onComplete(pathSegment) is abstract and should be implemented")}build(){if(this.buildPhase&&this.phase!=Zt.END)return;let e=this.phase;this.queue.then((()=>(this.buildPhase=e,this.buildSegment()))).then((t=>{this.buildPhase=null,t.phase=e,t.pointerID=this.pointerID,this.onComplete(t),e==Zt.END&&delete this.phase}))}async buildChain(){let e=await this.buildSegment();return e.phase=this.phase,e.pointerID=this.pointerID,this.onComplete(e),this.phase==Zt.END&&delete this.phase,e}async buildSegment(){let e={};return this.pathSegment.accumulatedAddition.length>0&&(e.added=await this.processSegment(this.pathSegment.accumulatedAddition,qt.ADDITION,this.pathSegment.last),e.added&&(e.added.segment=!0)),this.prediction&&this.pathSegment.lastPrediction.length>0&&(e.predicted=await this.processSegment(this.pathSegment.lastPrediction,qt.PREDICTION,this.pathSegment.last),e.predicted&&(e.predicted.segment=!0)),this.pathSegment.reset(),e}async processSegment(e,t,r){if(this.excludedPipelineStages.includes(Ht.SMOOTHER)||(e=this.smoother.build(e,t,r)),e=this.splineProducer.build(e,t,r))return this.processSpline(e,t,r)}async processSpline(e,t=qt.PROCESSOR,r=!0){let i,s=this.splineInterpolator.build(e,t,r);if(this.lastPipelineStage==Ht.SPLINE_INTERPOLATOR)return s;if(s)return s=this.brushApplier.build(s,t,r),this.lastPipelineStage==Ht.BRUSH_APPLIER?s:(s=await this.convexHullChainProducer.build(s,t,r),this.lastPipelineStage==Ht.CONVEX_HULL_CHAIN_PRODUCER||t==qt.PREDICTION?s:this.excludedPipelineStages.includes(Ht.POLYGON_MERGER)||(i=this.polygonMerger.build(s,t,r),this.lastPipelineStage!=Ht.POLYGON_MERGER)?(this.excludedPipelineStages.includes(Ht.POLYGON_SIMPLIFIER)||(i=this.polygonSimplifier.build(i,t,r)),new et(i)):new et(i));if(t==qt.PROCESSOR)throw new Error("InkBuilderAsync processSpline failed for spline",e)}abort(){this.buildPhase=null,this.queue.cancel(),super.abort()}}let nr,or,ar,lr;class hr extends I{constructor(e,t,r,i){let s,n,o,a;super(t.id),t.id||(t.id=this.id);let l=hr.RenderMode.SOURCE_OVER,h=hr.CompressionType.AUTO,d=new ue(t.layout,t.pointProps);Object.defineProperty(this,"target",{get:()=>console.warn("Stroke 'target' property is deprecated. Do not affects Stroke behaviour."),set:e=>console.warn("Stroke 'target' property is deprecated. Do not affects Stroke behaviour.")});let c=!0;Object.defineProperty(this,"layout",{value:t.layout,enumerable:!0}),Object.defineProperty(this,"points",{get:()=>t.points,enumerable:!0}),Object.defineProperty(this,"pointProps",{value:t.pointProps,enumerable:!0}),Object.defineProperty(this,"style",{value:d.style,enumerable:!0}),Object.defineProperty(this,"ts",{value:t.ts,enumerable:!0}),Object.defineProperty(this,"tf",{value:t.tf,enumerable:!0}),Object.defineProperty(this,"stride",{value:t.stride,enumerable:!0}),Object.defineProperty(this,"length",{value:t.length,enumerable:!0}),Object.defineProperty(this,"segmentsCount",{value:t.segmentsCount,enumerable:!0}),Object.defineProperty(this,"color",{get:()=>d.style.color,set:e=>{t.color=e,r&&(r.color=e)},enumerable:!0}),Object.defineProperty(this,"sensorData",{get:()=>i,set:e=>{if(i)throw new Error("sensorData is immutable");i=e}}),Object.defineProperty(this,"spline",{value:t,enumerable:!0}),Object.defineProperty(this,"path",{get:()=>(r||this.buildPath(),r),set:e=>{(r=e)instanceof ht&&(r.style=d.style),this.bounds=null},enumerable:!0}),Object.defineProperty(this,"pathValue",{get:()=>r}),Object.defineProperty(this,"bounds",{get:()=>(n||(n=this.path.bounds),this.matrix?n.transform(this.matrix).ceil():n),set:e=>n=e,enumerable:!0}),Object.defineProperty(this,"descriptor",{value:{brush:{}},enumerable:!0}),Object.defineProperty(this,"brush",{get:()=>(e||(e=this.descriptor.brush.value),e),set:r=>{if(c||(this.path=null),"string"==typeof r?r=new ne(r):r instanceof Oe||r instanceof Ye?r=new ne(r.name,r):r instanceof ne||(r=new ne(r.name,r.value)),r instanceof Ye&&!t.randomSeed)throw new Error("Spline do not provides randomSeed. Raster rendering requires it.");e=null,this.descriptor.brush=r},enumerable:!0}),Object.defineProperty(this,"randomSeed",{get:()=>o,set:e=>{if(o)throw new Error("randomSeed is immutable");o=e},enumerable:!0}),Object.defineProperty(this,"renderMode",{get:()=>l,set:e=>{if(!e)throw new Error("Stroke renderMode is required");if(!L.isValidURL(e))throw new Error(`The renderMode ${e} is not a well formed URI`);l=e}}),Object.defineProperty(this,"blendMode",{get:()=>hr.RenderMode.getBlendMode(l),set:e=>{if(!this.blendMode)throw new Error(`Override user defined renderMode '${this.renderMode}' is not allowed.`);this.renderMode=hr.RenderMode.get(e)}}),Object.defineProperty(this,"precisionSchema",{get:()=>a,set:e=>{if(a)throw new Error("precisionSchema is immutable, precisionSchema.update(schema) is an alternative");if(e){if(!(e instanceof Rt))throw new Error("Expected precisionSchema type is PrecisionSchema");a=e,h=hr.CompressionType.COMPUTED}else h=hr.CompressionType.NONE}}),Object.defineProperty(this,"compressionType",{get:()=>h,set:e=>{if(!e)throw new Error("Stroke compressionType is required");if(h==hr.CompressionType.COMPUTED&&e==hr.CompressionType.NONE)throw new Error("compressionType NONE is not applicable for compressed stroke");h=e,this.invalidatePrecisionSchema&&(delete this.invalidatePrecisionSchema,a=void 0)}}),Object.defineProperty(this,"uri",{get:()=>(s||(s=J.createStrokeURI(this.id)),s),enumerable:!0}),this.brush=e,this.path=r,this.sensorDataOffset=0,this.sensorDataMapping=[],c=!1}buildPath(){if(this.pathProceessInProgress)throw new Error("Init process in progress. Await init stroke.");nr||(nr=new rr),nr.configure(this.buildInkBuilderSettings()),this.path=nr.processSpline(this.spline)}async init(e){this.pathProceessInProgress=!0,or||(or=new sr),or.configure(this.buildInkBuilderSettings(e)),this.path=await or.processSpline(this.spline),delete this.pathProceessInProgress}buildInkBuilderSettings(e){return hr.onPipeline?hr.onPipeline(this):Object.assign({},{brush:this.brush,layout:this.layout,pathPointProps:this.pointProps},e)}invalidateBounds(){this.bounds=null}clone(){let e=new hr(this.descriptor.brush,this.spline.clone(),void 0,this.sensorData);return e.randomSeed=this.randomSeed,e.renderMode=this.renderMode,e.sensorDataOffset=this.sensorDataOffset,e.sensorDataMapping=this.sensorDataMapping.clone(),e}getSensorPoint(e){if(e>=this.length||e<0)throw new Error(`Index ${e} out of range - (0, ${this.length-1})`);let t;if(this.sensorData){let r=this.sensorData.inkStream;if(r){let i;this.sensorDataMapping.length>0?i=e>=this.sensorDataMapping.length?this.sensorDataMapping.last:this.sensorDataMapping[e]:(i=this.sensorDataOffset+e,i>=r.length&&(i=r.length-1)),t=r.get(i),t.index=i,t.timespan=t.timestamp,t.timestamp+=this.sensorData.created}}return t}getPoint(e){return this.spline.getPoint(e)}setPoint(e,t){let r=e*this.stride;this.layout.forEach(((e,i)=>this.points[r+i]=t.getProperty(e)))}pointAt(e){return this.getPoint(e)}getSegment(e){return this.spline.getSegment(e)}getAverageWidth(){let e=0;if(this.layout.includes(j.Property.SIZE)){let t=0;for(let e=0;e<this.length;e++)t+=this.getPoint(e).size;e=t/this.length}else e=this.pointProps.size;return e}split(e){let t=e.map((e=>this.slice(e)));return t.includes(this)||0==t.length?void 0:t}slice(e){let{fromPointIndex:t,toPointIndex:r,fromTValue:i,toTValue:s}=e;if(0==t&&r+1==this.length&&i==this.ts&&s==this.tf)return this;{let i=this.spline.slice(e),s=new hr(this.descriptor.brush,i,void 0,this.sensorData);return e.id||(e.id=s.id),s.randomSeed=this.randomSeed,s.renderMode=this.renderMode,this.sensorData&&(s.sensorDataOffset=this.sensorDataOffset+t,this.sensorDataMapping.length>0?s.sensorDataMapping=this.sensorDataMapping.slice(t,r+1):s.sensorDataMapping=[]),s}}subStroke(e){return console.warn("Stroke subStroke method is deprecated. Use Stroke instance slice method instead."),this.slice(e)}transform(e){e||(e=this.matrix,this.matrix=null),e&&(this.spline.transform(e),this.pathValue&&this.path.transform(e),this.compressionType!=hr.CompressionType.NONE&&(this.invalidatePrecisionSchema=!0,this.compressionType=hr.CompressionType.AUTO),this.bounds=null)}setTransform(e){this.matrix=e}static createInstance(e,t,r,i={},s,n=0,o=1){let a=i.id,l=i.color;a&&delete i.id,l&&(delete i.color,i=Object.assign({},i),r.includes(j.Property.RED)||(i.red=l.red),r.includes(j.Property.GREEN)||(i.green=l.green),r.includes(j.Property.BLUE)||(i.blue=l.blue),r.includes(j.Property.ALPHA)||(i.alpha=l.alpha));let h=new lt(r,t,i,n,o);h.id=a;let d=new hr(e,h);return d.randomSeed=s,d}static validatePath(e){if(!e)return!1;if(0==e.length)return!1;if(e instanceof et)return!0;if(Array.isArray(e))throw new Error("path should be instance of InkPath2D");let t=!1,r=0,i=!1,{size:s,red:n,green:o,blue:a,alpha:l}=e.pointProps;if(!(e instanceof ht)){let t=e.points.length,s=e.layout.length;i=0==t||t<4*s,r=t%s}return 0!=r?console.error(`The points array (length: ${e.points.length}) does not refer to provided layout (${e.layout.map((e=>e.name)).join(", ")})`):i?console.error("Less than needed minimum of points passed (At least 4 points are needed to define a path)!"):!e.layout.includes(j.Property.SIZE)&&isNaN(s)?console.error("Either the size property must be set or the path layout must include a SIZE property"):!e.layout.includes(j.Property.RED)&&isNaN(n)?console.error("Either the color property must be set or the path layout must include a RED property"):!e.layout.includes(j.Property.GREEN)&&isNaN(o)?console.error("Either the color property must be set or the path layout must include a GREEN property"):!e.layout.includes(j.Property.BLUE)&&isNaN(a)?console.error("Either the color property must be set or the path layout must include a BLUE property"):!e.layout.includes(j.Property.ALPHA)&&isNaN(l)?console.error("Either the color property must be set or the path layout must include a ALPHA property"):t=!0,t}static decodeInkPath(e){if("InkPath2D"==e.type)return et.fromJSON(e);if("InterpolatedSpline"==e.type)return ht.fromJSON(e);throw new Error(`Decode ink path faild. Cannot identify type: ${e.type}`)}}hr.RenderMode=Object.assign({},...Object.keys(Ne).map((e=>({[e]:`will://rasterization/3.0/blend-mode/${L.getPropName(e,!0)}`})))),hr.RenderMode.get=e=>hr.RenderMode[L.getEnumValueName(e.replace(/-/g,"_"))],hr.RenderMode.getBlendMode=e=>Ne[Object.keys(hr.RenderMode).filter((t=>hr.RenderMode[t]==e)).first],hr.Target={},Object.defineProperty(hr.Target,"2D",{get:()=>console.warn("Stroke 'Target[2D]' enum is deprecated")}),Object.defineProperty(hr.Target,"GL",{get:()=>console.warn("Stroke 'Target[GL]' enum is deprecated")}),Object.defineEnum(hr,"CompressionType",["AUTO","NONE","COMPUTED"]);class dr{constructor(){let e;this.statistics={},this.statisticCounts={},Object.defineProperty(this,"calculator",{get:()=>e,set:t=>{if(e&&!(e instanceof wt))throw new Error("calculator should be instance of PrecisionCalculator");e=t},enumerable:!0})}determinePrecisions(e){this.reset();for(let t of e)this.updatePrecisionSchema(t);this.printStats()}updatePrecisionSchema(e){let t=this.determinePrecisionSchema(e);e.precisionSchema?e.precisionSchema.update(t):e.precisionSchema=t}determinePrecisionSchema(e){if(e.compressionType!=hr.CompressionType.AUTO)return;if(!this.calculator)throw new Error("PrecisionDetector calculator property is required");let t=Number.MAX_SAFE_INTEGER,r=Number.MAX_SAFE_INTEGER,i=Number.MAX_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,n=Number.MAX_SAFE_INTEGER;for(let o of e.layout){let a,l=e.spline.getChannelData(o),h=this.calculator.calculatePrecision(l,o);switch(o){case j.Property.X:case j.Property.Y:case j.Property.Z:a=dr.StatType.POSITION,t=Math.min(h,t);break;case j.Property.SIZE:a=dr.StatType.SIZE,r=Math.min(h,r);break;case j.Property.ROTATION:a=dr.StatType.ROTATION,i=Math.min(h,i);break;case j.Property.SCALE_X:case j.Property.SCALE_Y:case j.Property.SCALE_Z:a=dr.StatType.SCALE,s=Math.min(h,s);break;case j.Property.OFFSET_X:case j.Property.OFFSET_Y:case j.Property.OFFSET_Z:a=dr.StatType.OFFSET,n=Math.min(h,n);break;default:continue}if(this.debug){let e=At.calculateError(l,h);this.addSampleStatistics(a,h,e,Math.min(...l),Math.max(...l))}}t==Number.MAX_SAFE_INTEGER&&(t=0),r==Number.MAX_SAFE_INTEGER&&(r=0),i==Number.MAX_SAFE_INTEGER&&(i=0),s==Number.MAX_SAFE_INTEGER&&(s=0),n==Number.MAX_SAFE_INTEGER&&(n=0);let o=Rt.encode({position:t,size:r,rotation:i,scale:s,offset:n});return new Rt(o)}addSampleStatistics(e,t,r,i,s){if(!this.debug)return;e!=dr.StatType.TOTAL&&this.addSampleStatistics(dr.StatType.TOTAL,t,r,i,s);let n=e.name;n in this.statistics||(this.statistics[n]={},this.statisticCounts[n]=0),t in this.statistics[n]||(this.statistics[n][t]={samplesCount:0,totalError:0,minError:Number.MAX_SAFE_INTEGER,maxError:0,sampleMinVal:Number.MAX_SAFE_INTEGER,sampleMaxVal:Number.MIN_SAFE_INTEGER}),this.statistics[n][t].samplesCount+=1,this.statistics[n][t].totalError+=r,this.statistics[n][t].minError=Math.min(this.statistics[n][t].minError,r),this.statistics[n][t].maxError=Math.max(this.statistics[n][t].maxError,r),this.statistics[n][t].sampleMinVal=Math.min(this.statistics[n][t].sampleMinVal,i),this.statistics[n][t].sampleMaxVal=Math.max(this.statistics[n][t].sampleMaxVal,s),this.statisticCounts[n]+=1}printStats(){this.debug&&(Object.keys(this.statistics).forEach((e=>{Object.values(this.statistics[e]).forEach((t=>{t.meanTotalError=t.samplesCount>0?t.totalError/t.samplesCount:NaN,t.usage=this.statisticCounts[e]>0?t.samplesCount/this.statisticCounts[e]*100:NaN}));let t=Object.keys(this.statistics[e]).sort(((e,t)=>e>t));console.log("***********************************************************************"),t.forEach((t=>{let r=this.statistics[e][t];console.log(`Stat Type: ${e} | Precision: ${t}`),console.log(` -> Count: ${r.samplesCount} (${r.usage}%)`),console.log(` -> Min/Max Error: ${r.minError} / ${r.maxError}`),console.log(` -> Sample Min/Max Value: ${r.sampleMinVal} / ${r.sampleMaxVal}`),console.log(` -> TotalError: ${r.totalError} / ${r.meanTotalError} (mean)`)}))})),console.log("***********************************************************************"))}reset(){this.statistics={},this.statisticCounts={}}}Object.defineEnum(dr,"StatType",["TOTAL","POSITION","SIZE","ROTATION","SCALE","OFFSET"]);class cr{constructor(e,t=cr.Type.UNKNOWN,r={}){this.uri=e,this.type=t,this.ontologyType,this.instance,this.internalID=r.internalID,this.externalModelID=r.modelID,this.isGloballyUnique=!!r.isGloballyUnique,this.belongsToCurrentModel=!!r.belongsToCurrentModel,this.triples=[],this.referencedEntities=[],this.referencedByEntities=[]}printDebugInfo(e=""){console.log(`${e}----------------------------------------------------------------`),console.log(`${e}EntityURI: ${this.uri}`),console.log(`${e}Type: ${this.type}`),console.log(`${e}OntologyType: ${this.ontologyType}`),console.log(`${e}InternalEntityID: ${this.internalID}`),console.log(`${e}ExternalModelID: ${this.externalModelID}`),console.log(`${e}EntityInstance:`,this.instance),console.log(`${e}IsGloballyUnique: ${this.isGloballyUnique}`),console.log(`${e}BelongsToCurrentModel: ${this.belongsToCurrentModel}`),console.log(`${e}ReferencedEntities: ${this.referencedEntities.length}`),this.referencedEntities.forEach((t=>console.log(`${e} -> ${t.uri}`))),console.log(`${e}ReferencedByEntities: ${this.referencedByEntities.length}`),this.referencedByEntities.forEach((t=>console.log(`${e} -> ${t.uri}`)))}}Object.defineEnum(cr,"Type",["UNKNOWN","NODE","STROKE","NAMED_ENTITY"]);class ur{constructor(e){this.model=e,this.entities={},this.entityDetector={[cr.Type.NODE]:{regEx:new RegExp(/^(uim:node)(\/[a-zA-Z0-9-]{36})?(\/[a-zA-Z0-9-_]{1,})?\/([a-zA-Z0-9-]{36})(#chunk=[0-9]+,[0-9]+)?$/),entityIDGroupIndex:0,modelIDGroupIndex:2},[cr.Type.STROKE]:{regEx:new RegExp(/^(uim:stroke)(\/[a-zA-Z0-9-]{36})?(\/)([a-zA-Z0-9-]{36})$/),entityIDGroupIndex:4,modelIDGroupIndex:2},[cr.Type.NAMED_ENTITY]:{regEx:new RegExp(/^(uim:ne)(\/[a-zA-Z0-9-]{36})?(\/)([a-zA-Z0-9-]{36})$/),entityIDGroupIndex:0,modelIDGroupIndex:2}}}clean(){this.analyze(),this.cleanupInternals(),this.cleanupUnusedEntities()}analyze(){let e={};this.model.knowledgeGraph.forEach((t=>{let r=e[t.subject];r||(r=this.determineEntityBasedOnURI(t.subject),e[t.subject]=r),r.triples.includes(t)||r.triples.push(t)})),Object.values(e).forEach((e=>{if(e.internalID&&e.belongsToCurrentModel)switch(e.type){case cr.Type.NODE:e.instance=this.model.getNode(e.internalID);break;case cr.Type.STROKE:e.instance=this.model.getStroke(e.internalID)}})),Object.values(e).forEach((t=>{t.triples.forEach((r=>{let i=e[r.object];i&&(t.referencedEntities.includes(i)||t.referencedEntities.push(i),i.referencedByEntities.includes(t)||i.referencedByEntities.push(t))}));let r=t.triples.filter((e=>e.predicate==ur.CommonRDF.HAS_TYPE||"@"==e.predicate)).first;r&&(t.ontologyType=r.object)})),this.entities=e,this.debug&&this.printStats()}determineEntityBasedOnURI(e){let t=cr.Type.UNKNOWN,r={},i=Object.keys(this.entityDetector);for(let s of i){t=cr.Type[s];let i=this.entityDetector[s],n=i.regEx.exec(e);if(n){let e=n[i.entityIDGroupIndex],t=n[i.modelIDGroupIndex];if(!e)throw new Error("Failed to extract internal ID");t&&(t=t.substring(1)),r={internalID:e,externalModelId:t,isGloballyUnique:!!t,belongsToCurrentModel:!t||this.model.id&&this.model.id==t};break}}return new cr(e,t,r)}cleanupInternals(){let e=new Set,t=[cr.Type.NODE,cr.Type.STROKE];Object.values(this.entities).forEach((r=>{t.includes(r.type)&&r.belongsToCurrentModel&&!r.instance&&e.add(r.uri)})),e.size>0&&(this.debug&&console.log(`[KnowledgeGraphAnalyzer] Cleanup internals - ${e.size}: ${Array.from(e).join(", ")}`),this.model.knowledgeGraph.remove((t=>e.has(t.subject)||e.has(t.object))),this.analyze())}cleanupUnusedEntities(){let e=new Set;Object.values(this.entities).forEach((t=>{t.type!=cr.Type.NAMED_ENTITY||!t.belongsToCurrentModel||t.referencedByEntities.length>0||e.add(t.uri)})),e.size>0&&(this.debug&&console.log(`[KnowledgeGraphAnalyzer] Cleanup unused entities - ${e.size}: ${Array.from(e).join(", ")}`),this.model.knowledgeGraph.remove((t=>e.has(t.subject)||e.has(t.object))),this.analyze())}printStats(){let e=0,t=Object.values(this.entities);console.log(`[KnowledgeGraphAnalyzer] Print ${t.length} entities analysis`),t.forEach((r=>r.printDebugInfo(`[${++e}/${t.length}] `)))}}ur.CommonRDF={HAS_TYPE:"http://www.w3.org/1999/02/22-rdf-syntax-ns#type",LOCALE:"http://ogp.me/ns#locale"},Object.defineProperty(globalThis,"DIGITAL_INK_DEBUG",{get:()=>ar,set:function(e){ar=e||{},U.debug=ar.InputListener,x.prototype.debug=ar.Pipeline,De.prototype.debug=ar.Pipeline,Ce.prototype.debug=ar.PathPointContext,tt.prototype.debug=ar.ClipperContext,yt.prototype.debug=ar.RTree,pt.prototype.debug=ar.HolesBuilder,ze.prototype.debug=ar.GL,It.prototype.debug=ar.RIFF,xt.prototype.debug=ar.RIFF,dr.prototype.debug=ar.PrecisionDetector,ur.prototype.debug=ar.KnowledgeGraphAnalyzer},enumerable:!0,configurable:!0});class pr extends jt{static WORKER_NAME="InkPathProvider";constructor(){super(pr.WORKER_NAME,pr.buildWorkerURL(),jt.WorkerType.CLASSIC),this.actions={}}static buildWorkerURL(){if(("undefined"==typeof document?new(require("url").URL)("file:"+__filename).href:document.currentScript&&document.currentScript.src||new URL("digital-ink-min.cjs",document.baseURI).href).contains("/wacom-src/"))return`/node_modules/digital-ink/workers/${pr.WORKER_NAME}.js`;if("function"!=typeof DedicatedWorkerGlobalScope){let e="undefined"==typeof __location?"undefined"==typeof document?new(require("url").URL)("file:"+__filename).href:document.currentScript&&document.currentScript.src||new URL("digital-ink-min.cjs",document.baseURI).href:__location;return e=e.substring(0,e.lastIndexOf("/")),e.endsWith("workers")||(e+="/workers"),e+=`/${pr.WORKER_NAME}`,"undefined"==typeof navigator?e+=".mjs":e+=".js",e}}async importBrushes(e){let t=this.nextID;return this.actions[t]={expected:this.workers.length},await this.broadcastMessage({action:"IMPORT_BRUSHES",actionID:t,brushes:e.map((e=>e.toJSON()))})}async build(e){if(0==e.length)return;let t=this.nextID;return this.actions[t]={strokes:e,queue:e.slice(),expected:e.length},this.updateProgress(0,e.length),await this.broadcast("BUILD",t)}buildRequestMessage(e,t){let r={action:e,actionID:t},i=this.actions[t];if("BUILD"!=e)throw new Error(`Unknow data action found: ${e}`);{let e=i.queue.shift();if(!e)return;e.spline.points.buffer instanceof ArrayBuffer&&this.transferables.push(e.spline.points.buffer),e.spline.encoding=se.Encoding.NONE,r.index=i.strokes.indexOf(e),r.brushName=e.brush.name,r.spline=e.spline.toJSON()}return r}recieve(e){let t=this.actions[e.actionID];switch(t.expected--,e.action){case"IMPORT_BRUSHES":break;case"BUILD":if(this.update(e.actionID,e.index,e.path,e.splineBuffer),t.expected>0){let t=this.buildRequestMessage(e.action,e.actionID);t&&this.send(e.worker,t)}break;default:throw new Error(`Unknow data action found: ${e.action}`)}0==t.expected&&(delete this.actions[e.actionID],this.resolve(e.actionID))}update(e,t,r,i){let s=this.actions[e],n=s.strokes[t];i instanceof ArrayBuffer&&(n.spline.buffer=i),n.path=hr.decodeInkPath(r);let o=100*(s.strokes.length-s.expected)/s.strokes.length;this.updateProgress(o,s.expected,n)}updateProgress(e,t,r){}}if($.type2D==$.Type2D.OFFSCREEN)if($.commonJS){const{Canvas:e,ImageData:t,Image:r}=require("canvas");global.OffscreenCanvas=e,global.ImageData=t,global.Image=r}else console.warn(`Current env - ${$.type.name}, do not provides OffscreenCanvas support`);class fr extends Le{get width(){return this.surface.width}get height(){return this.surface.height}constructor(e){super(),Object.defineProperty(this,"surface",{value:e.canvas,enumerable:!0}),Object.defineProperty(this,"ctx",{value:e,enumerable:!0}),Object.defineProperty(this,"renderingContext",{value:new at(e),enumerable:!0}),Object.defineProperty(this,"bounds",{get:()=>new v(0,0,this.width,this.height),enumerable:!0}),this.ctx.getContextAttributes||(this.ctx.getContextAttributes=()=>({}))}clear(e,t){if(t){if(ce.isColor(e))throw new Error("`clear` first argument should be Rectangle")}else ce.isColor(e)&&(t=e,e=null);e||(e=this.bounds),this.ctx.clearRect(e.left,e.top,e.width,e.height),t&&(this.ctx.fillStyle=t.toString(),this.ctx.fillRect(e.left,e.top,e.width,e.height))}draw(e){return this.drawStroke(e.brush,e.path,e.color,e.matrix)}drawStroke(e,t,r,i){if(!hr.validatePath(t))return null;if(!(e instanceof Oe))throw new Error("Incompatible brush found. It should be Brush2D instance.");i?this.matrix&&(i=this.matrix.multiply(i)):i=this.matrix;let s=t.bounds;if(s&&(i&&(s=s.transform(i)),s=s.ceil()),s=this.bounds.intersect(s),s){if(this.ctx.save(),i?this.ctx.setTransform(i.a,i.b,i.c,i.d,i.tx,i.ty):(this.ctx.rect(s.left,s.top,s.width,s.height),this.ctx.clip()),t instanceof et)this.renderingContext.fillShape(t,r),e.pattern&&this.renderingContext.fillShape(t,e.pattern);else{if(!(t instanceof ht))throw new Error("drawStroke 'path' type missmatch, expected oneof(InkPath2D, InterpolatedSpline)");this.drawSpline(t,r)}this.ctx.restore()}return s}drawSpline(e,t){t||(t=e.color),this.ctx.fillStyle=`rgb(${t.red}, ${t.green}, ${t.blue})`;for(let t=0;t<e.length;t++){let r=e.getPoint(t),i=r.size/2;this.ctx.beginPath(),this.ctx.arc(r.x,r.y,i,0,2*Math.PI),this.ctx.closePath(),this.ctx.fill()}}fill(e,t){let r;if(v.isRect(e))r=e;else{if("number"==typeof e[0]&&e.length%2==0&&(e=xe.createInstance(e)),e instanceof xe)e=new Qe(e);else if(!(e instanceof Qe))throw new Error("fill shape type missmatch, expected oneof(PolygonArray, Polygon, Rect)");r=e.bounds}return r=this.bounds.intersect(r),r&&(r=r.ceil(),this.ctx.fillStyle=t.toString(),v.isRect(e)?this.ctx.fillRect(e.left,e.top,e.width,e.height):(this.ctx.save(),this.ctx.rect(r.left,r.top,r.width,r.height),this.ctx.clip(),this.renderingContext.fillShape(e),this.ctx.restore())),r}blend(e,t={}){if(t.mode||(t.mode=Ne.SOURCE_OVER),t.transform&&t.destinationRect)throw new Error("`destinationRect` is not applicable with `transform`");if(t.sourceRect&&!t.destinationRect)throw new Error("With `sourceRect`, `destinationRect` is required");if(t.destinationRect&&!t.sourceRect)throw new Error("With `destinationRect`, `sourceRect`is required");t.rect&&(t.sourceRect=t.rect,t.destinationRect=t.rect),this.ctx.save(),t.transform?this.ctx.setTransform(t.transform.a,t.transform.b,t.transform.c,t.transform.d,t.transform.tx,t.transform.ty):t.clipRect&&(this.ctx.rect(t.clipRect.left,t.clipRect.top,t.clipRect.width,t.clipRect.height),this.ctx.clip()),this.ctx.globalCompositeOperation=t.mode,t.sourceRect&&t.destinationRect?this.ctx.drawImage(e.ctx.canvas,t.sourceRect.left,t.sourceRect.top,t.sourceRect.width,t.sourceRect.height,t.destinationRect.left,t.destinationRect.top,t.destinationRect.width,t.destinationRect.height):this.ctx.drawImage(e.ctx.canvas,0,0),this.ctx.restore()}createImageData(e,t,r){return new ImageData(e,t,r)}getImageData(e){e||(e=this.bounds);let t=this.ctx.getImageData(e.x,e.y,e.width,e.height);return t.x=e.x,t.y=e.y,t}putImageData(e,t,r){if(!(e instanceof ImageData))throw new Error("putImageData 'imageData' parameter is not instance of ImageData");(isNaN(t)||isNaN(r))&&(t=e.x||0,r=e.y||0),this.ctx.putImageData(e,t,r)}readPixels(e){return this.getImageData(e).data}writePixels(e,t){if(!(e instanceof Uint8Array||e instanceof Uint8ClampedArray))throw new Error("writePixels 'data' parameter is not instance of Uint8Array or Uint8ClampedArray");t||(t=this.bounds),e instanceof Uint8Array&&(e=new Uint8ClampedArray(e.buffer)),this.putImageData(this.createImageData(e,t.width,t.height),t.x,t.y)}getExportCanvas(e){let t=this.surface;return e&&(e=e.intersect(this.bounds).ceil(),t=new OffscreenCanvas(e.width,e.height),t.getContext("2d").putImageData(this.getImageData(e),0,0)),t}resize(e,t){this.surface.width=e,this.surface.height=t}}class mr extends fr{constructor(e){super(e)}createLayer(e,t){let r;r=e&&t?{width:e,height:t}:e&&e.width&&e.height?e:mr.getDefaultSize(this.width,this.height);let i=new OffscreenCanvas(r.width,r.height);return new fr(i.getContext("2d",this.ctx.getContextAttributes()))}static createInstance(e,t,r,i){if(!e||"function"!=typeof e.getContext)throw new Error("CanvasRenderingContext2D context provider is required");if(t>0&&r>0&&(e.width=t,e.height=r),!(e.width>0&&e.height>0))throw new Error("width and height are required and should be positive whole numbers");return new mr(e.getContext("2d",i))}}class gr{constructor(e,t){this.canvas=e,this.layer=e.createLayer(t),this.preliminaryLayer=void 0,this.restart=!0,this.runtime=!1,this.brush=void 0,this.color=void 0,this.backgroundColor=ce.TRANSPERENT,this.blendMode=Ne.SOURCE_OVER,this.matrix=void 0,this.strokeBounds=void 0,this.updatedArea=void 0,Object.defineProperty(this,"settings",{get:()=>({brush:this.brush,color:this.color,backgroundColor:this.backgroundColor,blendMode:this.blendMode,matrix:this.matrix,randomSeed:this.initialRandomSeed}),enumerable:!0})}configure(e){e.brush&&(this.brush=e.brush),e.color&&(this.color=e.color),e.backgroundColor&&(this.backgroundColor=e.backgroundColor),e.blendMode&&(this.blendMode=e.blendMode),"transform"in e&&this.setTransform(e.transform),this.restart=!0}setTransform(e){this.matrix=e,this.layer.setTransform(e),this.preliminaryLayer&&this.preliminaryLayer.setTransform(e)}draw(e,t=!1){e instanceof hr?(this.reset(!1),this.drawStroke(e),this.restart=!0):(this.restart&&this.reset(!0),this.drawSegment(e,t),t&&(this.restart=!0))}drawStroke(e){throw new Error("StrokeRenderer.drawStroke(stroke) should be implemented")}drawSegment(e,t=!1){throw new Error("StrokeRenderer.drawSegment(path, endStroke) should be implemented")}drawPreliminary(e){throw new Error("StrokeRenderer.drawPreliminary(path) should be implemented")}abort(){this.restart=!0}reset(e=!1){this.runtime=e,this.incompleteStrokeBounds=null,this.strokeBounds=null,this.updatedArea=null,this.preliminaryDirtyArea=null,this.layer.clear(this.backgroundColor),this.preliminaryLayer&&this.preliminaryLayer.clear(this.backgroundColor),this.restart=!1}validate(e){if(!this.brush)throw new Error("StrokeRenderer requires 'brush' to be configured");return e&&e.length>0}blendUpdatedArea(e){throw new Error("StrokeRenderer.blendUpdatedArea(layer) should be implemented")}blendStroke(e,t,r){throw new Error("StrokeRenderer.blendStroke(layer, dirtyArea, blendMode) should be implemented")}toStroke(e){throw new Error("StrokeRenderer.toStroke(builder) should be implemented")}}$.typeGL==$.TypeGL.STACK&&($.commonJS?lr=require("gl"):console.warn(`Current env - ${$.type.name}, do not provides WebGL support`));var yr=lr;var br=yr?class{constructor(e=300,t=150){this.width=e,this.height=t}getContext(e="webgl",t){if(!this.context){let e=this.width,r=this.height;this.context=yr(e,r,t),this.context.canvas=this;let i=this.context.getExtension("STACKGL_resize_drawingbuffer");Object.defineProperty(this,"width",{get:()=>e,set:t=>{e=t,i.resize(e,r)},enumerable:!0}),Object.defineProperty(this,"height",{get:()=>r,set:t=>{r=t,i.resize(e,r)},enumerable:!0})}return this.context}destroy(){if(this.context){this.context.getExtension("STACKGL_destroy_context").destroy(),delete this.context}}}:void 0;class Er{constructor(e){this.randomSeed=e||parseInt(Date.now()/1e3)}copyTo(e){e.randomSeed=this.randomSeed}}class Pr extends Fe{constructor(e,t){super(e.inkGLContext,t),Object.defineProperty(this,"inkContext",{value:e,enumerable:!0}),Object.defineProperty(this,"bounds",{get:()=>v.fromGLRect(this.graphicsBounds),enumerable:!0})}clear(e,t){if(t){if(ce.isColor(e))throw new Error("`clear` first argument should be Rect")}else ce.isColor(e)?(t=e,e=null):t=ce.TRANSPERENT;let r;if(v.isRect(e)){if(!e.intersect(this.bounds))return;r=v.fromRect(e).toGLRect()}Array.isArray(e)||e instanceof Float32Array?this.fill(e,t,!1):(this.inkContext.setTarget(this,r),this.inkContext.clearColor(t)),r&&this.inkContext.disableTargetClipRect()}draw(e){let t,r=e.brush;return r instanceof Ye?isFinite(e.randomSeed)&&(t=new Er(e.randomSeed)):t=e.color,this.drawStroke(r,e.path,t)}drawStroke(e,t,r){if(!hr.validatePath(t))return null;this.inkContext.setTarget(this);let i=this.inkContext.drawStroke(e,t,r);return v.fromGLRect(i)}fill(e,t,r=!0){if(v.isRect(e))e=xe.fromRect(e),e=new Qe(e);else if("number"==typeof e[0]&&e.length%2==0&&(e=xe.createInstance(e)),e instanceof xe)e=new Qe(e);else if(!(e instanceof Qe))throw new Error("fill shape type missmatch, expected oneof(PolygonArray, Polygon, Rect)");this.inkContext.setTarget(this);let i=this.inkContext.fill(e,t,r);return v.fromGLRect(i)}blend(e,t={}){if(t.mode||(t.mode=Ne.SOURCE_OVER),t.rect&&!t.transform&&(t.sourceRect=t.rect,t.destinationRect=t.rect),t.transform&&t.destinationRect)throw new Error("`destinationRect` is not applicable with `transform`");if(t.sourceRect&&!t.destinationRect)throw new Error("With `sourceRect`, `destinationRect` is required");if(t.destinationRect&&!t.sourceRect)throw new Error("With `destinationRect`, `sourceRect`is required");if(this.inkContext.setTarget(this,v.isRect(t.clipRect)?v.fromRect(t.clipRect).toGLRect():void 0),"boolean"==typeof t.flipY&&(e.flipY=t.flipY),t.transform&&t.rect){let r=v.fromRect(t.rect).toGLRect().toQuad(),i=v.fromRect(t.rect).toGLRect().toQuad(t.transform);this.inkContext.drawLayer(e,r,i,t.mode)}else t.transform?this.inkContext.drawLayerWithTransform(e,t.transform,t.mode):t.sourceRect&&t.destinationRect?this.inkContext.drawLayer(e,v.fromRect(t.sourceRect).toGLRect().toQuad(),v.fromRect(t.destinationRect).toGLRect().toQuad(),t.mode):this.inkContext.drawLayerWithTransform(e,null,t.mode)}createImageData(e,t,r){return e instanceof Uint8Array&&(e=new Uint8ClampedArray(e.buffer)),new ImageData(e,t,r)}getImageData(e,t=!1){e||(e=this.bounds);let r=this.createImageData(this.readPixels(e,t),e.width,e.height);return r.x=e.x,r.y=e.y,r}putImageData(e,t,r){if(!(e instanceof ImageData))throw new Error("putImageData 'imageData' parameter is not instance of ImageData");(isNaN(t)||isNaN(r))&&(t=e.x||0,r=e.y||0),this.writePixels(e.data,new v(t,r,e.width,e.height))}readPixels(e,t){e&&(e=v.fromRect(e).toGLRect()),this.inkContext.setTarget(this);let r=this.inkContext.readPixels(e);if(t)for(let e=0;e<r.length;e+=4){let t=r[e+3];r[e]=parseInt(255*r[e]/t),r[e+1]=parseInt(255*r[e+1]/t),r[e+2]=parseInt(255*r[e+2]/t)}return r}writePixels(e,t){if(!(e instanceof Uint8Array||e instanceof Uint8ClampedArray))throw new Error("writePixels 'data' parameter is not instance of Uint8Array or Uint8ClampedArray");t&&(t=v.fromRect(t).toGLRect()),this.inkContext.setTarget(this),this.inkContext.writePixels(t,e)}getExportCanvas(e){e=e?e.intersect(this.bounds).ceil():this.bounds;let t=new OffscreenCanvas(e.width,e.height);return t.getContext("2d").putImageData(this.getImageData(e,!0),0,0),t}}class Ir extends Pr{constructor(e){super(e,{display:!0,width:e.inkGLContext.gl.canvas.width,height:e.inkGLContext.gl.canvas.height,flipY:$.typeGL==$.TypeGL.WEB}),Object.defineProperty(this,"surface",{value:e.inkGLContext.gl.canvas,enumerable:!0}),Object.defineProperty(this,"ctx",{value:e.inkGLContext.gl,enumerable:!0}),Object.defineProperty(this,"MAX_SIZE",{value:this.ctx.getParameter(this.ctx.MAX_TEXTURE_SIZE),enumerable:!0});let t=this.ctx.getContextAttributes();if("function"==typeof requestAnimationFrame&&!t.preserveDrawingBuffer){let e=this.createLayer();Object.defineProperty(this,"backbuffer",{value:e,enumerable:!0});let t=r=>{this.present&&(delete this.present,super.blend(e,{mode:Ne.COPY})),this.frameID=requestAnimationFrame(t)};this.frameID=requestAnimationFrame(t)}}createLayer(e={}){let t=e.width,r=e.height;if(t&&r){if(t>this.MAX_SIZE)throw new Error(`Max width exceeded: ${t} found, ${this.MAX_SIZE} allowed`);if(r>this.MAX_SIZE)throw new Error(`Max height exceeded: ${r} found, ${this.MAX_SIZE} allowed`)}else{let t=Ir.getDefaultSize(this.width,this.height);e.width=t.width,e.height=t.height}return new Pr(this.inkContext,e)}clear(e,t){this.backbuffer?(this.backbuffer.clear(e,t),this.present=!0):super.clear(e,t)}draw(e,t){let r;return this.backbuffer?(r=this.backbuffer.draw(e,t),this.present=!0):r=super.draw(e,t),r}drawStroke(e,t,r){let i;return this.backbuffer?(i=this.backbuffer.drawStroke(e,t,r),this.present=!0):i=super.drawStroke(e,t,r),i}fill(e,t,r){let i;return this.backbuffer?(i=this.backbuffer.fill(e,t,r),this.present=!0):i=super.fill(e,t,r),i}blend(e,t){this.backbuffer?(this.backbuffer.blend(e,t),this.present=!0):super.blend(e,t)}readPixels(e,t){return this.backbuffer?this.backbuffer.readPixels(e,t):super.readPixels(e,t)}writePixels(e,t){this.backbuffer?(this.backbuffer.writePixels(e,t),this.present=!0):super.writePixels(e,t)}async toBlob(e=this.bounds,t,r){return this.backbuffer?await this.backbuffer.toBlob(e,t,r):await super.toBlob(e,t,r)}resize(e,t){super.resize(e,t),this.surface.width=e,this.surface.height=t}delete(){"number"==typeof this.frameID&&cancelAnimationFrame(this.frameID),super.delete(),this.backbuffer&&this.backbuffer.delete()}deleteLater(){return super.deleteLater(),this.backbuffer&&this.backbuffer.deleteLater(),this}static createInstance(e,t,r,i){if(!e||"function"!=typeof e.getContext)throw new Error("WebGL context provider is required");if(t>0&&r>0&&(e.width=t,e.height=r),!(e.width>0&&e.height>0))throw new Error("width and height are required and should be positive whole numbers");let s=new ze(e,i);return new Ir(s)}}class Sr{constructor(e,t,r){let i,s;this.listeners=[];let n=(e,t)=>{Object.defineProperty(this,e,{get:()=>t,set:r=>{if(!r&&"object"!=e)throw new Error(`SemanticTriple ${e} is required`);t=r,s=i,i=void 0,this.listeners.slice().forEach((e=>e(s,this)))},enumerable:!0})};n("subject",e),n("predicate",t),n("object",r),Object.defineProperty(this,"hashCode",{get:()=>(i||(i=b(this.toString())),i),enumerable:!0}),this.subject=e,this.predicate=t,this.object=r}equals(e){return this.subject==e.subject&&this.predicate==e.predicate&&this.object==e.object}subsets(e){if(!e||!e.subject&&!e.predicate&&!e.object)throw new Error("Illegal partialStatement found: at least onoeof(subject, predicate, object) is required");let t=!0;return e.subject&&(t=this.subject==e.subject),t&&e.predicate&&(t=this.predicate==e.predicate),t&&e.object&&(t=this.object==e.object),t}addListener(e){this.listeners.push(e)}removeListener(e){this.listeners.remove(e)}toString(){return`triple(${this.subject}, ${this.predicate}, ${this.object})`}toJSON(){return{subject:this.subject,predicate:this.predicate,object:this.object}}static hashCode(e){return e instanceof Sr?e.hashCode:b(Sr.prototype.toString.call(e))}}class xr extends Array{static get[Symbol.species](){return Array}constructor(...e){super();let t={};Object.defineProperty(this,"items",{value:t}),Object.defineProperty(this,"update",{value:(e,r)=>{delete t[e],this.items.hasOwnProperty(r.hashCode)?(r.removeListener(this.update),super.remove(r)):t[r.hashCode]=r}}),this.add(...e)}add(...e){for(let t of e)t instanceof Sr?this.push(t):this.addTriple(t.subject,t.predicate,t.object)}addTriple(e,t,r){this.push(new Sr(e,t,r))}push(...e){if(e.length>1)return void this.add(...e);let t=e[0];if(t instanceof Sr){let e=t.hashCode;this.items.hasOwnProperty(e)||(this.items[e]=t,super.push(t),t.addListener(this.update))}else this.addTriple(t.subject,t.predicate,t.object)}remove(...e){"function"==typeof e[0]&&(e=this.filter(e[0])),(e=e.map((e=>e instanceof Sr?e:this.items[Sr.hashCode(e)]))).forEach((e=>{e&&(e.removeListener(this.update),delete this.items[e.hashCode])})),super.remove(...e)}clear(){super.clear(),Object.keys(this.items).forEach((e=>{this.items[e].removeListener(this.update),delete this.items[e]}))}clone(){let e=new xr;return this.forEach((t=>e.addTriple(t.subject,t.predicate,t.object))),e}search(e){return console.warn("TripleStore search method is deprecated. Use filter instead."),this.filter((t=>{let r=!0;return Object.keys(e).forEach((i=>{r=r&&t[i]==e[i]})),r}))}}let wr=g?g.default||globalThis.protobuf:{};class Tr{static reservedViewNames=["main","sdm","hwr","ner"];constructor(e=Tr.Type.STROKE,t){if(e==Tr.Type.SENSOR_DATA)throw new Error("Sensor data trees are not supported yet");t||(t=e==Tr.Type.STROKE?"main":"sdm"),Object.defineProperty(this,"type",{value:e}),Object.defineProperty(this,"name",{get:()=>t,set:e=>{if(Tr.reservedViewNames.includes(t))throw new Error(`Tree name ${t} update is not allowed. Reserved names are immutable.`);if(Tr.reservedViewNames.includes(e))throw new Error(`Tree name ${e} is not allowed. It is reserved.`);let r=J.createNodeURISchema(this),i=J.createNodeURISchema(this,e);this.model.knowledgeGraph.forEach((e=>{e.subject.startsWith(r)&&(e.subject=e.subject.replace(r,i)),e.object.startsWith(r)&&(e.object=e.object.replace(r,i))})),this.model.views[e]=this.model.views[t],delete this.model.views[t],t=e},enumerable:!0}),Object.defineProperty(this,"uri",{get:()=>J.createTreeURI(t)})}}Object.defineEnum(Tr,"Type",["STROKE","SENSOR_DATA"]);class vr{static encodePathPointProperties(e,t){const r=t.$type;for(let i in r.fields){let r;if("color"==i)r=vr.rgba(e.red,e.green,e.blue,e.alpha);else{if(("size"==i||i.startsWith("scale"))&&1==e[i])continue;r=e[i]}isFinite(r)&&(t[i]=r)}return t}static decodePathPointProperties(e,t){if(!e)return;if(!t)throw new Error("Color property requires layout");const r=e.$type;let i={};for(let s in r.fields)if("color"==s){let r=vr.fromRGBA(e.color);t.includes(j.Property.RED)||(i.red=r.red),t.includes(j.Property.GREEN)||(i.green=r.green),t.includes(j.Property.BLUE)||(i.blue=r.blue),t.includes(j.Property.ALPHA)||(i.alpha=r.alpha)}else if(e.hasOwnProperty(s)){if(s.startsWith("scale")&&1==e[s])continue;i[s]=e[s]}return i}static rgba(e=0,t=0,r=0,i=0){return(255&e)<<24|(255&t)<<16|(255&r)<<8|255&(i=Math.round(255*i))}static fromRGBA(e=0){return{red:e>>24&255,green:e>>16&255,blue:e>>8&255,alpha:(255&e)/255}}}const Rr={evolution:["3.0.0","3.1.0"],"3.1.0":{schema:{nested:{UIM_3_1_0:{options:{optimize_for:"SPEED",java_multiple_files:!1,java_package:"com.wacom.ink.protobuf",java_outer_classname:"UIM_3_1_0",csharp_namespace:"Protobuf.WILL_3_1_0",swift_prefix:"WILL3_1_0"},nested:{BlendMode:{values:{SOURCE_OVER:0,DESTINATION_OVER:1,DESTINATION_OUT:2,LIGHTER:3,COPY:4,MIN:5,MAX:6}},Rectangle:{fields:{x:{type:"float",id:1},y:{type:"float",id:2},width:{type:"float",id:3},height:{type:"float",id:4}}},Matrix:{fields:{m00:{type:"float",id:1},m01:{type:"float",id:2},m02:{type:"float",id:3},m03:{type:"float",id:4},m10:{type:"float",id:5},m11:{type:"float",id:6},m12:{type:"float",id:7},m13:{type:"float",id:8},m20:{type:"float",id:9},m21:{type:"float",id:10},m22:{type:"float",id:11},m23:{type:"float",id:12},m30:{type:"float",id:13},m31:{type:"float",id:14},m32:{type:"float",id:15},m33:{type:"float",id:16}}},Interval:{fields:{fromIndex:{type:"uint32",id:1},toIndex:{type:"uint32",id:2},fromTValue:{type:"float",id:3},toTValue:{type:"float",id:4},id:{type:"bytes",id:100}}},PathPointProperties:{fields:{color:{type:"sint32",id:1},size:{type:"float",id:2},rotation:{type:"float",id:3},scaleX:{type:"float",id:4},scaleY:{type:"float",id:5},scaleZ:{type:"float",id:6},offsetX:{type:"float",id:7},offsetY:{type:"float",id:8},offsetZ:{type:"float",id:9}}},Property:{fields:{name:{type:"string",id:1},value:{type:"string",id:2}}},InkState:{values:{PLANE:0,HOVERING:1,IN_VOLUME:2,VOLUME_HOVERING:3}},InkSensorMetricType:{values:{LENGTH:0,TIME:1,FORCE:2,ANGLE:3,NORMALIZED:4,LOGICAL:5,DIMENSIONLESS:6}},InkInputProviderType:{values:{PEN:0,TOUCH:1,MOUSE:2,CONTROLLER:3}},InputContext:{fields:{id:{type:"bytes",id:1},environmentID:{type:"bytes",id:2},sensorContextID:{type:"bytes",id:3}}},Environment:{fields:{id:{type:"bytes",id:1},properties:{rule:"repeated",type:"Property",id:2}}},InkInputProvider:{fields:{id:{type:"bytes",id:1},type:{type:"InkInputProviderType",id:2},properties:{rule:"repeated",type:"Property",id:3}}},InputDevice:{fields:{id:{type:"bytes",id:1},properties:{rule:"repeated",type:"Property",id:2}}},SensorContext:{fields:{id:{type:"bytes",id:1},sensorChannelsContext:{rule:"repeated",type:"SensorChannelsContext",id:2}}},SensorChannelsContext:{fields:{id:{type:"bytes",id:1},channels:{rule:"repeated",type:"SensorChannel",id:2},samplingRateHint:{type:"uint32",id:3},latency:{type:"uint32",id:4},inkInputProviderID:{type:"bytes",id:5},inputDeviceID:{type:"bytes",id:6}}},SensorChannel:{fields:{id:{type:"bytes",id:1},type:{type:"string",id:2},metric:{type:"InkSensorMetricType",id:3},resolution:{type:"double",id:4},min:{type:"float",id:5},max:{type:"float",id:6},precision:{type:"uint32",id:7}}},InputContextData:{fields:{inputContexts:{rule:"repeated",type:"InputContext",id:1},inkInputProviders:{rule:"repeated",type:"InkInputProvider",id:2},inputDevices:{rule:"repeated",type:"InputDevice",id:3},environments:{rule:"repeated",type:"Environment",id:4},sensorContexts:{rule:"repeated",type:"SensorContext",id:5}}},ChannelData:{fields:{sensorChannelID:{type:"bytes",id:1},values:{rule:"repeated",type:"sint32",id:2}}},SensorData:{fields:{id:{type:"bytes",id:1},inputContextID:{type:"bytes",id:2},state:{type:"InkState",id:3},timestamp:{type:"uint64",id:4},dataChannels:{rule:"repeated",type:"ChannelData",id:5}}},InputData:{fields:{inputContextData:{type:"InputContextData",id:1},sensorData:{rule:"repeated",type:"SensorData",id:2}}},RotationMode:{values:{NONE:0,RANDOM:1,TRAJECTORY:2}},BrushPrototype:{fields:{coordX:{rule:"repeated",type:"float",id:1},coordY:{rule:"repeated",type:"float",id:2},coordZ:{rule:"repeated",type:"float",id:3},indices:{rule:"repeated",type:"uint32",id:4},shapeURI:{type:"string",id:5},size:{type:"float",id:6}}},VectorBrush:{fields:{name:{type:"string",id:1},prototype:{rule:"repeated",type:"BrushPrototype",id:2},spacing:{type:"float",id:3}}},RasterBrush:{fields:{name:{type:"string",id:1},spacing:{type:"float",id:2},scattering:{type:"float",id:3},rotationMode:{type:"RotationMode",id:4},shapeTexture:{rule:"repeated",type:"bytes",id:5},shapeTextureURI:{rule:"repeated",type:"string",id:6},fillTexture:{type:"bytes",id:7},fillTextureURI:{type:"string",id:8},fillWidth:{type:"float",id:9},fillHeight:{type:"float",id:10},randomizeFill:{type:"bool",id:11},blendMode:{type:"BlendMode",id:12}}},Brushes:{fields:{vectorBrushes:{rule:"repeated",type:"VectorBrush",id:1},rasterBrushes:{rule:"repeated",type:"RasterBrush",id:2}}},Stroke:{oneofs:{data:{oneof:["splineData","splineCompressed"]},properties:{oneof:["propertiesIndex","propertiesValue"]},brushURI:{oneof:["brushURIIndex","brushURIValue"]},renderModeURI:{oneof:["renderModeURIIndex","renderModeURIValue"]}},fields:{id:{type:"bytes",id:1},precisions:{type:"sint32",id:2},startParameter:{type:"float",id:3},endParameter:{type:"float",id:4},splineData:{type:"SplineData",id:5},splineCompressed:{type:"SplineCompressed",id:6},propertiesIndex:{type:"uint32",id:7},propertiesValue:{type:"PathPointProperties",id:8},brushURIIndex:{type:"uint32",id:9},brushURIValue:{type:"string",id:10},renderModeURIIndex:{type:"uint32",id:11},renderModeURIValue:{type:"string",id:12},randomSeed:{type:"uint32",id:13},sensorDataOffset:{type:"uint32",id:14},sensorDataID:{type:"bytes",id:15},sensorDataMapping:{rule:"repeated",type:"uint32",id:16}},nested:{SplineData:{fields:{splineX:{rule:"repeated",type:"float",id:1},splineY:{rule:"repeated",type:"float",id:2},splineZ:{rule:"repeated",type:"float",id:3},red:{rule:"repeated",type:"uint32",id:4},green:{rule:"repeated",type:"uint32",id:5},blue:{rule:"repeated",type:"uint32",id:6},alpha:{rule:"repeated",type:"uint32",id:7},size:{rule:"repeated",type:"float",id:8},rotation:{rule:"repeated",type:"float",id:9},scaleX:{rule:"repeated",type:"float",id:10},scaleY:{rule:"repeated",type:"float",id:11},scaleZ:{rule:"repeated",type:"float",id:12},offsetX:{rule:"repeated",type:"float",id:13},offsetY:{rule:"repeated",type:"float",id:14},offsetZ:{rule:"repeated",type:"float",id:15}}},SplineCompressed:{fields:{splineX:{rule:"repeated",type:"sint32",id:1},splineY:{rule:"repeated",type:"sint32",id:2},splineZ:{rule:"repeated",type:"sint32",id:3},red:{rule:"repeated",type:"uint32",id:4},green:{rule:"repeated",type:"uint32",id:5},blue:{rule:"repeated",type:"uint32",id:6},alpha:{rule:"repeated",type:"uint32",id:7},size:{rule:"repeated",type:"sint32",id:8},rotation:{rule:"repeated",type:"sint32",id:9},scaleX:{rule:"repeated",type:"sint32",id:10},scaleY:{rule:"repeated",type:"sint32",id:11},scaleZ:{rule:"repeated",type:"sint32",id:12},offsetX:{rule:"repeated",type:"sint32",id:13},offsetY:{rule:"repeated",type:"sint32",id:14},offsetZ:{rule:"repeated",type:"sint32",id:15}}}}},InkData:{fields:{strokes:{rule:"repeated",type:"Stroke",id:1},unitScaleFactor:{type:"float",id:2},transform:{type:"Matrix",id:3},brushURIs:{rule:"repeated",type:"string",id:4},renderModeURIs:{rule:"repeated",type:"string",id:5},properties:{rule:"repeated",type:"PathPointProperties",id:6}}},TripleStore:{fields:{statements:{rule:"repeated",type:"SemanticTriple",id:1}},nested:{SemanticTriple:{fields:{subject:{type:"string",id:1},predicate:{type:"string",id:2},object:{type:"string",id:3}}}}},Properties:{fields:{properties:{rule:"repeated",type:"Property",id:1}}},StructureType:{values:{STROKE:0,SENSOR_DATA:1}},Node:{oneofs:{id:{oneof:["groupID","index"]}},fields:{depth:{type:"uint32",id:1},groupID:{type:"bytes",id:2},index:{type:"uint32",id:3},interval:{type:"Interval",id:4},bounds:{type:"Rectangle",id:5}}},InkTree:{fields:{name:{type:"string",id:1},tree:{rule:"repeated",type:"Node",id:2}}},InkStructure:{fields:{type:{type:"StructureType",id:1},inkTree:{type:"InkTree",id:2},views:{rule:"repeated",type:"InkTree",id:3}}},Path:{fields:{layout:{type:"uint32",id:1},pointProps:{type:"PathPointProperties",id:2},data:{rule:"repeated",type:"float",id:3}}},Polygon:{fields:{shape:{type:"Path",id:1},holes:{rule:"repeated",type:"Path",id:2}}},PolygonArray:{fields:{data:{rule:"repeated",type:"Polygon",id:1}}},InkPath:{oneofs:{data:{oneof:["path","polygons"]}},fields:{path:{type:"Path",id:1},polygons:{type:"PolygonArray",id:2},spline:{type:"Path",id:3}}},Style:{fields:{pointerID:{type:"uint32",id:1},color:{type:"sint32",id:2},brushURI:{type:"string",id:3},randomSeed:{type:"uint32",id:4},renderModeURI:{type:"string",id:5}}},Segment:{fields:{pointerID:{type:"uint32",id:1},complete:{type:"bool",id:2},ink:{type:"InkPath",id:3}}},StrokesContext:{fields:{path:{rule:"repeated",type:"bytes",id:1}}},Intersection:{fields:{path:{type:"bytes",id:1},intervals:{rule:"repeated",type:"Interval",id:2}}},InkOperation:{oneofs:{operation:{oneof:["compose","add","remove","update","split","select","updateSelection","transform"]}},fields:{compose:{type:"Compose",id:1},add:{type:"Add",id:2},remove:{type:"Remove",id:3},update:{type:"Update",id:4},split:{type:"Split",id:5},select:{type:"Select",id:6},updateSelection:{type:"UpdateSelection",id:7},transform:{type:"Transform",id:8}},nested:{Compose:{oneofs:{stage:{oneof:["style","segment","abort"]}},fields:{style:{type:"Style",id:1},segment:{type:"Segment",id:2},abort:{type:"bool",id:3}}},Add:{fields:{path:{type:"Stroke",id:1},ink:{type:"InkPath",id:2}}},Remove:{fields:{context:{type:"StrokesContext",id:1}}},Update:{fields:{context:{type:"StrokesContext",id:1},style:{type:"Style",id:2},edit:{type:"bool",id:3}}},Split:{fields:{intersections:{rule:"repeated",type:"Intersection",id:1},affectedArea:{type:"Rectangle",id:2}}},Select:{oneofs:{stage:{oneof:["selector","selection","abort"]}},fields:{selector:{type:"Stroke",id:1},selection:{type:"StrokesContext",id:2},abort:{type:"bool",id:3}}},UpdateSelection:{oneofs:{stage:{oneof:["transform","complete"]}},fields:{transform:{type:"Matrix",id:1},complete:{type:"bool",id:2}}},Transform:{fields:{context:{type:"StrokesContext",id:1},matrix:{type:"Matrix",id:2}}}}},Range:{fields:{min:{type:"float",id:1},max:{type:"float",id:2},remapURI:{type:"string",id:3}}},PathPointContext:{fields:{statics:{type:"PathPointProperties",id:1},dynamics:{type:"PathPointSettings",id:2},colorMask:{type:"uint32",id:3}}},PathPointSettings:{fields:{size:{type:"PropertySettings",id:1},red:{type:"PropertySettings",id:2},green:{type:"PropertySettings",id:3},blue:{type:"PropertySettings",id:4},alpha:{type:"PropertySettings",id:5},rotation:{type:"PropertySettings",id:6},scaleX:{type:"PropertySettings",id:7},scaleY:{type:"PropertySettings",id:8},scaleZ:{type:"PropertySettings",id:9},offsetX:{type:"PropertySettings",id:11},offsetY:{type:"PropertySettings",id:12},offsetZ:{type:"PropertySettings",id:13}}},PropertySettings:{fields:{value:{type:"Range",id:1},velocity:{type:"Range",id:2},pressure:{type:"Range",id:3},altitude:{type:"Range",id:4},radiusX:{type:"Range",id:5},radiusY:{type:"Range",id:6},resolveURI:{type:"string",id:7},dependencies:{type:"uint32",id:8}}},InkTool:{oneofs:{brush:{oneof:["vectorBrush","rasterBrush"]}},fields:{vectorBrush:{type:"VectorBrush",id:1},rasterBrush:{type:"RasterBrush",id:2},blendMode:{type:"BlendMode",id:3},context:{type:"PathPointContext",id:4}}}}}}},root:"UIM_3_1_0",messages:{InputContext(e){e.id=P.toBytes(P.format(e.id)),e.environmentID=P.toBytes(P.format(e.environmentID)),e.sensorContextID=P.toBytes(P.format(e.sensorContextID))},Environment(e){e.id=P.toBytes(P.format(e.id))},InkInputProvider(e){e.id=P.toBytes(P.format(e.id))},InputDevice(e){e.id=P.toBytes(P.format(e.id))},SensorContext(e){e.id=P.toBytes(P.format(e.id))},SensorChannelsContext(e){e.id=P.toBytes(P.format(e.id)),e.inputDeviceID=P.toBytes(P.format(e.inputDeviceID)),e.inkInputProviderID&&(e.inkInputProviderID=P.toBytes(P.format(e.inkInputProviderID))),e.samplingRateHint&&(e.samplingRateHint=e.samplingRateHint.value),e.latency&&(e.latency=e.latency.value)},SensorChannel(e){e.id=P.toBytes(P.format(e.id))},ChannelData(e){e.sensorChannelID=P.toBytes(P.format(e.sensorChannelID))},SensorData(e){e.id=P.toBytes(e.id),e.inputContextID=P.toBytes(P.format(e.inputContextID))},InputData(e){let t=[],r={};e.sensorData.forEach(((e,i)=>{r[e.id]?t.push(i):0==e.dataChannels.length?(console.warn(`Not found corresponding data channels for sensor data with id: ${e.id}. Invalid sensor data is discarded.`),t.push(i)):r[e.id]=e})),t.reverse().forEach((t=>e.sensorData.removeAt(t)))},View(e){e.name.startsWith("will://")&&(e.name=e.name.toLowerCase()),e.name=e.name.substring(e.name.lastIndexOf("/")+1)},Node(e,t){let r=Rr["3.0.0"].format;e.chunkToIndex>e.chunkFromIndex&&(e.interval={fromIndex:e.chunkFromIndex,toIndex:e.chunkToIndex,fromTValue:0,toTValue:1}),e.update={nodeID:e.id},e.type==r.NodeType.STROKE_GROUP||e.type==r.NodeType.SENSOR_DATA_GROUP?(P.validate(e.id)||(e.id=P.generate(),e.update.id=e.id),e.groupID=P.toBytes(e.id),e.id="groupID"):(e.type==r.NodeType.STROKE?e.update.id=t.context.inkData.strokes[e.index].id:e.update.id=t.context.inputData.sensorData[e.index].id,e.id="index"),Object.defineProperty(e,"bounds",{get:()=>e.groupBoundingBox,configurable:!0})},InkData(e,t){e.brushURIs=[],e.renderModeURIs=[],e.properties=[],e.unitScaleFactor=1,e.transform=t.context.transform},Stroke(e,t){let r=Rr["3.1.0"].format,i=Rr["3.1.0"].messages.PathPointProperties;e.data="splineData",e.splineData={splineX:e.splineX,splineY:e.splineY,splineZ:e.splineZ,red:e.red.map((e=>Math.round(255*e))),green:e.green.map((e=>Math.round(255*e))),blue:e.blue.map((e=>Math.round(255*e))),alpha:e.red.map((e=>Math.round(255*e))),size:e.size,rotation:e.rotation,scaleX:e.scaleX,scaleY:e.scaleY,scaleZ:e.scaleZ,offsetX:e.offsetX,offsetY:e.offsetY,offsetZ:e.offsetZ},e.id=P.toBytes(e.id),e.sensorDataID&&(e.sensorDataID=P.toBytes(e.sensorDataID)),e.randomSeed=e.style.particlesRandomSeed,e.brushURI="brushURIValue",e.renderModeURI="renderModeURIValue",e.properties="propertiesValue",e.brushURIValue=e.style.brushURI,e.style.renderModeURI&&(e.renderModeURIValue=e.style.renderModeURI),i(e.style.properties,t,!1),e.propertiesValue=vr.encodePathPointProperties(e.style.properties,r.PathPointProperties.create())},PathPointProperties(e,t,r=!0){if(r)return;let i=Rr["3.0.0"].format;for(let t in i.PathPointProperties.fields)if(e[t]){let r=e[t].value;"red"!=t&&"green"!=t&&"blue"!=t||(r=Math.round(255*r)),e[t]=r}else e[t]=void 0},TripleStore(e,t){let r=Rr["3.0.0"].format,i=[],s=[{tree:t.context.inkTree},...t.context.views],n=t.context.inkTree.first.type,o=n==r.NodeType.STROKE_GROUP?Tr.Type.STROKE:Tr.Type.SENSOR_DATA;s.forEach((e=>{if(e.tree.first.type!=n){let t=e.tree.first.type==r.NodeType.STROKE_GROUP?Tr.Type.STROKE:Tr.Type.SENSOR_DATA;throw new Error(`Inconsistent view found: ${t.name} Expected: ${o.name}`)}let t=new Tr(o,e.name);t.tree=e.tree,i.push(t)})),i.forEach((t=>{t.tree.forEach((r=>((t,r,i,s)=>{let n=`uim:node/${r}`,o=i||r;e.statements.forEach((e=>{e.subject==n&&(e.subject=J.createNodeURI(t,o,s)),e.object==n&&(e.object=J.createNodeURI(t,o,s))}))})(t,r.update.nodeID,r.update.id,r.interval)))}))}}},"3.0.0":{schema:{nested:{WacomInkFormat3:{options:{optimize_for:"SPEED",java_multiple_files:!1,java_package:"com.wacom.ink.protobuf",java_outer_classname:"Will3_0_0",csharp_namespace:"Protobuf.WILL_3_0_0"},nested:{Rectangle:{fields:{x:{type:"float",id:1},y:{type:"float",id:2},width:{type:"float",id:3},height:{type:"float",id:4}}},Matrix4:{fields:{m00:{type:"float",id:1},m01:{type:"float",id:2},m02:{type:"float",id:3},m03:{type:"float",id:4},m10:{type:"float",id:5},m11:{type:"float",id:6},m12:{type:"float",id:7},m13:{type:"float",id:8},m20:{type:"float",id:9},m21:{type:"float",id:10},m22:{type:"float",id:11},m23:{type:"float",id:12},m30:{type:"float",id:13},m31:{type:"float",id:14},m32:{type:"float",id:15},m33:{type:"float",id:16}}},Range:{fields:{min:{type:"float",id:1},max:{type:"float",id:2},remapURI:{type:"string",id:3}}},Float32:{fields:{value:{type:"float",id:1}}},Uint32:{fields:{value:{type:"uint32",id:1}}},Property:{fields:{name:{type:"string",id:1},value:{type:"string",id:2}}},SemanticTriple:{fields:{subject:{type:"string",id:1},predicate:{type:"string",id:2},object:{type:"string",id:3}}},InkState:{values:{PLANE:0,HOVERING:1,IN_VOLUME:2,VOLUME_HOVERING:3}},InkSensorMetricType:{values:{LENGTH:0,TIME:1,FORCE:2,ANGLE:3,NORMALIZED:4,LOGICAL:5,DIMENSIONLESS:6}},InkInputProviderType:{values:{PEN:0,TOUCH:1,MOUSE:2,CONTROLLER:3}},InputContext:{fields:{id:{type:"string",id:1},environmentID:{type:"string",id:2},sensorContextID:{type:"string",id:3}}},Environment:{fields:{id:{type:"string",id:1},properties:{rule:"repeated",type:"Property",id:2}}},InkInputProvider:{fields:{id:{type:"string",id:1},type:{type:"InkInputProviderType",id:2},properties:{rule:"repeated",type:"Property",id:3}}},InputDevice:{fields:{id:{type:"string",id:1},properties:{rule:"repeated",type:"Property",id:2}}},SensorContext:{fields:{id:{type:"string",id:1},sensorChannelsContext:{rule:"repeated",type:"SensorChannelsContext",id:2}}},SensorChannelsContext:{fields:{id:{type:"string",id:1},channels:{rule:"repeated",type:"SensorChannel",id:2},samplingRateHint:{type:"Uint32",id:3},latency:{type:"Uint32",id:4},inkInputProviderID:{type:"string",id:5},inputDeviceID:{type:"string",id:6}}},SensorChannel:{fields:{id:{type:"string",id:1},type:{type:"string",id:2},metric:{type:"InkSensorMetricType",id:3},resolution:{type:"double",id:4},min:{type:"float",id:5},max:{type:"float",id:6},precision:{type:"uint32",id:7}}},InputContextData:{fields:{inputContexts:{rule:"repeated",type:"InputContext",id:1},inkInputProviders:{rule:"repeated",type:"InkInputProvider",id:2},inputDevices:{rule:"repeated",type:"InputDevice",id:3},environments:{rule:"repeated",type:"Environment",id:4},sensorContexts:{rule:"repeated",type:"SensorContext",id:5}}},ChannelData:{fields:{sensorChannelID:{type:"string",id:1},values:{rule:"repeated",type:"sint32",id:2}}},SensorData:{fields:{id:{type:"string",id:1},inputContextID:{type:"string",id:2},state:{type:"InkState",id:3},timestamp:{type:"uint64",id:4},dataChannels:{rule:"repeated",type:"ChannelData",id:5}}},Stroke:{fields:{id:{type:"string",id:1},startParameter:{type:"float",id:2},endParameter:{type:"float",id:3},splineX:{rule:"repeated",type:"float",id:4},splineY:{rule:"repeated",type:"float",id:5},splineZ:{rule:"repeated",type:"float",id:6},red:{rule:"repeated",type:"float",id:7},green:{rule:"repeated",type:"float",id:8},blue:{rule:"repeated",type:"float",id:9},alpha:{rule:"repeated",type:"float",id:10},size:{rule:"repeated",type:"float",id:11},rotation:{rule:"repeated",type:"float",id:12},scaleX:{rule:"repeated",type:"float",id:13},scaleY:{rule:"repeated",type:"float",id:14},scaleZ:{rule:"repeated",type:"float",id:15},offsetX:{rule:"repeated",type:"float",id:16},offsetY:{rule:"repeated",type:"float",id:17},offsetZ:{rule:"repeated",type:"float",id:18},sensorDataOffset:{type:"uint32",id:19},sensorDataID:{type:"string",id:20},sensorDataMapping:{rule:"repeated",type:"uint32",id:21},style:{type:"Style",id:22}}},RotationMode:{values:{NONE:0,RANDOM:1,TRAJECTORY:2}},BlendMode:{values:{SOURCE_OVER:0,DESTINATION_OVER:1,DESTINATION_OUT:2,LIGHTER:3,COPY:4,MIN:5,MAX:6}},BrushPrototype:{fields:{coordX:{rule:"repeated",type:"float",id:1},coordY:{rule:"repeated",type:"float",id:2},coordZ:{rule:"repeated",type:"float",id:3},indices:{rule:"repeated",type:"uint32",id:4},shapeURI:{type:"string",id:5},size:{type:"float",id:6}}},VectorBrush:{fields:{name:{type:"string",id:1},prototype:{rule:"repeated",type:"BrushPrototype",id:2},spacing:{type:"float",id:3}}},RasterBrush:{fields:{name:{type:"string",id:1},spacing:{type:"float",id:2},scattering:{type:"float",id:3},rotationMode:{type:"RotationMode",id:4},shapeTexture:{rule:"repeated",type:"bytes",id:5},shapeTextureURI:{rule:"repeated",type:"string",id:6},fillTexture:{type:"bytes",id:7},fillTextureURI:{type:"string",id:8},fillWidth:{type:"float",id:9},fillHeight:{type:"float",id:10},randomizeFill:{type:"bool",id:11},blendMode:{type:"BlendMode",id:12}}},NodeType:{values:{STROKE_GROUP:0,SENSOR_DATA_GROUP:1,STROKE:2,SENSOR_DATA:3}},Node:{fields:{id:{type:"string",id:1},depth:{type:"uint32",id:2},index:{type:"uint32",id:3},type:{type:"NodeType",id:4},groupBoundingBox:{type:"Rectangle",id:5},chunkFromIndex:{type:"uint32",id:6},chunkToIndex:{type:"uint32",id:7}}},View:{fields:{name:{type:"string",id:1},tree:{rule:"repeated",type:"Node",id:2}}},PathPointProperties:{fields:{size:{type:"Float32",id:1},red:{type:"Float32",id:2},green:{type:"Float32",id:3},blue:{type:"Float32",id:4},alpha:{type:"Float32",id:5},rotation:{type:"Float32",id:6},scaleX:{type:"Float32",id:7},scaleY:{type:"Float32",id:8},scaleZ:{type:"Float32",id:9},offsetX:{type:"Float32",id:11},offsetY:{type:"Float32",id:12},offsetZ:{type:"Float32",id:13}}},Style:{fields:{properties:{type:"PathPointProperties",id:1},brushURI:{type:"string",id:2},particlesRandomSeed:{type:"uint32",id:3},renderModeURI:{type:"string",id:4}}},InputData:{fields:{inputContextData:{type:"InputContextData",id:1},sensorData:{rule:"repeated",type:"SensorData",id:2}}},InkData:{fields:{strokes:{rule:"repeated",type:"Stroke",id:1}}},Brushes:{fields:{vectorBrushes:{rule:"repeated",type:"VectorBrush",id:1},rasterBrushes:{rule:"repeated",type:"RasterBrush",id:2}}},TripleStore:{fields:{statements:{rule:"repeated",type:"SemanticTriple",id:1}}},Tool:{oneofs:{brush:{oneof:["vectorBrush","rasterBrush"]}},fields:{vectorBrush:{type:"VectorBrush",id:1},rasterBrush:{type:"RasterBrush",id:2},blendMode:{type:"BlendMode",id:3},context:{type:"PathPointContext",id:4}}},PathPointContext:{fields:{statics:{type:"PathPointProperties",id:1},dynamics:{type:"PathPointSettings",id:2}}},PathPointSettings:{fields:{size:{type:"PropertySettings",id:1},red:{type:"PropertySettings",id:2},green:{type:"PropertySettings",id:3},blue:{type:"PropertySettings",id:4},alpha:{type:"PropertySettings",id:5},rotation:{type:"PropertySettings",id:6},scaleX:{type:"PropertySettings",id:7},scaleY:{type:"PropertySettings",id:8},scaleZ:{type:"PropertySettings",id:9},offsetX:{type:"PropertySettings",id:11},offsetY:{type:"PropertySettings",id:12},offsetZ:{type:"PropertySettings",id:13}}},PropertySettings:{fields:{value:{type:"Range",id:1},velocity:{type:"Range",id:2},pressure:{type:"Range",id:3},altitude:{type:"Range",id:4},radiusX:{type:"Range",id:5},radiusY:{type:"Range",id:6},resolveURI:{type:"string",id:7},dependencies:{rule:"repeated",type:"InputPropertyType",id:8}}},InputPropertyType:{values:{PRESSURE:0,RADIUS_X:1,RADIUS_Y:2,AZIMUTH:3,ALTITUDE:4,ROTATION:5}},InkObject:{fields:{inputData:{type:"InputData",id:1},inkData:{type:"InkData",id:2},brushes:{type:"Brushes",id:3},inkTree:{rule:"repeated",type:"Node",id:4},views:{rule:"repeated",type:"View",id:5},knowledgeGraph:{type:"TripleStore",id:6},transform:{type:"Matrix4",id:7},properties:{rule:"repeated",type:"Property",id:8}}}}}}},root:"WacomInkFormat3",messages:{}}};Rr.evolution.forEach((e=>{let t=Rr[e].root;Object.defineProperty(Rr[e],"format",{get:function(){return this.value||(this.value=wr.Root.fromJSON(this.schema.nested[t])),this.value}})})),Object.defineProperty(Rr,"latest",{value:Rr[Rr.evolution.last].format,enumerable:!0});const{Namespace:Ar,Message:Or}=wr;class Cr{constructor(){this.format=Rr.latest}static encode(e){return e.constructor.encode(e).finish()}static decode(e,t){if(!(t instanceof Ar))throw new Error("Expected 'Type' to be instance of 'Namespace'");return e instanceof ArrayBuffer&&(e=new Uint8Array(e)),e instanceof Uint8Array?t.decode(e):e instanceof Or?e:t.fromObject(e)}}const{Namespace:Dr,Message:kr}=wr;class Nr{constructor(){Object.defineProperty(this,"format",{value:Rr.latest})}decodeInkObject(e,t){if("3.0.0"==t){let r=this.decode("InkObject",e.data,t);return{Properties:new kr({properties:r.properties}),KnowledgeGraph:r.knowledgeGraph,InputData:r.inputData,Brushes:r.brushes,InkData:r.inkData,InkStructure:new kr({type:Rr.latest.StructureType.STROKE,inkTree:{tree:r.inkTree},views:r.views})}}return{Properties:this.decode("Properties",e.prps,t),KnowledgeGraph:this.decode("TripleStore",e.knwg,t),InputData:this.decode("InputData",e.inpt,t),Brushes:this.decode("Brushes",e.brsh,t),InkData:this.decode("InkData",e.inkd,t),InkStructure:this.decode("InkStructure",e.inks,t)}}decode(e,t,r="latest"){if(!t)return;let i=Rr[r].format[e].decode(t),s=Rr.evolution.slice();for(;s.first!=r;)s=s.slice(1);return this.evolution=s.slice(1),this.evolution.length>0&&(this.state={context:i},this.resolve(i),delete this.state),i}resolve(e){let t=e.constructor.name;this.evolution.forEach((r=>{let i=Rr[r].messages[t];i&&i(e,this.state)})),Object.values(e).forEach((e=>{e instanceof kr?this.resolve(e):Array.isArray(e)&&e.length>0&&e.first instanceof kr&&e.forEach((e=>{e instanceof kr&&this.resolve(e)}))}))}}class Mr extends Cr{constructor(){super(),this.precisionDetector=new dr,Object.defineProperty(this,"precisionCalculator",{get:()=>this.precisionDetector.calculator,set:e=>this.precisionDetector.calculator=e,enumerable:!0})}encode(e,t=1,r){if(0==e.length)return;let i=this.buildStrokesIndex(e);this.state={index:i.index},this.precisionDetector.calculator&&this.precisionDetector.reset();let s=this.format.InkData.create({strokes:e.map((e=>this.encodeStroke(e))),unitScaleFactor:t,transform:this.encodeMatrix(r),brushURIs:i.brushURIs,renderModeURIs:i.renderModeURIs,properties:i.properties.map((e=>vr.encodePathPointProperties(e,this.format.PathPointProperties.create())))});return this.reset(),this.precisionDetector.calculator&&this.precisionDetector.printStats(),Cr.encode(s)}buildStrokesIndex(e){let t=[],r=[],i=[],s={},n={};return e.forEach((e=>{let o=[];for(let t in this.format.PathPointProperties.fields)"color"==t?(o.push("red",e.pointProps.red||0),o.push("green",e.pointProps.green||0),o.push("blue",e.pointProps.blue||0),o.push("alpha",(e.pointProps.alpha||0).toFixed(2))):o.push(t,(e.pointProps[t]||0).toFixed(2));o=o.join("_");let a=t.indexOf(e.brush.name),l=e.renderMode!=hr.RenderMode.SOURCE_OVER?r.indexOf(e.renderMode):void 0,h=i.indexOf(o);-1==a&&(a=t.push(e.brush.name)-1),-1==l&&(l=r.push(e.renderMode)-1),-1==h&&(h=i.push(o)-1,s[o]=e.pointProps),n[e.id]={brushURI:a,renderModeURI:l,pathPointProperties:h}})),{properties:i.map((e=>s[e])),brushURIs:t,renderModeURIs:r,index:n}}decode(e,t={},r=[]){if(!e)return;let i=Cr.decode(e,this.format.InkData),s={brushes:t,brushURIs:i.brushURIs,sensorPaths:Object.assign({},...r.map((e=>({[e.id]:e})))),renderModeURIs:i.renderModeURIs,properties:i.properties},n={strokes:i.strokes.map((e=>this.decodeStroke(e,s))),unitScaleFactor:i.unitScaleFactor||1,transform:this.decodeMatrix(i.transform)};return this.reset(),n}encodeStroke(e){let t=this.state?this.state.index[e.id]:void 0,r=this.format.Stroke.create({id:P.toBytes(e.id),startParameter:e.ts,endParameter:e.tf,randomSeed:e.randomSeed});if(t?(r.brushURIIndex=t.brushURI+1,r.propertiesIndex=t.pathPointProperties+1,isFinite(t.renderModeURI)&&(r.renderModeURIIndex=t.renderModeURI+1)):(r.brushURIValue=e.brush.name,r.propertiesValue=vr.encodePathPointProperties(e.pointProps,this.format.PathPointProperties.create()),e.renderMode!=hr.RenderMode.SOURCE_OVER&&(r.renderModeURIValue=e.renderMode)),this.precisionDetector.calculator&&e.compressionType==hr.CompressionType.AUTO&&this.precisionDetector.updatePrecisionSchema(e),e.precisionSchema?(r.precisions=e.precisionSchema.precisions,r.splineCompressed=this.encodeSplineCompressed(e.spline,e.precisionSchema)):r.splineData=this.encodeSpline(e.spline),e.sensorData&&!this.ignoreSensorData){if(!t)throw new Error("Model-less strokes sensor data persistance is not supported");r.sensorDataID=P.toBytes(e.sensorData.id),r.sensorDataOffset=e.sensorDataOffset,r.sensorDataMapping=e.sensorDataMapping}return r}decodeStroke(e,t={}){let r="splineCompressed"==e.data,i=e[e.data];if(0==i.splineX.length||0==i.splineY.length)throw new Error("Incomplete path definition");let s=[j.Property.X,j.Property.Y];i.splineZ.length>0&&s.push(j.Property.Z),i.red&&i.red.length>0&&s.push(j.Property.RED),i.green.length>0&&s.push(j.Property.GREEN),i.blue.length>0&&s.push(j.Property.BLUE),i.alpha.length>0&&s.push(j.Property.ALPHA),i.size.length>0&&s.push(j.Property.SIZE),i.rotation.length>0&&s.push(j.Property.ROTATION),i.scaleX.length>0&&s.push(j.Property.SCALE_X),i.scaleY.length>0&&s.push(j.Property.SCALE_Y),i.scaleZ.length>0&&s.push(j.Property.SCALE_Z),i.offsetX.length>0&&s.push(j.Property.OFFSET_X),i.offsetY.length>0&&s.push(j.Property.OFFSET_Y),i.offsetZ.length>0&&s.push(j.Property.OFFSET_Z);let n,o,a=i.splineX.length,l=s.length,h=Float32Array.createSharedInstance(a*l);r?(n=new Rt(e.precisions),this.decodeSplineCompressed(i,s,h,n)):this.decodeSpline(i,s,h),e.renderModeURI&&(o="renderModeURIValue"==e.renderModeURI?e.renderModeURIValue:t.renderModeURIs[e.renderModeURIIndex-1]);let d,c="propertiesValue"==e.properties?vr.decodePathPointProperties(e.propertiesValue,s):vr.decodePathPointProperties(t.properties[e.propertiesIndex-1],s),u="brushURIValue"==e.brushURI?e.brushURIValue:t.brushURIs[e.brushURIIndex-1],p=(t.brushes?t.brushes[u]:void 0)||u;t.sensorPaths&&e.sensorDataID&&(d=t.sensorPaths[P.fromBytes(e.sensorDataID)]);let f=e.startParameter,m=e.endParameter;1==f&&(console.warn(`Invalid ts = 1 found on spline deserializtion, ts is set to 0.99999. Stroke ${P.fromBytes(e.id)} is affected.`),f=.99999),0==m&&(console.warn(`Invalid tf = 1 found on spline deserializtion, tf is set to 0.00001. Stroke ${P.fromBytes(e.id)} is affected.`),m=1e-5);let g=new lt(s,h,c,f,m);g.id=this.cloneStroke?P.generate():P.fromBytes(e.id);let y=new hr(p,g,t.inkPath,d);return y.randomSeed=e.randomSeed,y.precisionSchema=n,o&&(y.renderMode=o),d&&(y.sensorDataOffset=e.sensorDataOffset,y.sensorDataMapping=e.sensorDataMapping),y}encodeSpline(e){let t=this.format.Stroke.SplineData.create();for(let r=0;r<e.length;r++){let i=e.getPoint(r);e.layout.forEach((e=>{switch(e){case j.Property.X:t.splineX.push(i.x);break;case j.Property.Y:t.splineY.push(i.y);break;case j.Property.Z:t.splineZ.push(i.z);break;case j.Property.RED:t.red.push(i.red);break;case j.Property.GREEN:t.green.push(i.green);break;case j.Property.BLUE:t.blue.push(i.blue);break;case j.Property.ALPHA:t.alpha.push(Math.round(255*i.alpha));break;case j.Property.SIZE:t.size.push(i.size);break;case j.Property.ROTATION:t.rotation.push(i.rotation);break;case j.Property.SCALE_X:t.scaleX.push(i.scaleX);break;case j.Property.SCALE_Y:t.scaleY.push(i.scaleY);break;case j.Property.SCALE_Z:t.scaleZ.push(i.scaleZ);break;case j.Property.OFFSET_X:t.offsetX.push(i.offsetX);break;case j.Property.OFFSET_Y:t.offsetY.push(i.offsetY);break;case j.Property.OFFSET_Z:t.offsetZ.push(i.offsetZ);break;default:throw new Error(`Invalid layout property provided: ${e}`)}}))}return t}decodeSpline(e,t,r){let i=t.length;for(let s=0;s<r.length;s++)t.forEach(((t,n)=>{let o;switch(t){case j.Property.X:o=e.splineX[s];break;case j.Property.Y:o=e.splineY[s];break;case j.Property.Z:o=e.splineZ[s];break;case j.Property.RED:o=e.red[s];break;case j.Property.GREEN:o=e.green[s];break;case j.Property.BLUE:o=e.blue[s];break;case j.Property.ALPHA:o=e.alpha[s]/255;break;case j.Property.SIZE:o=e.size[s];break;case j.Property.ROTATION:o=e.rotation[s];break;case j.Property.SCALE_X:o=e.scaleX[s];break;case j.Property.SCALE_Y:o=e.scaleY[s];break;case j.Property.SCALE_Z:o=e.scaleZ[s];break;case j.Property.OFFSET_X:o=e.offsetX[s];break;case j.Property.OFFSET_Y:o=e.offsetY[s];break;case j.Property.OFFSET_Z:o=e.offsetZ[s];break;default:throw new Error(`Invalid layout property provided: ${t.name}`)}r[s*i+n]=o}))}encodeSplineCompressed(e,t){let r=this.format.Stroke.SplineCompressed.create(),i=t.factors,s={},n=(e,r,n)=>{let o;if((n=Math.round(n*i[e]))>Number.MAX_INT32||n<-Number.MAX_INT32)throw new Error(`Int32 precision exceeded ${n} for precision with type ${e} and value ${t[e]}. This value is not applicable.`);return o=r in s?n-s[r]:n,s[r]=n,o};for(let t=0;t<e.length;t++){let i=e.getPoint(t);e.layout.forEach(((e,t)=>{switch(e){case j.Property.X:r.splineX.push(n("position","x",i.x));break;case j.Property.Y:r.splineY.push(n("position","y",i.y));break;case j.Property.Z:r.splineZ.push(n("position","z",i.z));break;case j.Property.RED:r.red.push(i.red);break;case j.Property.GREEN:r.green.push(i.green);break;case j.Property.BLUE:r.blue.push(i.blue);break;case j.Property.ALPHA:r.alpha.push(Math.round(255*i.alpha));break;case j.Property.SIZE:r.size.push(n("size","size",i.size));break;case j.Property.ROTATION:r.rotation.push(n("rotation","rotation",i.rotation));break;case j.Property.SCALE_X:r.scaleX.push(n("scale","scaleX",i.scaleX));break;case j.Property.SCALE_Y:r.scaleY.push(n("scale","scaleY",i.scaleY));break;case j.Property.SCALE_Z:r.scaleZ.push(n("scale","scaleZ",i.scaleZ));break;case j.Property.OFFSET_X:r.offsetX.push(n("offset","offsetX",i.offsetX));break;case j.Property.OFFSET_Y:r.offsetY.push(n("offset","offsetY",i.offsetY));break;case j.Property.OFFSET_Z:r.offsetZ.push(n("offset","offsetZ",i.offsetZ));break;default:throw new Error(`Invalid layout property provided: ${e}`)}}))}return r}decodeSplineCompressed(e,t,r,i){let s=t.length,n=i.factors,o={},a=(e,t,r)=>(t in o&&(r+=o[t]),o[t]=r,r/n[e]);for(let i=0;i<r.length;i++)t.forEach(((t,n)=>{let o;switch(t){case j.Property.X:o=a("position","x",e.splineX[i]);break;case j.Property.Y:o=a("position","y",e.splineY[i]);break;case j.Property.Z:o=a("position","z",e.splineZ[i]);break;case j.Property.RED:o=e.red[i];break;case j.Property.GREEN:o=e.green[i];break;case j.Property.BLUE:o=e.blue[i];break;case j.Property.ALPHA:o=e.alpha[i]/255;break;case j.Property.SIZE:o=a("size","size",e.size[i]);break;case j.Property.ROTATION:o=a("rotation","rotation",e.rotation[i]);break;case j.Property.SCALE_X:o=a("scale","scaleX",e.scaleX[i]);break;case j.Property.SCALE_Y:o=a("scale","scaleY",e.scaleY[i]);break;case j.Property.SCALE_Z:o=a("scale","scaleZ",e.scaleZ[i]);break;case j.Property.OFFSET_X:o=a("offset","offsetX",e.offsetX[i]);break;case j.Property.OFFSET_Y:o=a("offset","offsetY",e.offsetY[i]);break;case j.Property.OFFSET_Z:o=a("offset","offsetZ",e.offsetZ[i]);break;default:throw new Error(`Invalid layout property provided: ${t.name}`)}r[i*s+n]=o}))}encodeMatrix(e){if(e&&!e.isIdentity)return this.format.Matrix.create({m00:e.m11,m01:e.m12,m02:e.m13,m03:e.m14,m10:e.m21,m11:e.m22,m12:e.m23,m13:e.m24,m20:e.m31,m21:e.m32,m22:e.m33,m23:e.m34,m30:e.m41,m31:e.m42,m32:e.m43,m33:e.m44})}decodeMatrix(e){if(e)return M.fromMatrix([e.m00,e.m01,e.m02,e.m03,e.m10,e.m11,e.m12,e.m13,e.m20,e.m21,e.m22,e.m23,e.m30,e.m31,e.m32,e.m33])}reset(){this.state=void 0,this.ignoreSensorData=!1,this.cloneStroke=!1}}class Lr extends Cr{constructor(){super()}encode(e){if(0==e.length)return;let t={},r={},i={},s={},n={};e.forEach((e=>{let o=e.context;t[o.id]||(t[o.id]=o,n[o.environment.id]||(n[o.environment.id]=o.environment),r[o.sensorContext.id]||(r[o.sensorContext.id]=o.sensorContext,o.sensorContext.channelsContexts.forEach((e=>{i[e.device.id]||(i[e.device.id]=e.device),e.inkProvider&&(s[e.inkProvider.id]||(s[e.inkProvider.id]=e.inkProvider))}))))}));let o=this.format.InputData.create({sensorData:e.map((e=>this.encodeSensorData(e))),inputContextData:this.format.InputContextData.create({inputContexts:Object.values(t).map((e=>this.format.InputContext.create({id:P.toBytes(P.format(e.id)),environmentID:P.toBytes(P.format(e.environment.id)),sensorContextID:P.toBytes(P.format(e.sensorContext.id))}))),sensorContexts:Object.values(r).map((e=>this.format.SensorContext.create({id:P.toBytes(P.format(e.id)),sensorChannelsContext:e.channelsContexts.map((e=>this.format.SensorChannelsContext.create({id:P.toBytes(P.format(e.id)),channels:e.channels.map((e=>this.format.SensorChannel.create({id:P.toBytes(P.format(e.id)),type:e.type,metric:this.format.InkSensorMetricType[e.metric.name],resolution:e.resolution,min:e.min,max:e.max,precision:e.precision}))),samplingRateHint:e.samplingRate,latency:e.latency,inkInputProviderID:e.inkProvider?P.toBytes(P.format(e.inkProvider.id)):void 0,inputDeviceID:P.toBytes(P.format(e.device.id))})))}))),inkInputProviders:Object.values(s).map((e=>this.format.InkInputProvider.create({id:P.toBytes(P.format(e.id)),type:this.format.InkInputProviderType[e.type.name],properties:this.encodeProperties(e.props)}))),inputDevices:Object.values(i).map((e=>this.format.InputDevice.create({id:P.toBytes(P.format(e.id)),properties:this.encodeProperties(e.props)}))),environments:Object.values(n).map((e=>this.format.Environment.create({id:P.toBytes(P.format(e.id)),properties:this.encodeProperties(e.props)})))})});return Cr.encode(o)}decode(e){if(!e)return[];let t=Cr.decode(e,this.format.InputData),r={},i={},s={},n={},o={};return t.inputContextData.environments.forEach((e=>{let t=new X;this.decodeProperties(e.properties,t.props),Object.freeze(t),t.id!=P.fromBytes(e.id).replace(/-/g,"")&&console.warn(`Environment decode id missmatch - found ${P.fromBytes(e.id).replace(/-/g,"")}, expected ${t.id}`),o[t.id]=t})),t.inputContextData.inkInputProviders.forEach((e=>{let t=this.decodeProperties(e.properties),r=new S(S.Type[this.format.InkInputProviderType[e.type]],t);Object.freeze(r),r.id!=P.fromBytes(e.id).replace(/-/g,"")&&console.warn(`InkInputProvider decode id missmatch - found ${P.fromBytes(e.id).replace(/-/g,"")}, expected ${r.id}`),n[r.id]=r})),t.inputContextData.inputDevices.forEach((e=>{let t=new te;this.decodeProperties(e.properties,t.props),Object.freeze(t),t.id!=P.fromBytes(e.id).replace(/-/g,"")&&console.warn(`InputDevice decode id missmatch - found ${P.fromBytes(e.id).replace(/-/g,"")}, expected ${t.id}`),s[t.id]=t})),t.inputContextData.sensorContexts.forEach((e=>{let t=new W;e.sensorChannelsContext.forEach((e=>{let r=new q(s[P.fromBytes(e.inputDeviceID).replace(/-/g,"")],n[P.fromBytes(e.inkInputProviderID).replace(/-/g,"")]);e.samplingRateHint&&(r.samplingRate=e.samplingRateHint),e.latency&&(r.latency=e.latency),e.channels.forEach((e=>{let t=Z.Metric[this.format.InkSensorMetricType[e.metric]],i=new Z(e.type,t,e.resolution,e.min,e.max);i.precision=e.precision,r.add(i),i.id!=P.fromBytes(e.id).replace(/-/g,"")&&console.warn(`SensorChannel decode id missmatch - found ${P.fromBytes(e.id).replace(/-/g,"")}, expected ${i.id}`)})),t.addContext(r),r.id!=P.fromBytes(e.id).replace(/-/g,"")&&console.warn(`SensorChannelsContext decode id missmatch - found ${P.fromBytes(e.id).replace(/-/g,"")}, expected ${r.id}`)})),Object.freeze(t),i[t.id]=t,t.id!=P.fromBytes(e.id).replace(/-/g,"")&&console.warn(`SensorContext decode id missmatch - found ${P.fromBytes(e.id).replace(/-/g,"")}, expected ${t.id}`)})),t.inputContextData.inputContexts.forEach((e=>{let t=new K(o[P.fromBytes(e.environmentID).replace(/-/g,"")],i[P.fromBytes(e.sensorContextID).replace(/-/g,"")]);Object.freeze(t),t.id!=P.fromBytes(e.id).replace(/-/g,"")&&console.warn(`InputContext decode id missmatch - found ${P.fromBytes(e.id).replace(/-/g,"")}, expected ${t.id}`),r[t.id]=t})),t.sensorData.map((e=>this.decodeSensorData(e,r[P.fromBytes(e.inputContextID).replace(/-/g,"")])))}encodeSensorData(e){let t=this.format.SensorData.create({id:P.toBytes(e.id),inputContextID:P.toBytes(P.format(e.context.id)),state:this.format.InkState[e.inkState.name],timestamp:e.created});return e.streams.forEach((e=>{let r={};e.channels.forEach((e=>r[e.id]=[]));for(let t=0;t<e.length;t++){let i=e.get(t);e.channels.forEach((e=>{r[e.id].push(i[L.getPropName(e.name)])}))}e.channels.forEach((e=>{if(!("precision"in e))throw new Error(`Precision not found for channel with id: ${e.id}`);let i=r[e.id];if(0==i.length)return;let s=10**e.precision,n=Math.round(i[0]*s),o=this.format.ChannelData.create({sensorChannelID:P.toBytes(P.format(e.id))});o.values.push(n);for(let e=1;e<i.length;e++){let t=Math.round(i[e]*s);o.values.push(t-n),n=t}t.dataChannels.push(o)}))})),t}decodeSensorData(e,t){if(0==e.dataChannels.length)throw new Error(`Not found corresponding data channels for sensor data with id: ${P.fromBytes(e.id)}`);let r=new Q(t,P.fromBytes(e.id));r.created=parseInt(E.fromValue(e.timestamp).toString()),r.inkState=Q.InkState[this.format.InkState[e.state]];let i={};return e.dataChannels.forEach((e=>{let r=P.fromBytes(e.sensorChannelID).replace(/-/g,"");if(0==e.values.length)return void(i[r]=[]);let s=t.sensorContext.getContextByChannelID(r);if(!s)throw new Error(`Not found corresponding channel context for data with channelID ${r}`);let n=10**s.get(r).precision,o=e.values[0],a=[];a.push(o/n);for(let t=1;t<e.values.length;t++){let r=o+e.values[t];a.push(r/n),o=r}i[r]=a})),t.sensorContext.channelsContexts.forEach((e=>{let t=new ee(e.channels),s=i[e.channels.first.id];if(s){let r=s.length;for(let s=0;s<r;s++)e.channels.forEach((e=>{let r=i[e.id];if(!r)throw new Error(`Not found corresponding data for channel ${e.type} with id: ${e.id}`);t.data.push(r[s])}))}else{if(t.ink)throw new Error("Empty ink stream is not allowed");{let t=0;if(e.channels.forEach((e=>{i[e.id]&&(t+=i[e.id].length)})),t>0)throw new Error(`Un-alligned channels context is not valid, found with id: ${e.id}`)}}r.add(t)})),r}encodeProperties(e){return Object.keys(e).map((t=>this.format.Property.create({name:t,value:e[t]})))}decodeProperties(e,t={}){return Object.assign(t,...e.map((e=>({[e.name]:e.value}))))}}class _r extends Cr{constructor(){super()}async encode(e){if(0==e.length)return;let t=this.format.Brushes.create();for(let r of e)if(r instanceof Oe){let e=this.encodeBrush2D(r);t.vectorBrushes.push(e)}else{let e=await this.encodeBrushGL(r);t.rasterBrushes.push(e)}return Cr.encode(t)}decode(e){if(!e)return{};let t=Cr.decode(e,this.format.Brushes),r={};return t.vectorBrushes.forEach((e=>r[e.name]=this.decodeBrush2D(e))),t.rasterBrushes.forEach((e=>r[e.name]=this.decodeBrushGL(e))),r}encodeBrush2D(e){if(!e.name)throw new Error("Encode Brush2D failed. name property is required.");let t=this.format.VectorBrush.create({name:e.name,spacing:e.spacing}),r=Array.isArray(e.shape)?e.shape:[e.shape];for(let e of r){let r=this.format.BrushPrototype.create({size:e.size});if(e.descriptor.shape.name)r.shapeURI=e.descriptor.shape.name;else{let t=e.shape;for(let e=0;e<t.shape.length;e++)r.coordX.push(t.shape.getPointX(e)),r.coordY.push(t.shape.getPointY(e))}t.prototype.push(r)}return t}decodeBrush2D(e){if(ie.instance&&ie.instance[e.name]){if(ie.instance[e.name]instanceof Oe)return ie.instance[e.name];throw new Error(`URI conflict detected, ${e.name} expected Brush2D, found ${ie.instance[e.name].constructor.name}`)}let t=[];return e.prototype.forEach((e=>{let r;if(e.shapeURI)r=e.shapeURI;else{r=Float32Array.createSharedInstance(2*e.coordX.length);for(let t=0;t<r.length/2;t++)r[2*t]=e.coordX[t],r[2*t+1]=e.coordY[t]}t.push(new we(r,e.size))})),new Oe(e.name,t,e.spacing)}async encodeBrushGL(e){if(!e.name)throw new Error("Encode BrushGL failed. name property is required.");let t={shape:[],shapeURI:[],fill:void 0,filleURI:void 0};if(Array.isArray(e.shape)){let r=e.descriptor.shape.map((e=>e.name)).filter((e=>e));if(r.length>0){if(r.length!=e.shape.length)throw new Error(`Brush ${e.name} shape names length do not match with brush mipmap`);t.shapeURI=r}}else e.descriptor.shape.name&&t.shapeURI.push(e.descriptor.shape.name);if(t.fillURI=e.descriptor.fill.name,0==t.shapeURI.length||!t.fillURI){let r={shape:await e.getShapeBinary(),fill:await e.getFillBinary()};0==t.shapeURI.length&&(Array.isArray(e.shape)?t.shape=r.shape:t.shape.push(r.shape)),t.fillURI||(t.fill=r.fill)}let r=e.blendMode.replace(/-/g,"_").toUpperCase();return this.format.RasterBrush.create({name:e.name,spacing:e.spacing,scattering:e.scattering,blendMode:this.format.BlendMode[r],rotationMode:this.format.RotationMode[e.rotationMode.name],shapeTexture:t.shape,shapeTextureURI:t.shapeURI,fillTexture:t.fill,fillTextureURI:t.fillURI,fillWidth:e.fillTextureSize.width,fillHeight:e.fillTextureSize.height,randomizeFill:e.randomizeFill})}decodeBrushGL(e){if(ie.instance&&ie.instance[e.name]){if(ie.instance[e.name]instanceof Ye)return ie.instance[e.name];throw new Error(`URI conflict detected, ${e.name} expected BrushGL, found ${ie.instance[e.name].constructor.name}`)}let t,r;if(e.shapeTextureURI.length>0)t=1==e.shapeTextureURI.length?{name:e.shapeTextureURI.first}:e.shapeTextureURI.map((e=>({name:e})));else{if(!(e.shapeTexture.length>0))throw new Error("Decode BrushGL shape - insufficent data found");t=1==e.shapeTexture.length?{value:e.shapeTexture.first}:e.shapeTexture.map((e=>({value:e})))}if(e.fillTextureURI)r={name:e.fillTextureURI};else{if(!e.fillTexture)throw new Error("Decode BrushGL fill - insufficent data found");r={value:e.fillTexture}}return new Ye(e.name,t,r,{spacing:e.spacing,scattering:e.scattering,blendMode:Ne[this.format.BlendMode[e.blendMode]],rotationMode:Ye.RotationMode[e.rotationMode]},{randomize:e.randomizeFill,size:{width:e.fillWidth,height:e.fillHeight}})}}class Fr extends Cr{constructor(){super()}encode(e){if(!e||0==e.length)return;let t=this.format.TripleStore.create({statements:e.map((e=>this.format.TripleStore.SemanticTriple.create({subject:e.subject,predicate:e.predicate,object:e.object})))});return Cr.encode(t)}decode(e){if(!e)return;let t=Cr.decode(e,this.format.TripleStore);return new xr(...t.statements)}}class Br extends I{constructor(e){super(e)}}class Ur extends Br{constructor(e){let t;super(e),Object.defineProperty(this,"bounds",{get:()=>(t||(t=this.getBounds()),t),set:e=>t=e,enumerable:!0}),Object.defineProperty(this,"boundsValue",{get:()=>t}),Object.defineProperty(this,"root",{get:function(){let e=this.parent,t=this;for(;e;)t=e,e=e.parent;return t},enumerable:!0})}getBounds(){throw new Error("getBounds is abstract, should be implemented")}invalidateBounds(){this.preventInvalidateBounds||(this.bounds=void 0,this.parent&&this.parent.invalidateBounds())}remove(){this.parent.removeChild(this)}}class jr extends Ur{constructor(e){let t;super(e),this.children=[],Object.defineProperty(this,"uri",{get:()=>(t||(t=J.createNodeURI(this.root.model,this.id)),t),enumerable:!0}),Object.defineProperty(this,"type",{value:"GROUP",enumerable:!0}),Object.defineProperty(this,"content",{value:this.children,enumerable:!0})}getBounds(){let e;return this.children.forEach((t=>{e=e?e.union(t.bounds):t.bounds})),e}contains(e){if(!(e instanceof Ur))throw new Error(`Incompatible node found - ${e.constructor.name}. It should be ink model Element.`);let t=!1,r=e.parent;for(;r;){if(r==this){t=!0;break}r=r.parent}return t}indexOf(e){if(!(e instanceof Ur))throw new Error(`Incompatible node found - ${e.constructor.name}. It should be ink model Element.`);return this.children.indexOf(e)}appendChild(e,t){if(!(e instanceof Ur))throw new Error(`Incompatible node found - ${e.constructor.name}. It should be ink model Element.`);if(t<0)throw new Error("Index should be a positive number");let r=e.parent;if(r){if(this.root.id!=e.root.id)throw new Error("Moving nodes from one hierarchy to another is not allowed. Make sure root is common for this operation.");e.parent.children.remove(e),e.parent.invalidateBounds()}if(e.parent=this,isFinite(t)&&t<this.children.length?this.children.insert(e,t):this.children.push(e),!r){let r=this.root.model;r&&r.register(e,t)}return this.invalidateBounds(),e}removeChild(e){if(!this.children.includes(e))throw new Error("Node was not found");let t=this.root.model;t&&t.unregister(e),this.invalidateBounds(),this.children.remove(e)}remove(){this.parent?this.parent.removeChild(this):(this.model&&this.model.unregister(this),this.invalidateBounds())}}class Gr extends Ur{constructor(e,t){super(),Object.defineProperty(this,"uri",{get:()=>this.id,enumerable:!0}),Object.defineProperty(this,"type",{value:"PATH",enumerable:!0}),Object.defineProperty(this,"index",{get:()=>this.parent?this.parent.indexOf(this):0,enumerable:!0}),Object.defineProperty(this,"content",{value:e,enumerable:!0}),Object.defineProperty(this,"fragment",{value:t,enumerable:!0}),Object.defineProperty(this,"interval",{get:()=>(console.warn("Element Path interval is deprecated. Use fragment property to get path part. fromIndex and toIndex are accessible as fromPointIndex, toPointIndex."),this.fragment&&(this.fragment.fromIndex=this.fragment.fromPointIndex,this.fragment.toIndex=this.fragment.toPointIndex),this.fragment),enumerable:!0})}buildURI(){return J.createNodeURI(this.root.model,this.content.id,this.fragment)}getBounds(){if(this.fragment){let e=this.content.slice(this.fragment);return e.brush instanceof Oe&&e.buildPath({lastPipelineStage:Ht.BRUSH_APPLIER}),e.bounds}return this.content.bounds}split(e,t=1){if(this.content instanceof Q)throw new Error("SensorData is immutable. Split is not applicable.");if(!this.parent)throw new Error("Dettached Path node split is not allowed. Attach to hierarchy first.");if(e<0||e>this.content.length-1)throw new Error(`Index out of range {0, ${this.content.length-1}}`);let r=this.fragment?this.fragment.fromPointIndex:0,i=this.fragment?this.fragment.toPointIndex:this.content.length-1,s=this.fragment?this.fragment.fromTValue:this.content.ts,n=this.fragment?this.fragment.toTValue:this.content.tf,o=new me(this.content.spline,r,e+1,s,t-.05),a=new me(this.content.spline,e-1,i,1==t?.05:t,n);if(o.toPointIndex+1-o.fromPointIndex<4)throw new Error(`Invalid split index ${e} found - range {${o.fromPointIndex}, ${o.toPointIndex}} is invalid. At least 4 points are needed to define path fragment.`);if(a.toPointIndex+1-a.fromPointIndex<4)throw new Error(`Invalid split index ${e} found - range {${a.fromPointIndex}, ${a.toPointIndex}} is invalid. At least 4 points are needed to define path fragment.`);let l=new Gr(this.content,o),h=new Gr(this.content,a),d=this.index;return this.remove(),this.parent.appendChild(l,d),this.parent.appendChild(h,d+1),[l,h]}}class $r extends Tr{constructor(e,t,r){super(t.type,e),this.model=t,this.root=this.createGroup(r),this.root.model=this,Object.defineProperty(this,"tree",{get:()=>(console.warn("View 'tree' property is deprecated. Use root instead."),this.root)}),this.register(this.root)}addPath(e,t){return t||(t=this.root),t.appendChild(this.createElement(e))}createElement(e,t){if(t&&!(t instanceof me))throw new Error("fragment expected type is PathFragment");return this.model.createElement(e,this,t)}createGroup(e){return this.model.createGroup(e,this)}register(e){if(e instanceof jr)e.children.forEach((e=>this.register(e)));else{if(!(e instanceof Gr))throw new Error(`Register unknown node found: ${e.id}`);if(e.content instanceof hr){if(this.type!=$r.Type.STROKE)throw new Error(`Incompatible element content found - ${e.content.constructor.name}. Content should be instance of Stroke.`)}else{if(!(e.content instanceof Q))throw new Error(`Incompatible element content found - ${e.content.constructor.name}. Content should be ${this.type.name}.`);if(this.type!=$r.Type.SENSOR_DATA)throw new Error(`Incompatible element content found - ${e.content.constructor.name}. Content should be instance of SensorData.`)}if(!this.model.content.includes(e.content))throw new Error(`Node content not found in underling ink model - ${e.content.id}`)}this.model.index(e),this.updateKnowledgeGraph(e)}unregister(e){e instanceof jr&&e.children.forEach((e=>this.unregister(e))),delete this.model.registry.nodes[e.uri],this.updateKnowledgeGraph(e)}updateKnowledgeGraph(e){if(this.model.registry.nodes[e.uri]){if(!this.knowledgeGraph)return;this.knowledgeGraph.filter((t=>t.subject==e.uri||t.object==e.uri)).forEach((t=>{t.subject==e.uri&&t.object.startsWith("uim:ne/")&&this.model.knowledgeGraph.add(...this.knowledgeGraph.filter((e=>e.subject==t.object))),this.model.knowledgeGraph.add(t)}))}else this.model.knowledgeGraph.filter((t=>t.subject==e.uri||t.object==e.uri)).forEach((t=>{t.subject==e.uri&&t.object.startsWith("uim:ne/")&&this.model.knowledgeGraph.remove(...this.model.knowledgeGraph.filter((e=>e.subject==t.object))),this.model.knowledgeGraph.remove(t)}))}extractKnowledge(){let e=this.model.knowledgeGraph.filter((e=>e.subject.startsWith(J.createNodeURISchema(this)))),t=new Set(e.map((e=>e.object)));for(;t.size>0;){let r=this.model.knowledgeGraph.filter((r=>t.has(r.subject)&&!e.includes(r)));e.push(...r),t=new Set(r.map((e=>e.object)))}return e}}class Yr extends Tr{constructor(e=Yr.Type.STROKE,t){super(e),this.root=this.createGroup(t),this.root.model=this,Object.defineProperty(this,"tree",{get:()=>(console.warn("InkModel 'tree' property is deprecated. Use root instead."),this.root)}),this.props={},this.views={},this.unitScaleFactor=1,this.transform=void 0,this.knowledgeGraph=new xr,this.knowledgeGraphAnalyzer=new ur(this),Object.defineProperty(this,"registry",{value:{nodes:{},content:{},brushes:{}},enumerable:!0}),this.type==Yr.Type.STROKE?this.registry.sensorData={}:Object.defineProperty(this.registry,"sensorData",{get:()=>this.content,enumerable:!0}),Object.defineProperty(this,"content",{value:[],enumerable:!0}),Object.defineProperty(this,"strokes",{get:()=>this.type==Yr.Type.STROKE?this.content.slice():[],enumerable:!0}),Object.defineProperty(this,"sensorData",{get:()=>{let e;if(this.type==Yr.Type.STROKE){let t={};this.content.forEach((e=>{e.sensorData&&(t[e.sensorData.id]=e.sensorData)})),this.disableSensorDataIntegrity&&Object.keys(this.registry.sensorData).forEach((e=>t[e]=this.registry.sensorData[e])),e=Object.values(t)}else e=this.content;return e},set:e=>{if(!(e instanceof Q))throw new Error("Data type mismatch, expected SensorData");if(this.type==Yr.Type.SENSOR_DATA)throw new Error("For SensorData models use 'addPath' method instead");this.index(e)},enumerable:!0}),Object.defineProperty(this,"brushes",{get:()=>{let e={};return this.strokes.forEach((t=>e[t.brush.name]=this.registry.brushes[t.brush.name]||t.brush)),Object.values(e)},set:e=>{e.forEach((e=>this.index(e)))},enumerable:!0}),this.register(this.root),this.disableSensorDataIntegrity=!0}addPath(e,t){t||(t=this.root);let r=this.createElement(e);return e.sensorData&&this.index(e.sensorData),e.brush&&this.index(e.brush),t.appendChild(r)}removePath(e){e.nodeID&&this.registry.nodes[e.nodeID].remove()}replacePath(e,t,r=!1){if(!e.nodeID)return;let i=this.getNode(e.nodeID),s=i.parent||this.root,n=t.map((e=>this.createElement(e))),o=s.children.indexOf(i);if(r){let e=s.appendChild(this.createGroup(),o);n.forEach((t=>e.appendChild(t)))}else n.forEach(((e,t)=>s.appendChild(e,o+t)));this.removePath(e)}createElement(e,t,r){if(!e)throw new Error("Element content not found");let i=t?t.type:this.type;switch(i){case Yr.Type.STROKE:if(!(e instanceof hr))throw new Error(`Incompatible element content found - ${e.constructor.name}. Content should be instance of Stroke.`);if(r&&!t)throw new Error("Main tree is not fragmentable. Fragments are applicable only in Views.");break;case Yr.Type.SENSOR_DATA:if(!(e instanceof Q))throw new Error(`Incompatible element content found - ${e.constructor.name}. Content should be instance of SensorData.`);if(r)throw new Error("SensorData fragments are not supported");break;default:throw console.warn(i),new Error("Invalid ink model type found")}return new Gr(e,r)}createGroup(e,t){return new jr(e)}getItem(e){return console.warn("InkModel getItem method is deprecated. Use oneof(getNode(id), getStroke(id), getSensorData(id), getBrush(id))."),this.registry.nodes[e]||this.registry.content[e]||this.registry.sensorData[e]||this.registry.brushes[e]}getNode(e){let t;if(L.isValidURL(e))t=this.registry.nodes[e];else{let r=[this,...Object.values(this.views)];for(let i of r){let r=J.createNodeURI(i,e);if(t=this.registry.nodes[r],t)break}}return t}getPath(e){return this.registry.content[e]}getStroke(e){return this.type==Yr.Type.STROKE?this.registry.content[e]:void 0}getSensorData(e){return this.registry.sensorData[e]}getBrush(e){return this.registry.brushes[e]}register(e,t){if(e instanceof jr)e.children.forEach((e=>this.register(e)));else{if(!(e instanceof Gr))throw new Error(`Register unknown node found: ${e.id}`);if(e.content instanceof hr){if(this.type!=Yr.Type.STROKE)throw new Error(`Incompatible element content found - ${e.content.constructor.name}. Content should be instance of Stroke.`)}else{if(!(e.content instanceof Q))throw new Error(`Incompatible element content found - ${e.content.constructor.name}. Content should be ${this.type.name}.`);if(this.type!=Yr.Type.SENSOR_DATA)throw new Error(`Incompatible element content found - ${e.content.constructor.name}. Content should be instance of SensorData.`)}Object.defineProperty(e.content,"nodeID",{value:e.id,enumerable:!0,configurable:!0}),isFinite(t)&&t<this.content.length?this.content.insert(e.content,t):this.content.push(e.content),this.index(e.content)}this.index(e),this.resetViews()}index(e){let t,r=e.id;if(e instanceof Br){r=e.uri,t="nodes";let i=this.type.name;e instanceof jr&&(i=`ol<${i}>`),Object.defineProperty(e,"dataType",{value:i,enumerable:!0})}else e instanceof hr?t="content":e instanceof Q?t=this.type==Yr.Type.SENSOR_DATA?"content":"sensorData":e instanceof oe&&(t="brushes");if(!t)throw new Error("Expected item type is oneof(InkNode, Stroke, SensorData, Brush)");{let i=this.registry[t];if(i[r]){if(i[r]!=e)throw new Error(`Cannot register ${t} item with id ${r}. Already is available item with such identifier.`)}else i[r]=e}}unregister(e){this.resetViews(),e instanceof jr?e.children.forEach((e=>this.unregister(e))):e instanceof Gr&&(delete e.content.nodeID,delete this.registry.content[e.content.id],this.content.remove(e.content)),e==this.root?e.children.clear():delete this.registry.nodes[e.uri]}createView(e,t,r){let i=new $r(e,this,t);return this.views[e]=i,r&&(i.knowledgeGraph=r,i.updateKnowledgeGraph(i.root)),i}resetViews(){if(!this.keepViews){for(let e in this.views)this.views[e].root.remove(),delete this.views[e];this.knowledgeGraph.length>0&&this.knowledgeGraphAnalyzer.clean()}}static createCopyInstance(e){let t=new Yr(e.type,e.root.id);t.id=e.id,t.props=e.props,t.transform=e.transform,t.unitScaleFactor=e.unitScaleFactor,t.knowledgeGraph=e.knowledgeGraph.clone(),e.type==Yr.Type.STROKE&&(Object.values(e.registry.sensorData).forEach((e=>t.index(e))),Object.values(e.registry.brushes).forEach((e=>t.index(e))));let r=(e,t)=>{e.children.forEach((e=>{if("PATH"==e.type){let r=t.root.model.createElement(e.content);t.appendChild(r)}else{if("GROUP"!=e.type)throw new Error(`Unknown node type found: ${e.type}`);{let i=t.root.model.createGroup(e.id);t.appendChild(i),r(e,i)}}}))};return r(e.root,t.root),Object.values(e.views).forEach((e=>{let i=t.createView(e.name,e.root.id);r(e.root,i.root)})),t}}class Xr extends Cr{constructor(){super()}encode(e){let t=this.format.InkStructure.create({type:this.format.StructureType[e.type.name],inkTree:this.format.InkTree.create({tree:this.encodeNodeTree(e)}),views:Object.values(e.views).map((e=>this.encodeView(e)))});return Cr.encode(t)}decode(e,t,r){if(!e)return;let i=Cr.decode(e,this.format.InkStructure),s=i.type==this.format.StructureType.STROKE?Yr.Type.STROKE:Yr.Type.SENSOR_DATA,n=s==Yr.Type.STROKE?t:r,o=new Yr(s,P.fromBytes(i.inkTree.tree.first.groupID)),a=i.inkTree.tree.first.bounds;return a&&(o.root.bounds=new v(a.x,a.y,a.width,a.height)),this.decodeNodeTree(o,i.inkTree.tree.slice(1),n),i.views.forEach((e=>this.decodeView(e,o,n))),s==Yr.Type.STROKE&&r.forEach((e=>o.index(e))),o}encodeView(e){return this.format.InkTree.create({name:e.name,tree:this.encodeNodeTree(e)})}decodeView(e,t,r,i){let s=e.tree.first,n=P.fromBytes(s.groupID);if(!t.views[e.name]||t.views[e.name].root.id!=n){let s=t.createView(e.name,n,i),o=e.tree.first.bounds;o&&(s.root.bounds=new v(o.x,o.y,o.width,o.height)),this.decodeNodeTree(s,e.tree.slice(1),r),s.invalid&&(console.warn(`Drop view ${s.uri} due to invalid structure`),delete t.views[s.name],t.knowledgeGraphAnalyzer.clean())}}encodeNodeTree(e){let t=[];return t.push(this.encodeNode(e.root,0)),this.addChildren(t,e,e.root.children,1),t}addChildren(e,t,r,i){r.forEach((r=>{let s=r instanceof Gr?(t.model||t).content.indexOf(r.content):void 0;e.push(this.encodeNode(r,i,s)),r instanceof jr&&this.addChildren(e,t,r.children,i+1)}))}encodeNode(e,t,r){let i=this.format.Node.create({depth:t,bounds:e.boundsValue});return e instanceof jr?i.groupID=P.toBytes(e.id):i.index=r,e.fragment&&(i.interval=this.format.Interval.create({fromIndex:e.fragment.fromPointIndex,toIndex:e.fragment.toPointIndex,fromTValue:e.fragment.fromTValue,toTValue:e.fragment.toTValue})),i}decodeNodeTree(e,t,r){if(e.invalid)return;let i=e.root,s=0,n={};for(let o of t){for(;s>=o.depth;)i=i.parent,s--;if(i.preventInvalidateBounds=!0,"groupID"==o.id){if(!(i instanceof jr))throw new Error("Incorrect tree structure, a tree node is not a Group instance and cannot contain child nodes.");i=i.appendChild(e.createGroup(P.fromBytes(o.groupID))),o.bounds&&(i.bounds=new v(o.bounds.x,o.bounds.y,o.bounds.width,o.bounds.height))}else{let t;if(o.interval){if(e instanceof Yr)throw new Error("Intervals are not applicable for InkModel, only View allow intervals");if(e.type==Yr.Type.STROKE){let i=r[o.index];try{t=new me(i.spline,o.interval.fromIndex,o.interval.toIndex,o.interval.fromTValue,o.interval.toTValue),n[i.id]?n[i.id].forEach((e=>{if(t.overlaps(e))throw new Error(`Overlapped fragments are not allowed. ${t} overlaps ${e}`)})):n[i.id]=[],n[i.id].push(t)}catch(t){if(Yr.reservedViewNames.includes(e.name))return console.warn(`invalid path fragment content id: ${i.id} - ${t.message}`),void(e.invalid=!0);throw t}}else console.warn(`Intervals are not applicable for SensorData models, only Stroke models allow intervals. Model ${e.name} discards interval.`)}if(e.type==Yr.Type.STROKE&&Yr.reservedViewNames.includes(e.name)){let i=r[o.index],s=J.createNodeURI(e,i.id,t);if((e.model||e).getNode(s))return console.warn(`duplicate path node ${s}`),void(e.invalid=!0)}let s=e.createElement(r[o.index],t);i=i.appendChild(s)}delete i.parent.preventInvalidateBounds,s=o.depth}}}class zr extends Cr{constructor(){super()}encode(e={}){let t=this.format.Properties.create({properties:Object.keys(e).map((t=>this.format.Property.create({name:t,value:e[t]})))});return 0==t.properties.length?void 0:Cr.encode(t)}decode(e){if(!e)return;let t=Cr.decode(e,this.format.Properties);return Object.assign({},...t.properties.map((e=>({[e.name]:e.value}))))}}class Vr extends Cr{constructor(){super(),this.brushesCodec=new _r}async encode(e,t={},r={},i=Ne.SOURCE_OVER){let s=[];isFinite(r.red)&&s.push(Vr.ColorIndex.indexOf("RED")),isFinite(r.green)&&s.push(Vr.ColorIndex.indexOf("GREEN")),isFinite(r.blue)&&s.push(Vr.ColorIndex.indexOf("BLUE")),isFinite(r.alpha)&&s.push(Vr.ColorIndex.indexOf("ALPHA"));let n=L.encodeBitMask(s),o=this.format.InkTool.create({vectorBrush:e instanceof Oe?this.brushesCodec.encodeBrush2D(e):void 0,rasterBrush:e instanceof Ye?await this.brushesCodec.encodeBrushGL(e):void 0,context:this.format.PathPointContext.create({statics:vr.encodePathPointProperties(r,this.format.PathPointProperties.create()),dynamics:this.encodePathPointSettings(t),colorMask:n})});if(i!=Ne.SOURCE_OVER){let e=i.replace(/-/g,"_").toUpperCase();o.blendMode=this.format.BlendMode[e]}return Cr.encode(o)}decode(e){if(!e)return;let t=Cr.decode(e,this.format.InkTool),r=L.decodeBitMask(t.context.colorMask).map((e=>j.Property[Vr.ColorIndex[e]])),i=[j.Property.RED,j.Property.GREEN,j.Property.BLUE,j.Property.ALPHA].filter((e=>!r.includes(e)));return{brush:"vectorBrush"==t.brush?this.brushesCodec.decodeBrush2D(t.vectorBrush):this.brushesCodec.decodeBrushGL(t.rasterBrush),blendMode:Ne[this.format.BlendMode[t.blendMode]],statics:vr.decodePathPointProperties(t.context.statics,i),dynamics:this.decodePathPointSettings(t.context.dynamics)}}encodePathPointSettings(e){let t=this.format.PathPointSettings.create();for(let r in this.format.PathPointSettings.fields)e[r]&&!e[r].disabled&&(t[r]=this.encodePropertySettings(r,e[r]));return t}decodePathPointSettings(e){if(!e)return;let t={};for(let r in this.format.PathPointSettings.fields)e[r]&&(t[r]=this.decodePropertySettings(e[r]));return t}encodePropertySettings(e,t){let r=t=>{if(t)return this.format.Range.create({min:t.min,max:t.max,remapURI:this.getActionDescriptorName(e,"Remap",t.remap)})};return this.format.PropertySettings.create({value:r(t.value),velocity:r(t.velocity),pressure:r(t.pressure),altitude:r(t.altitude),radiusX:r(t.radiusX),radiusY:r(t.radiusY),resolveURI:this.getActionDescriptorName(e,"Resolve",t.resolve),dependencies:L.encodeBitMask((t.dependencies||[]).map((e=>Vr.InputPropertyTypeIndex.indexOf(Z.getTypeName(e)))))||void 0})}getActionDescriptorName(e,t,r){if(r){if("function"==typeof r)throw new Error(`Encode '${e}' property failed. ${t} action name property is required. Please provide ActionDescriptor for it's definition.`);if("string"==typeof r)return r;if(r.name)return r.name;throw new Error(`Encode '${e}' property failed. ${t} action name property is required. Please provide ActionDescriptor for it's definition.`)}}decodePropertySettings(e){let t={},r=(e,r)=>{r&&(t[e]={min:r.min,max:r.max,remap:r.remapURI})};r("value",e.value),r("velocity",e.velocity),r("pressure",e.pressure),r("altitude",e.altitude),r("radiusX",e.radiusX),r("radiusY",e.radiusY),t.resolve=e.resolveURI;let i=L.decodeBitMask(e.dependencies).map((e=>Z.Type[Vr.InputPropertyTypeIndex[e]]));return i.length>0&&(t.dependencies=i),t}}Vr.InputPropertyTypeIndex=Object.freeze([void 0,"PRESSURE","RADIUS_X","RADIUS_Y","AZIMUTH","ALTITUDE","ROTATION"]),Vr.ColorIndex=Object.freeze([void 0,"RED","GREEN","BLUE","ALPHA"]);let Hr=new TextEncoder;const Zr=3,qr=1,Wr=0,Kr={extension:"uim",contentType:"application/vnd.wacom-ink.model",description:"Universal Ink Model",fourCC:{format:Hr.encode("UINK"),InkObject:Hr.encode("DATA"),Properties:Hr.encode("PRPS"),InputData:Hr.encode("INPT"),Brushes:Hr.encode("BRSH"),InkData:Hr.encode("INKD"),InkStructure:Hr.encode("INKS"),TripleStore:Hr.encode("KNWG")}};Object.defineProperty(Kr,"version",{value:`${Zr}.${qr}.${Wr}`}),Object.defineProperty(Kr,"serial",{value:new Uint8Array([Zr,qr,Wr])});class Jr extends jt{static WORKER_NAME="SegmentsProvider";constructor(){super(Jr.WORKER_NAME,Jr.buildWorkerURL(),jt.WorkerType.CLASSIC),this.state={}}static buildWorkerURL(){if(("undefined"==typeof document?new(require("url").URL)("file:"+__filename).href:document.currentScript&&document.currentScript.src||new URL("digital-ink-min.cjs",document.baseURI).href).contains("/wacom-src/"))return`/node_modules/digital-ink/workers/${Jr.WORKER_NAME}.js`;if("function"!=typeof DedicatedWorkerGlobalScope){let e="undefined"==typeof __location?"undefined"==typeof document?new(require("url").URL)("file:"+__filename).href:document.currentScript&&document.currentScript.src||new URL("digital-ink-min.cjs",document.baseURI).href:__location;return e=e.substring(0,e.lastIndexOf("/")),e.endsWith("workers")||(e+="/workers"),e+=`/${Jr.WORKER_NAME}`,"undefined"==typeof navigator?e+=".mjs":e+=".js",e}}async importBrushes(e){let t=this.nextID;return this.state[t]={expected:this.workers.length},await this.broadcastMessage({action:"IMPORT_BRUSHES",actionID:t,brushes:e.map((e=>e.toJSON()))})}async importSpline(e,t){let r=this.nextID;return this.state[r]={expected:this.workers.length},await this.broadcastMessage({action:"IMPORT_SPLINE",actionID:r,strokeID:e,spline:t.toJSON()})}async removeSpline(e){let t=this.nextID;return this.state[t]={expected:this.workers.length},await this.broadcastMessage({action:"REMOVE_SPLINE",actionID:t,strokeID:e})}async buildStrokeSegments(e){await this.importSpline(e.id,e.spline);let t=this.nextID;return this.state[t]={strokeID:e.id,brushName:e.brush.name,indices:new Array(e.segmentsCount).fill(0).map(((e,t)=>t)),segments:[],count:e.segmentsCount,expected:e.segmentsCount},await this.broadcast("BUILD_STROKE_SEGMENT",t)}buildRequestMessage(e,t){let r={action:e,actionID:t},i=this.state[t];if("BUILD_STROKE_SEGMENT"!=e)throw new Error(`Unknow data action found: ${e}`);{let e=i.indices.shift();if(isNaN(e))return;r.index=e,r.strokeID=i.strokeID,r.brushName=i.brushName}return r}recieve(e){let t,r=this.state[e.actionID];switch(r.expected--,e.action){case"IMPORT_BRUSHES":case"IMPORT_SPLINE":case"REMOVE_SPLINE":break;case"BUILD_STROKE_SEGMENT":if(r.segments[e.index]={strokeID:r.strokeID,segmentIndex:e.index,bounds:v.fromRect(e.bounds),spline:lt.fromJSON(e.spline),depth:e.depth},0==r.expected)t=r.segments,this.removeSpline(r.strokeID);else{let t=this.buildRequestMessage(e.action,e.actionID);t&&this.send(e.worker,t)}break;default:throw new Error(`Unknow data action found: ${e.action}`)}0==r.expected&&(delete this.state[e.actionID],this.resolve(e.actionID,t))}}class Qr{constructor(){this.tree=new yt,this.strokes={},this.brushAppliers={},this.nodes={},this.distanceInterpolator=new ut(1,!1,!0),this.curvatureInterpolator=new _t(!0,!0),this.convexHullChainProducer=new Bt,this.segmentsProducer=Jr.getInstance()}add(e){e.brush instanceof Ye||(this.strokes[e.id]=e,this.loadStrokeNode(e))}getStroke(e){return this.strokes[e]}getBrushApplier(e){let t=this.strokes[e].brush;return this.brushAppliers[t.name]||(this.brushAppliers[t.name]=new Ft(t)),this.brushAppliers[t.name]}getNodes(e){return this.nodes[e]}loadStrokeNode(e){let t=ft.buildStrokeNode(e);this.nodes[e.id]=[],this.nodes[e.id].push(t),this.load(this.nodes[e.id])}reload(e){this.unload(this.nodes[e.id]),this.loadStrokeNode(e)}remove(e){let t="string"==typeof e?e:e.id;this.unload(this.nodes[t]),delete this.nodes[t],delete this.strokes[t]}update(e,t){let r={intersected:[],selected:[],dirtyArea:void 0};return Object.keys(e).forEach((i=>{let s=this.strokes[i],n=this.split(s,e[i]);n&&(r.intersected.push({stroke:s,strokes:n}),t||(r.dirtyArea=s.bounds.union(r.dirtyArea)),e[i].intervals.forEach(((e,t)=>{e.inside&&r.selected.push(n[t])})))})),r}split(e,t){let{intervals:r,holes:i}=t;if(0==r.length)return[];let s=e.split(r);if(!s)return;s.forEach((e=>{this.strokes[e.id]=e}));let n=[],o=[];return r.map((t=>this.nodes[e.id].slice(t.fromNodeIndex,t.toNodeIndex+1))).forEach(((t,i)=>{let a,l,h=s[i],d=this.getBrushApplier(h.id),c=r[i].fromPointIndex,u=r[i].toPointIndex-3;if(h.ts!=t.first.spline.ts){let r=t.first.segmentIndex,i=this.nodes[e.id].filter((e=>e.segmentIndex==r));t=t.filter((e=>e.segmentIndex!=r)),r>=c&&(a=ft.buildStrokeSegment(h.id,h.spline,r-c,d),n.push(a)),o.push(...i)}if(t.length>0&&h.tf!=t.last.spline.tf){let r=t.last.segmentIndex,i=this.nodes[e.id].filter((e=>e.segmentIndex==r));t=t.filter((e=>e.segmentIndex!=r)),r<=u&&(l=ft.buildStrokeSegment(h.id,h.spline,r-c,d),n.push(l)),o.push(...i)}t.forEach((e=>{e.strokeID=h.id,e.segmentIndex-=c})),a&&t.unshift(a),l&&t.push(l),this.nodes[h.id]=t})),i.forEach((t=>o.push(...this.nodes[e.id].slice(t.fromNodeIndex,t.toNodeIndex+1)))),this.unload(o),this.load(n),delete this.nodes[e.id],delete this.strokes[e.id],s}replace(e,t){t.forEach((e=>this.add(e))),this.remove(e)}load(e){Array.isArray(e)||(e=[e]),0!=e.length&&(this.tree.load(e),this.tree.canvas&&this.tree.canvas.refresh())}updateTree(e,t){this.tree.remove(e),this.nodes[e.strokeID].replace(e,t)}unload(e){Array.isArray(e)||(e=[e]),e.forEach((e=>this.tree.remove(e))),this.tree.canvas&&this.tree.canvas.refresh()}search(e){return this.tree.search(e)}reset(){this.strokes={},this.brushAppliers={},this.nodes={},this.tree.clear(),this.tree.canvas&&this.tree.canvas.refresh()}static createInstance(e){let t=new Qr;if(e){t.strokes=Object.assign({},e.strokes),t.brushAppliers=e.brushAppliers;let r=[];for(let i in t.strokes)t.nodes[i]=e.nodes[i].map((e=>Object.assign({},e))),r=r.concat(t.nodes[i]);t.tree.load(r)}return t}}class ei extends ft{constructor(e){super(e)}intersect(e){if(!this.context)throw new Error("Required spatial context not found");return this.nodes=new Set,this.updateSegmentation(e),this.mode==ei.Mode.PARTIAL_STROKE?this.createIntervals(this.nodes,e):{intersected:{},selected:Array.from(Set.prototype.map.call(this.nodes,(e=>e.strokeID)))}}async intersectAsync(e){if(!this.context)throw new Error("Required spatial context not found");return this.nodes2=[],await this.updateSegmentationAsync(e),this.mode==ei.Mode.PARTIAL_STROKE?this.createIntervals(this.nodes2,e):{intersected:{},selected:this.nodes2.map((e=>e.strokeID))}}intersectSegmentation(e){if(!this.context)throw new Error("Required spatial context not found");return this.createIntervals(0==this.nodes2.length?this.nodes:this.nodes2,e)}}class ti extends ft{constructor(e){super(e)}select(e){if(!this.context)throw new Error("Required spatial context not found");let t=e.spline.getPoint(0).toArray(e.layout),r=e.spline.getPoint(e.spline.length-1).toArray(e.layout),i=[...r,...r,...t,...t],s=new hr(e.brush,new lt(e.layout,i,e.pointProps));this.updateSegmentation(s.path);let n={intersected:{},selected:[]},o=e.bounds,a=Yt.createClipperPath(e.spline),l=this.context.search(o),h=this.nodes.map((e=>e.strokeID)),d=Set.prototype.map.call(l,(e=>e.strokeID)).filter((e=>!h.has(e)));if(this.context.tree.canvas&&this.context.tree.canvas.addOperation("drawSelection",o,e.spline,e.path.first),this.mode==ti.Mode.PARTIAL_STROKE){let t=this.createIntervals(this.nodes,e.path);n=t;for(let e of h){let r=t.intersected[e]?t.intersected[e].intervals:[],i=0==r.length?null:this.context.getNodes(e);for(let e of r){let t=this.computeCenter(i,e.fromNodeIndex,e.toNodeIndex),r=Yt.containsPoint(a,t);this.context.tree.canvas&&this.context.tree.canvas.addOperation("fillPoint",t,5,r?ce.WHITE:ce.BLACK),e.inside=r}}}else n.selected=Array.from(h);for(let e of d){let t=this.context.getNodes(e),r=this.computeCenter(t,0,t.length-1);Yt.containsPoint(a,r)&&(n.selected.push(e),this.context.tree.canvas&&this.context.tree.canvas.addOperation("fillPoint",r,5,ce.GREEN))}return Object.defineProperty(n,"length",{get:()=>Object.keys(n.intersected).length+n.selected.length,enumerable:!0}),this.context.tree.canvas&&this.context.tree.canvas.refresh(),n}async selectAsync(e){if(!this.context)throw new Error("Required spatial context not found");let t=e.spline.getPoint(0).toArray(e.layout),r=e.spline.getPoint(e.spline.length-1).toArray(e.layout),i=[...r,...r,...t,...t],s=new hr(e.brush,new lt(e.layout,i,e.pointProps));await this.updateSegmentationAsync(s.path);let n={intersected:{},selected:[]},o=e.bounds,a=Yt.createClipperPath(e.spline),l=this.context.search(o),h=this.nodes2.map((e=>e.strokeID)),d=l.map((e=>e.strokeID)).filter((e=>!h.includes(e)));if(this.context.tree.canvas&&this.context.tree.canvas.addOperation("drawSelection",o,e.spline,e.path.first),this.mode==ti.Mode.PARTIAL_STROKE){let t=this.createIntervals(this.nodes2,e.path);n=t;for(let e of h){let r=t.intersected[e]?t.intersected[e].intervals:[],i=0==r.length?null:this.context.getNodes(e);for(let e of r){let t=this.computeCenter(i,e.fromNodeIndex,e.toNodeIndex),r=Yt.containsPoint(a,t);this.context.tree.canvas&&this.context.tree.canvas.addOperation("fillPoint",t,5,r?ce.WHITE:ce.BLACK),e.inside=r}}}else n.selected=Array.from(h);for(let e of d){let t=this.context.getNodes(e),r=this.computeCenter(t,0,t.length-1);Yt.containsPoint(a,r)&&(n.selected.push(e),this.context.tree.canvas&&this.context.tree.canvas.addOperation("fillPoint",r,5,ce.GREEN))}return Object.defineProperty(n,"length",{get:()=>Object.keys(n.intersected).length+n.selected.length,enumerable:!0}),this.context.tree.canvas&&this.context.tree.canvas.refresh(),n}computeCenter(e,t,r){let i=r+1-t,s=0,n=0;for(let i=t;i<=r;i++){let t=e[i].bounds.center;s+=t.x,n+=t.y}return{x:s/i,y:n/i}}}const{PathProducer:ri,Smoother:ii,SplineProducer:si,DistanceBasedInterpolator:ni,CurvatureBasedInterpolator:oi,BrushApplier:ai,ConvexHullChainProducer:li,ConvexHullChainProducerAsync:hi,PolygonMerger:di,PolygonSimplifier:ci}=Wt,ui=Ht;exports.ArrayPath=ge,exports.BlendMode=Ne,exports.Brush2D=Oe,exports.BrushApplier=ai,exports.BrushGL=Ye,exports.BrushPrototype=we,exports.Color=ce,exports.ColorsBox=rt,exports.ConvexHullChainProducer=li,exports.ConvexHullChainProducerAsync=hi,exports.CurvatureBasedInterpolator=oi,exports.DistanceBasedInterpolator=ni,exports.Environment=X,exports.FixedValuePrecisionCalculator=class extends wt{constructor(e=2,t=!1){super(),this.precision=e,this.autoAdjustOnIntegerOverflow=t}calculatePrecision(e,t){if(!this.autoAdjustOnIntegerOverflow)return this.precision;let r=this.precision,i=NaN;for(;isNaN(i);){if(i=At.calculateError(e,r),0==r){if(isNaN(i))throw new Error("Can't calculate appropriate precision value for the provided float sequence.");break}r--}return r}},exports.InkBuilder=rr,exports.InkBuilderAsync=sr,exports.InkCanvas2D=mr,exports.InkCanvasGL=Ir,exports.InkCodec=class{constructor(){this.dataCodec=new Mr,this.inputCodec=new Lr,this.brushesCodec=new _r,this.structureCodec=new Xr,this.tripleStoreCodec=new Fr,this.propsCodec=new zr,this.inkToolCodec=new Vr,this.compatibilityProvider=new Nr,this.riffEncoder=new It(Kr.fourCC.format,Kr.serial),this.riffDecoder=new xt,Object.defineProperty(this,"precisionCalculator",{get:()=>this.dataCodec.precisionCalculator,set:e=>this.dataCodec.precisionCalculator=e,enumerable:!0})}async encodeInkModel(e,t=Pt.CompressionType.NONE){return this.riffEncoder.add(this.propsCodec.encode(e.props),{version:Kr.serial,fourCC:Kr.fourCC.Properties,contentType:Pt.ContentType.PROTO,compressionType:t}),this.riffEncoder.add(this.inputCodec.encode(e.sensorData),{version:Kr.serial,fourCC:Kr.fourCC.InputData,contentType:Pt.ContentType.PROTO,compressionType:t}),this.riffEncoder.add(await this.brushesCodec.encode(e.brushes),{version:Kr.serial,fourCC:Kr.fourCC.Brushes,contentType:Pt.ContentType.PROTO,compressionType:t}),this.riffEncoder.add(this.dataCodec.encode(e.strokes,e.unitScaleFactor,e.transform),{version:Kr.serial,fourCC:Kr.fourCC.InkData,contentType:Pt.ContentType.PROTO,compressionType:t}),this.riffEncoder.add(this.tripleStoreCodec.encode(e.knowledgeGraph),{version:Kr.serial,fourCC:Kr.fourCC.TripleStore,contentType:Pt.ContentType.PROTO,compressionType:t}),this.riffEncoder.add(this.structureCodec.encode(e),{version:Kr.serial,fourCC:Kr.fourCC.InkStructure,contentType:Pt.ContentType.PROTO,compressionType:t}),await this.riffEncoder.encode()}async decodeInkModel(e,t){e instanceof ArrayBuffer&&(e=new Uint8Array(e));let r=await this.riffDecoder.decode(e),i=r.asProps();return this.buildInkModel(i,r.version,t)}buildInkModel(e,t,r){let i=this.compatibilityProvider.decodeInkObject(e,t),s=this.tripleStoreCodec.decode(i.KnowledgeGraph);if(r){let e=(r.type==Yr.Type.STROKE?i.InkData.strokes:i.InputData.sensorData).map((e=>r.getPath(e.id)));i.InkStructure.views.forEach((t=>this.decodeView(t,r,e,s)))}else{let e=this.inputCodec.decode(i.InputData),n=this.brushesCodec.decode(i.Brushes),o=this.dataCodec.decode(i.InkData,n,e);(r=this.structureCodec.decode(i.InkStructure,o?o.strokes:[],e)).version=t,o&&(r.unitScaleFactor=o.unitScaleFactor,r.transform=o.transform,r.brushes=Object.values(n)),s&&(r.knowledgeGraph=s),i.Properties&&(r.props=this.propsCodec.decode(i.Properties))}return r}encodeInputData(e){return this.inputCodec.encode(e)}decodeInputData(e){return this.inputCodec.decode(e)}encodeInkData(e){return this.dataCodec.ignoreSensorData=!0,this.dataCodec.encode(e)}decodeInkData(e){this.dataCodec.cloneStroke=!0;let t=this.dataCodec.decode(e);return t?t.strokes:[]}async encodeBrushes(e){return await this.brushesCodec.encode(e)}decodeBrushes(e){return Object.values(this.brushesCodec.decode(e))}encodeProperties(e){return this.propsCodec.encode(e)}decodeProperties(e){return this.propsCodec.decode(e)}encodeTripleStore(e){return this.tripleStoreCodec.encode(e)}decodeTripleStore(e){return this.tripleStoreCodec.decode(e)}static async buildJSON(e,t="InkModel"){e instanceof ArrayBuffer&&(e=new Uint8Array(e));let r={type:t},i={};if("InkModel"==t){let t=new xt,s=await t.decode(e),n=s.asProps(),o=Rr[s.version].format,a=new TextDecoder;r.version=s.version,r.format=a.decode(Kr.fourCC.format),n.data?i.InkObject=n.data:(n.inks&&(i.InkStructure=n.inks),n.inpt&&(i.InputData=n.inpt),n.inkd&&(i.InkData=n.inkd),n.brsh&&(i.Brushes=n.brsh),n.prps&&(i.Properties=n.prps),n.knwg&&(i.TripleStore=n.knwg));for(let e in i){let t=Cr.decode(i[e],o[e]);i[e]=t.toJSON()}}else{let s=Rr.latest,n=Cr.decode(e,s[t]);if(!n)throw new Error(`Build type missmatch - ${t}, expected oneof(InkModel, InputData, InkData, Brushes, Properties, TripleStore, InkTool, InkOperation)`);r.version=Rr.evolution.last,i=n.toJSON()}return{head:r,body:i}}decodeJSON(e){let t,{type:r,version:i}=e.head,s=e.body;if("InkModel"==r){let e={},r=new TextDecoder,n=Rr[i].format;for(let t in s){let i=Cr.decode(s[t],n[t]);e[r.decode(Kr.fourCC[t]).toLowerCase()]=Cr.encode(i)}t=this.buildInkModel(e,i)}else{let e=Rr.latest,i=Cr.decode(s,e[r]);switch(r){case"InputData":t=this.decodeInputData(i);break;case"InkData":t=this.decodeInkData(i);break;case"Brushes":t=this.decodeBrushes(i);break;case"Properties":t=this.decodeProperties(i);break;case"TripleStore":t=this.decodeTripleStore(i);break;case"InkTool":t=this.inkToolCodec.decode(i);break;case"InkOperation":if(!this.inkOperationCodec)throw new Error("InkCodec.inkOperationCodec property is not found");this.inkOperationCodec.decode(void 0,i);break;default:throw new Error(`input type missmatch - ${r}, expected oneof(InkModel, InputData, InkData, Brushes, Properties, TripleStore, InkTool, InkOperation)`)}}return t}},exports.InkController=y,exports.InkInputProvider=S,exports.InkModel=Yr,exports.InkObjectFormat=Kr,exports.InkOperation=class extends Cr{constructor(){super(),this.dataCodec=new Mr}composeStyle(e){let t=this.format.InkOperation.create({compose:this.format.InkOperation.Compose.create({style:this.encodeStyle(e)})});return Cr.encode(t)}composeSegment(e,t,r=0){if(!e||0==e.length)return;let i=this.format.InkOperation.create({compose:this.format.InkOperation.Compose.create({segment:this.format.Segment.create({pointerID:r,complete:t,ink:this.encodeInkPath(e)})})});return Cr.encode(i)}composeAbort(){let e=this.format.InkOperation.create({compose:this.format.InkOperation.Compose.create({abort:!0})});return Cr.encode(e)}add(e){let t=this.format.InkOperation.create({add:this.format.InkOperation.Add.create({path:this.dataCodec.encodeStroke(e),ink:this.encodeInkPath(e.path)})});return Cr.encode(t)}remove(e){let t=this.buildStrokesContext(e);if(!t)return;let r=this.format.InkOperation.create({remove:this.format.InkOperation.Remove.create({context:t})});return Cr.encode(r)}update(e,t,r=!1){let i=this.buildStrokesContext(e);if(!i)return;let s=this.format.InkOperation.create({update:this.format.InkOperation.Update.create({context:i,style:this.encodeStyle(t,!0),edit:r})});return Cr.encode(s)}split(e,t){let r=Object.keys(e);if(0==r.length)return;let i=this.format.InkOperation.create({split:this.format.InkOperation.Split.create({intersections:r.map((t=>this.encodeIntersection(t,e[t].intervals))),affectedArea:t})});return Cr.encode(i)}selectSelector(e){let t=this.format.InkOperation.create({select:this.format.InkOperation.Select.create({selector:this.dataCodec.encodeStroke(e)})});return Cr.encode(t)}selectSelection(e){let t=this.buildStrokesContext(e);if(!t)return this.selectAbort();let r=this.format.InkOperation.create({select:this.format.InkOperation.Select.create({selection:t})});return Cr.encode(r)}selectAbort(){let e=this.format.InkOperation.create({select:this.format.InkOperation.Select.create({abort:!0})});return Cr.encode(e)}updateSelectionTransform(e){let t=this.format.InkOperation.create({updateSelection:this.format.InkOperation.UpdateSelection.create({transform:this.dataCodec.encodeMatrix(e)})});return Cr.encode(t)}updateSelectionComplete(){let e=this.format.InkOperation.create({updateSelection:this.format.InkOperation.UpdateSelection.create({complete:!0})});return Cr.encode(e)}transform(e,t){let r=this.buildStrokesContext(e);if(!r)return;let i=this.format.InkOperation.create({transform:this.format.InkOperation.Transform.create({context:r,matrix:this.dataCodec.encodeMatrix(t)})});return Cr.encode(i)}buildStrokesContext(e){if(e&&(Array.isArray(e)||(e=[e]),0!=e.length))return this.format.StrokesContext.create({path:e.map((e=>"string"==typeof e?P.toBytes(e):P.toBytes(e.id)))})}decode(e,t){let r=Cr.decode(t,this.format.InkOperation);switch(r.operation){case"compose":switch(r.compose.stage){case"style":this.onComposeStyle(e,this.decodeStyle(r.compose.style,!1));break;case"segment":this.onComposeSegment(e,this.decodeInkPath(r.compose.segment.ink),r.compose.segment.complete,r.compose.segment.pointerID);break;case"abort":this.onComposeAbort(e);break;default:throw new Error(`Unknown compose stage found: ${r.compose.stage}`)}break;case"add":{let t;r.add.ink&&(t=this.decodeInkPath(r.add.ink));let i=this.dataCodec.decodeStroke(r.add.path,{inkPath:t});this.onAdd(e,i);break}case"remove":this.onRemove(e,r.remove.context.path.map((e=>P.fromBytes(e))));break;case"update":this.onUpdate(e,r.update.context.path.map((e=>P.fromBytes(e))),this.decodeStyle(r.update.style,!0),r.update.edit);break;case"split":{let t={intersected:{}},i=new v(r.split.affectedArea.x,r.split.affectedArea.y,r.split.affectedArea.width,r.split.affectedArea.height);r.split.intersections.forEach((e=>{let r=this.decodeIntersection(e);t.intersected[r.id]=r.intervals})),this.onSplit(e,t,i);break}case"select":switch(r.select.stage){case"selector":this.onSelectSelector(e,this.dataCodec.decodeStroke(r.select.selector));break;case"selection":this.onSelectSelection(e,r.select.selection.path.map((e=>P.fromBytes(e))));break;case"abort":this.onSelectAbort(e);break;default:throw new Error(`Unknown select stage found: ${r.select.stage}`)}break;case"updateSelection":switch(r.updateSelection.stage){case"transform":this.onUpdateSelectionTransform(e,this.dataCodec.decodeMatrix(r.updateSelection.transform));break;case"complete":this.onUpdateSelectionComplete(e);break;default:throw new Error(`Unknown selection update found: ${r.updateSelection.stage}`)}break;case"transform":this.onTransform(e,r.transform.context.path.map((e=>P.fromBytes(e))),this.dataCodec.decodeMatrix(r.transform.matrix));break;default:throw new Error(`Unknown ink operation found: ${r.operation}`)}}traceDecode(){this.debug||(this.debug=!0,this.onComposeStyle=console.log.bind(console,"onComposeStyle"),this.onComposeSegment=console.log.bind(console,"onComposeSegment"),this.onComposeAbort=console.log.bind(console,"onComposeAbort"),this.onAdd=console.log.bind(console,"onAdd"),this.onRemove=console.log.bind(console,"onRemove"),this.onUpdate=console.log.bind(console,"onUpdate"),this.onSplit=console.log.bind(console,"onSplit"),this.onSelectSelector=console.log.bind(console,"onSelectSelector"),this.onSelectSelection=console.log.bind(console,"onSelectSelection"),this.onSelectAbort=console.log.bind(console,"onSelectAbort"),this.onUpdateSelectionTransform=console.log.bind(console,"onUpdateSelectionTransform"),this.onUpdateSelectionComplete=console.log.bind(console,"onUpdateSelectionComplete"),this.onTransform=console.log.bind(console,"onTransform"))}onComposeStyle(e,t){throw new Error("InkOperation.onComposeStyle(user, style) should be implemented")}onComposeSegment(e,t,r,i){throw new Error("InkOperation.onComposeSegment(user, segment, endStroke, pointerID) should be implemented")}onComposeAbort(e){throw new Error("InkOperation.onComposeAbort(user) should be implemented")}onAdd(e,t){throw new Error("InkOperation.onAdd(user, stroke) should be implemented")}onRemove(e,t){throw new Error("InkOperation.onRemove(user, strokes) should be implemented")}onUpdate(e,t,r,i){throw new Error("InkOperation.onUpdate(user, strokes, style, edit) should be implemented")}onSplit(e,t,r){throw new Error("InkOperation.onSplit(user, intersections, affectedArea) should be implemented")}onSelectSelector(e,t){throw new Error("InkOperation.onSelectSelector(user, selector) should be implemented")}onSelectSelection(e,t){throw new Error("InkOperation.onSelectSelection(user, selection) should be implemented")}onSelectAbort(e){throw new Error("InkOperation.onSelectAbort(user) should be implemented")}onUpdateSelectionTransform(e,t){throw new Error("InkOperation.onUpdateSelectionTransform(user, transform) should be implemented")}onUpdateSelectionComplete(e){throw new Error("InkOperation.onUpdateSelectionComplete(user) should be implemented")}onTransform(e,t,r){throw new Error("InkOperation.onTransform(user, strokes, transform) should be implemented")}encodeStyle(e,t=!1){let r=this.format.Style.create();if(isFinite(e.pointerID)){if(t)throw new Error("Style property pointerID is not applicable for update");r.pointerID=e.pointerID}else if(!t)throw new Error("Style property pointerID is required");if(e.color)r.color=vr.rgba(e.color.red,e.color.green,e.color.blue,e.color.alpha);else if(!t)throw new Error("Style property color is required");if(e.brush){if(r.brushURI=e.brush.name,e.brush instanceof Ye)if(e.randomSeed){if(t)throw new Error("Style property randomSeed is not applicable for update, it is immutable");r.randomSeed=e.randomSeed}else if(!t)throw new Error("Style property randomSeed is required")}else if(!t)throw new Error("Style property brush is required");if(e.renderMode)e.renderMode!=hr.RenderMode.SOURCE_OVER&&(r.renderModeURI=e.renderMode);else if(e.blendMode)e.blendMode!=Ne.SOURCE_OVER&&(r.renderModeURI=hr.RenderMode.get(e.blendMode));else if(!t)throw new Error("Style property oneof(renderMode, blendMode) is required");return r}decodeStyle(e,t=!1){let r={};if(t||(r.pointerID=e.pointerID),e.color&&(r.color=ce.fromColor(vr.fromRGBA(e.color))),e.brushURI){let i=new ne(e.brushURI);if(r.brush=i.value,r.brush instanceof Ye)if(e.randomSeed)t?console.warn("Style property randomSeed is not applicable for update, it is immutable"):r.randomSeed=e.randomSeed;else if(!t)throw new Error("Style property randomSeed is required")}return r.renderMode=e.renderModeURI||hr.RenderMode.SOURCE_OVER,r}encodeInkPath(e,t){let r=this.format.InkPath.create();if(e instanceof et)r.polygons=this.format.PolygonArray.create({data:e.map((e=>this.format.Polygon.create({shape:this.format.Path.create({data:e.shape.points}),holes:e.holes.map((e=>this.format.Path.create({data:e.points})))})))});else if(e instanceof ht)r.path=this.format.Path.create({layout:L.encodeBitMask(e.layout.map((e=>e.value+1))),pointProps:vr.encodePathPointProperties(e.pointProps,this.format.PathPointProperties.create()),data:e.points});else{if(!(e instanceof lt))throw new Error("Expected path type - oneof(InkPath2D, InterpolatedSpline, Spline), not found");if(t)throw new Error("spline already provided through path property");t=e}return t&&(r.spline=this.format.Path.create({layout:L.encodeBitMask(t.layout.map((e=>e.value+1))),pointProps:vr.encodePathPointProperties(t.pointProps,this.format.PathPointProperties.create()),data:t.points})),r}decodeInkPath(e){let t;if("polygons"==e.data)t=new et(...e.polygons.data.map((e=>xe.createInstance(e.shape.data,e.holes.map((e=>e.data))))));else if("path"==e.data){let r=L.decodeBitMask(e.path.layout).map((e=>j.Property[e-1])),i=vr.decodePathPointProperties(e.path.pointProps,r);t=new ht(r,e.path.data,i)}if(e.spline){let r=L.decodeBitMask(e.spline.layout).map((e=>j.Property[e-1])),i=vr.decodePathPointProperties(e.spline.pointProps,r),s=new lt(r,e.spline.data,i);t?t.spline=s:t=s}return t}encodeIntersection(e,t){if(t.some((e=>!e.id)))throw new Error("Interval 'id' is required");return this.format.Intersection.create({path:P.toBytes(e),intervals:t.map((e=>this.format.Interval.create({id:P.toBytes(e.id),fromIndex:e.fromPointIndex,toIndex:e.toPointIndex,fromTValue:e.fromTValue,toTValue:e.toTValue})))})}decodeIntersection(e){return{id:P.fromBytes(e.path),intervals:e.intervals.map((e=>({id:P.fromBytes(e.id),fromPointIndex:e.fromIndex,toPointIndex:e.toIndex,fromTValue:e.fromTValue,toTValue:e.toTValue})))}}},exports.InkPath2D=et,exports.InkPathProducer=pr,exports.InkToolCodec=Vr,exports.InputContext=K,exports.InputDevice=te,exports.InputListener=U,exports.InterpolatedSpline=ht,exports.Intersector=ei,exports.Matrix=M,exports.OffscreenCanvasGL=br,exports.Path=fe,exports.PathPoint=j,exports.PathPointContext=Ce,exports.PathProducer=ri,exports.PathSegment=Jt,exports.Pipeline=Wt,exports.PipelineStage=ui,exports.Point=w,exports.PointerData=Kt,exports.Poly=Yt,exports.Polygon=xe,exports.PolygonArray=Qe,exports.PolygonMerger=di,exports.PolygonSimplifier=ci,exports.PrecisionCalculator=wt,exports.PrecisionSchema=Rt,exports.RIFFDecoder=xt,exports.RIFFEncoder=It,exports.RIFFFormat=Pt,exports.RMSEBasedPrecisionCalculator=class extends wt{constructor(e=.5){super(),this.qualityFactor=e}calculatePrecision(e,t){let r=new Float32Array(9),i=0,s=NaN,n=At.l2Norm(e);if(0==n)return 2;for(let t=0;t<9;t++){var o=At.calculateError(e,t)/n;if(isNaN(o))break;if(!isNaN(s)&&s<=o)break;if(i=t,r[t]=o,At.isZero(o))break;s=o}return Math.round(this.qualityFactor*i)}},exports.Rect=v,exports.RenderingContext2D=at,exports.Scalar=V,exports.SegmentsProducer=Jr,exports.Selector=ti,exports.SemanticTriple=Sr,exports.SensorChannel=Z,exports.SensorChannelsContext=q,exports.SensorContext=W,exports.SensorData=Q,exports.SensorStream=ee,exports.ShapeFactory=ae,exports.SharedPath=ye,exports.Smoother=ii,exports.SpatialContext=Qr,exports.Spline=lt,exports.SplineProducer=si,exports.Stroke=hr,exports.StrokeRenderer2D=class extends gr{constructor(e,t){super(e,t),this.alphaLayer=void 0}drawStroke(e){let t=e.blendMode;if(!(e.brush instanceof Oe))throw new Error("Incompatible brush found. It should be Brush2D instance.");if(!t)return void console.warn(`Cannot process ${e.renderMode} render mode. Requres custom processing.`);this.blendMode=e.style.blendMode||t;let r=this.layer.draw(e);this.strokeBounds=r,this.updatedArea=r}drawSegment(e,t=!1){if(!this.color)throw new Error("StrokeRenderer requires 'color' to be configured");if(this.validate(e)){let t=this.layer.drawStroke(this.brush,e,this.color.toRGB(),e.matrix);t&&(this.incompleteStrokeBounds=t.union(this.incompleteStrokeBounds),this.strokeBounds=t.union(this.strokeBounds),this.updatedArea=this.incompleteStrokeBounds.union(this.preliminaryDirtyArea))}else this.updatedArea=this.preliminaryDirtyArea;this.blendWithPreliminaryLayer=!1,this.preliminaryDirtyArea=null}drawPreliminary(e){this.validate(e)&&(this.preliminaryLayer||(this.preliminaryLayer=this.canvas.createLayer(),this.preliminaryLayer.setTransform(this.matrix)),this.updatedArea&&this.preliminaryLayer&&(this.preliminaryLayer.clear(this.updatedArea),this.preliminaryLayer.blend(this.layer,{mode:Ne.SOURCE_OVER,rect:this.updatedArea})),this.preliminaryDirtyArea=this.preliminaryLayer.drawStroke(this.brush,e,this.color.toRGB(),e.matrix),this.updatedArea=v.union(this.preliminaryDirtyArea,this.updatedArea),this.preliminaryLayer&&(this.blendWithPreliminaryLayer=!0))}reset(e){super.reset(e),this.runtime&&this.color.alpha<1&&(this.alphaLayer?this.alphaLayer.resize(this.layer.width,this.layer.height):this.alphaLayer=this.canvas.createLayer(this.layer.width,this.layer.height))}blendUpdatedArea(e){if(!this.updatedArea)return;let t=e||this.canvas,r=this.blendWithPreliminaryLayer?this.preliminaryLayer:this.layer,i=t.bounds.intersect(this.updatedArea);i&&(this.color.alpha<1?(this.alphaLayer.clear(),this.alphaLayer.ctx.globalAlpha=1,this.alphaLayer.blend(t,{rect:i}),this.alphaLayer.ctx.globalAlpha=this.color.alpha,this.alphaLayer.blend(r,{mode:this.blendMode,rect:i}),t.clear(i),t.blend(this.alphaLayer,{rect:i})):t.blend(r,{mode:this.blendMode,rect:i})),this.incompleteStrokeBounds=null,this.updatedArea=null}blendStroke(e,t,r){if(!this.strokeBounds)return;r||(r=this.blendMode);let i=this.layer,s=e||this.canvas;(t=s.bounds.intersect(t||this.strokeBounds))&&(this.runtime&&this.color.alpha<1?(this.alphaLayer.clear(),this.alphaLayer.ctx.globalAlpha=this.color.alpha,this.alphaLayer.blend(i,{rect:t}),s.blend(this.alphaLayer,{mode:r,rect:t})):s.blend(i,{mode:r,rect:t}))}blendStrokes(e,t,r={},i){if(0==e.length)return;let s,n,o,a=e.first.renderMode,l=[],h=()=>{let e=hr.RenderMode.getBlendMode(a);this.strokeBounds=n,n=null,this.blendStroke(t,r.rect,e),s=this.strokeBounds.union(s),this.reset()},d=()=>{if(!i)throw new Error("strokeRendererGL should be provided for WebGL strokes rasterization");i.reset(),o=i.blendStrokes(l,t,r),s=o.union(s),l.clear()};i&&(i.layer.resize(this.layer.width,this.layer.height),i.setTransform(this.matrix)),this.reset();for(let t of e)t.brush instanceof Oe?(l.length>0&&(d(),a=t.renderMode),a!=t.renderMode&&(h(),a=t.renderMode),n=t.bounds.union(n),this.drawStroke(t)):(n&&h(),l.push(t));return l.length>0?d():h(),this.restart=!0,s}toStroke(e,t){if(!this.brush)throw new Error("StrokeRenderer brush is not configured");t&&console.warn("StrokeRenderer2D.toStroke 'simplify' param is deprecated. Do not affects InkPath. InkBuilderSettings 'concatSegments' should be configured to affect ink path properly.");let r=e.getSensorData(),i=e.getSpline(),s=e.getInkPath(),n=new hr(this.brush,i,s,r);return r&&(n.sensorDataMapping=r.inkStream.getPipelineMapping()),this.blendMode!=Ne.SOURCE_OVER&&(n.renderMode=hr.RenderMode.get(this.blendMode)),n}delete(){console.warn("Not applicable with 2D API")}},exports.StrokeRendererGL=class extends gr{constructor(e,t){super(e,t),this.layerOptions=t,this.bitmapLayer=void 0,this.randomSeed=void 0,this.initialRandomSeed=void 0}configure(e){super.configure(e),this.brush instanceof Ye&&isFinite(e.randomSeed)&&(this.initialRandomSeed=e.randomSeed)}draw(e,t=!1){if(this.layer.isDeleted())throw new Error("StrokeRenderer cannot draw, it is already deleted");super.draw(e,t)}drawStroke(e){let t=e.blendMode;if(!t)return void console.warn(`Cannot process ${e.renderMode} render mode. Requres custom processing.`);this.blendMode=e.style.blendMode||t;let r=this.layer.draw(e);this.strokeBounds=r,this.updatedArea=r}drawSegment(e,t=!1){if(this.validate(e)){e.color&&this.color&&!e.color.equals(this.color)&&(e.color=this.color);let t=this.brush instanceof Ye?this.strokeLastRendererdDrawContext:this.color,r=this.layer.drawStroke(this.brush,e,t);r&&(this.incompleteStrokeBounds=r.union(this.incompleteStrokeBounds),this.strokeBounds=r.union(this.strokeBounds),this.updatedArea=this.incompleteStrokeBounds.union(this.preliminaryDirtyArea))}else this.updatedArea=this.preliminaryDirtyArea;this.blendWithPreliminaryLayer=!1,this.preliminaryDirtyArea=null}drawPreliminary(e){if(!this.validate(e))return;let t=null;this.brush instanceof Ye?(this.strokeLastRendererdDrawContext.copyTo(this.strokePrelimLastRenderedDrawContext),t=this.strokePrelimLastRenderedDrawContext):t=this.color,this.preliminaryLayer||(this.preliminaryLayer=this.canvas.createLayer(this.layerOptions),this.preliminaryLayer.setTransform(this.matrix)),this.updatedArea&&this.preliminaryLayer&&this.preliminaryLayer.blend(this.layer,{mode:Ne.COPY,rect:this.updatedArea}),e.color&&this.color&&!e.color.equals(this.color)&&(e.color=this.color),this.preliminaryDirtyArea=this.preliminaryLayer.drawStroke(this.brush,e,t),this.updatedArea=v.union(this.preliminaryDirtyArea,this.updatedArea),this.preliminaryLayer&&(this.blendWithPreliminaryLayer=!0)}reset(){super.reset(),this.bitmapLayer&&(this.bitmapLayer.clear(this.backgroundColor),this.bitmapLayer.resize(this.layer.width,this.layer.height)),this.brush instanceof Ye?(this.strokeLastRendererdDrawContext=new Er(this.initialRandomSeed),this.strokePrelimLastRenderedDrawContext||(this.strokePrelimLastRenderedDrawContext=new Er),delete this.initialRandomSeed,this.randomSeed=this.strokeLastRendererdDrawContext.randomSeed):delete this.randomSeed}blendUpdatedArea(e){if(!this.updatedArea)return;let t=this.blendWithPreliminaryLayer?this.preliminaryLayer:this.layer,r=e||this.canvas,i=r.bounds.intersect(this.updatedArea);if(i){if(r instanceof fr)throw new Error("Runtime blendig requires OffscreenLayerGL target");r.blend(t,{mode:this.blendMode,rect:i})}this.incompleteStrokeBounds=null,this.updatedArea=null}blendStroke(e,t,r){if(!this.strokeBounds)return;r||(r=this.blendMode);let i=this.layer,s=e||this.canvas;(t=s.bounds.intersect(t||this.strokeBounds))&&(s instanceof fr?this.blendStroke2D(s,{mode:r,rect:t}):s.blend(i,{mode:r,rect:t}))}blendStroke2D(e,t={}){let r=t.rect||t.sourceRect||this.layer.bounds,i=this.layer.getImageData(r,!0);if(!this.bitmapLayer){let e=new OffscreenCanvas(this.layer.width,this.layer.height);this.bitmapLayer=new fr(e.getContext("2d"))}this.bitmapLayer.putImageData(i,r.x,r.y),e.blend(this.bitmapLayer,t)}blendStrokes(e,t,r={}){if(0==e.length)return;let i,s,n=e.first.renderMode,o=()=>{let e=hr.RenderMode.getBlendMode(n);this.strokeBounds=s,s=null,this.blendStroke(t,r.rect,e),i=this.strokeBounds.union(i),this.reset()};this.reset();for(let t of e)(n!=t.renderMode||t.brush instanceof Oe&&t!=e.first)&&(o(),n=t.renderMode),s=t.bounds.union(s),this.drawStroke(t);return o(),this.restart=!0,i}toStroke(e){let t=e.getSensorData(),r=e.getSpline(),i=e.getInkPath(),s=new hr(this.brush,r,i,t);return t&&(s.sensorDataMapping=t.inkStream.getPipelineMapping()),s.randomSeed=this.randomSeed,this.blendMode!=Ne.SOURCE_OVER&&(s.renderMode=hr.RenderMode.get(this.blendMode)),s}delete(){this.layer.delete(),this.preliminaryLayer&&this.preliminaryLayer.delete()}},exports.TextTable=_,exports.TripleStore=xr,exports.TypedArrayCodec=se,exports.URIResolver=ie,exports.VarianceBasedPrecisionCalculator=class extends wt{constructor(e=.5){super(),this.qualityFactor=e}calculatePrecision(e,t){let r=new Float32Array(e.length);r[0]=0;for(let t=1;t<e.length;t++)r[t]=(e[t]-e[t-1])%1;let i=At.variance(r),s=i%1==0?0:-Math.floor(Math.log10(i));return s=Math.min(s,9),Math.round(this.qualityFactor*s)}},exports.fsx=Ae,exports.math=Ie,exports.utils=L,exports.uuid=P,exports.version="1.4.2";
