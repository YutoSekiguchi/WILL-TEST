import"js-ext";import{vec2 as t,vec3 as e,vec4 as i,mat4 as s,quat2 as r}from"gl-matrix";import*as n from"poly2tri";"function"==typeof Worker&&(Worker.prototype.on=function(t,e){this[`on${t}`]=i=>{let s="message"==t?i.data:i;e(s)}}),"function"==typeof DedicatedWorkerGlobalScope&&(DedicatedWorkerGlobalScope.prototype.on=function(t,e){this[`on${t}`]=i=>{let s="message"==t?i.data:i;e(s)}});class o{constructor(s,r,n,o){if(isNaN(s))throw new Error(`Invalid x found: ${s}`);if(isNaN(r))throw new Error(`Invalid y found: ${r}`);let a=[s,r];isFinite(n)&&(a.push(n),isFinite(o)&&a.push(o)),this.value=a.toFloat32Array(),Object.defineProperty(this,"x",{get:()=>this.value[0],set:t=>{this.value[0]=t},enumerable:!0}),Object.defineProperty(this,"y",{get:()=>this.value[1],set:t=>{this.value[1]=t},enumerable:!0}),2==a.length?this.vec=t:3==a.length?(this.vec=e,Object.defineProperty(this,"z",{get:()=>this.value[2],set:t=>{this.value[2]=t},enumerable:!0})):(this.vec=i,Object.defineProperty(this,"w",{get:()=>this.value[3],set:t=>{this.value[3]=t},enumerable:!0}))}add(t){t instanceof o||(t=o.fromPoint(t));let e=this.vec.create();return this.vec.add(e,this.value,t.value),o.fromPoint(e)}addSelf(t){return t instanceof o||(t=o.fromPoint(t)),this.vec.add(this.value,this.value,t.value),this}subtract(t){t instanceof o||(t=o.fromPoint(t));let e=this.vec.create();return this.vec.subtract(e,this.value,t.value),o.fromPoint(e)}subtractSelf(t){return t instanceof o||(t=o.fromPoint(t)),this.vec.subtract(this.value,this.value,t.value),this}multiply(t){t instanceof o||(t=o.fromPoint(t));let e=this.vec.create();return this.vec.multiply(e,this.value,t.value),o.fromPoint(e)}multiplySelf(t){return t instanceof o||(t=o.fromPoint(t)),this.vec.multiply(this.value,this.value,t.value),this}divide(t){t instanceof o||(t=o.fromPoint(t));let e=this.vec.create();return this.vec.divide(e,this.value,t.value),o.fromPoint(e)}divideSelf(t){return t instanceof o||(t=o.fromPoint(t)),this.vec.divide(this.value,this.value,t.value),this}scale(t){let e=this.vec.create();return this.vec.scale(e,this.value,t),o.fromPoint(e)}scaleSelf(t){return this.vec.scale(this.value,this.value,t),this}abs(){return new o(Math.abs(this.x),Math.abs(this.y),isFinite(this.z)?Math.abs(this.z):void 0,isFinite(this.w)?Math.abs(this.w):void 0)}absSelf(){return this.x=Math.abs(this.x),this.y=Math.abs(this.y),isFinite(this.z)&&(this.z=Math.abs(this.z)),isFinite(this.w)&&(this.w=Math.abs(this.w)),this}transform(t){if(!t)return this;let e=this.vec.create();return this.vec.transformMat4(e,this.value,t.toFloat32Array()),o.fromPoint(e)}transformSelf(t){return this.vec.transformMat4(this.value,this.value,t.toFloat32Array()),this}toFloat32Array(){return this.value}toJSON(){let t={x:this.x,y:this.y};return isFinite(this.z)&&(t.z=this.z,isFinite(this.w)&&(t.w=this.w)),t}toString(){return`point(${this.value.join(", ")})`}clone(){return o.fromPoint(this)}static fromPoint(t){return Array.isArray(t)||ArrayBuffer.isTypedArray(t)?new o(t[0],t[1],t[2],t[3]):new o(t.x,t.y,t.z,t.w)}}const a={m11:0,m12:1,m13:2,m14:3,m21:4,m22:5,m23:6,m24:7,m31:8,m32:9,m33:10,m34:11,m41:12,m42:13,m43:14,m44:15},l=a.m11,h=a.m12,u=a.m21,p=a.m22,c=a.m41,d=a.m42;class f{constructor(t=s.create(),e=f.MultiplicationType.PRE){Object.defineProperty(this,"value",{value:t,enumerable:!0}),Object.defineProperty(this,"multiplicationType",{value:e,enumerable:!0});let i=function(t,e){let i=a[t];this.value[i]=e};Object.defineProperty(this,"a",{get:()=>this.value[l],set:i.bind(this,"m11"),enumerable:!0}),Object.defineProperty(this,"b",{get:()=>this.value[h],set:i.bind(this,"m12"),enumerable:!0}),Object.defineProperty(this,"c",{get:()=>this.value[u],set:i.bind(this,"m21"),enumerable:!0}),Object.defineProperty(this,"d",{get:()=>this.value[p],set:i.bind(this,"m22"),enumerable:!0}),Object.defineProperty(this,"e",{get:()=>this.value[c],set:i.bind(this,"m41"),enumerable:!0}),Object.defineProperty(this,"f",{get:()=>this.value[d],set:i.bind(this,"m42"),enumerable:!0}),Object.defineProperty(this,"tx",{get:()=>this.value[c],set:i.bind(this,"m41"),enumerable:!0}),Object.defineProperty(this,"ty",{get:()=>this.value[d],set:i.bind(this,"m42"),enumerable:!0}),Object.defineProperty(this,"m11",{get:()=>this.value[0],set:i.bind(this,"m11"),enumerable:!0}),Object.defineProperty(this,"m12",{get:()=>this.value[1],set:i.bind(this,"m12"),enumerable:!0}),Object.defineProperty(this,"m13",{get:()=>this.value[2],set:i.bind(this,"m13"),enumerable:!0}),Object.defineProperty(this,"m14",{get:()=>this.value[3],set:i.bind(this,"m14"),enumerable:!0}),Object.defineProperty(this,"m21",{get:()=>this.value[4],set:i.bind(this,"m21"),enumerable:!0}),Object.defineProperty(this,"m22",{get:()=>this.value[5],set:i.bind(this,"m22"),enumerable:!0}),Object.defineProperty(this,"m23",{get:()=>this.value[6],set:i.bind(this,"m23"),enumerable:!0}),Object.defineProperty(this,"m24",{get:()=>this.value[7],set:i.bind(this,"m24"),enumerable:!0}),Object.defineProperty(this,"m31",{get:()=>this.value[8],set:i.bind(this,"m31"),enumerable:!0}),Object.defineProperty(this,"m32",{get:()=>this.value[9],set:i.bind(this,"m32"),enumerable:!0}),Object.defineProperty(this,"m33",{get:()=>this.value[10],set:i.bind(this,"m33"),enumerable:!0}),Object.defineProperty(this,"m34",{get:()=>this.value[11],set:i.bind(this,"m34"),enumerable:!0}),Object.defineProperty(this,"m41",{get:()=>this.value[12],set:i.bind(this,"m41"),enumerable:!0}),Object.defineProperty(this,"m42",{get:()=>this.value[13],set:i.bind(this,"m42"),enumerable:!0}),Object.defineProperty(this,"m43",{get:()=>this.value[14],set:i.bind(this,"m43"),enumerable:!0}),Object.defineProperty(this,"m44",{get:()=>this.value[15],set:i.bind(this,"m44"),enumerable:!0}),Object.defineProperty(this,"isIdentity",{get:()=>1==this.a&&0==this.b&&0==this.c&&1==this.d&&0==this.tx&&0==this.ty,enumerable:!0}),Object.defineProperty(this,"is2D",{get:()=>!(0!=this.m31||0!=this.m32||0!=this.m13||0!=this.m23||1!=this.m33||0!=this.m43||0!=this.m14||0!=this.m24||0!=this.m34||1!=this.m44),enumerable:!0}),Object.defineProperty(this,"translateX",{get:()=>this.tx}),Object.defineProperty(this,"translateY",{get:()=>this.ty}),Object.defineProperty(this,"skewX",{get:()=>Math.tan(this.c)}),Object.defineProperty(this,"skewY",{get:()=>Math.tan(this.b)}),Object.defineProperty(this,"scaleX",{get:()=>Math.sqrt(this.a*this.a+this.c*this.c)}),Object.defineProperty(this,"scaleY",{get:()=>Math.sqrt(this.d*this.d+this.b*this.b)}),Object.defineProperty(this,"rotation",{get:()=>Math.atan2(this.b,this.a)})}clone(){return new f(this.value.clone(),this.multiplicationType)}translate(t){return this.multiply(f.fromTranslate(t))}translateSelf(t){this.multiplySelf(f.fromTranslate(t))}rotate(t,e){return this.multiply(f.fromRotate(t,e))}rotateSelf(t,e){this.multiplySelf(f.fromRotate(t,e))}scale(t,e){return this.multiply(f.fromScale(t,e))}scaleSelf(t,e){this.multiplySelf(f.fromScale(t,e))}multiply(t){return this.multiplicationType==f.MultiplicationType.PRE?this.preMultiply(t):this.postMultiply(t)}preMultiply(t){let e=s.create();return s.multiply(e,t.toFloat32Array(),this.value),new f(e,this.multiplicationType)}postMultiply(t){let e=s.create();return s.multiply(e,this.value,t.toFloat32Array()),new f(e,this.multiplicationType)}multiplySelf(t){this.multiplicationType==f.MultiplicationType.PRE?this.preMultiplySelf(t):this.postMultiplySelf(t)}preMultiplySelf(t){s.multiply(this.value,t.toFloat32Array(),this.value)}postMultiplySelf(t){s.multiply(this.value,this.value,t.toFloat32Array())}invert(){let t=s.create();return s.invert(t,this.value),new f(t,this.multiplicationType)}invertSelf(){s.invert(this.value,this.value)}decompose(){return{translate:{x:this.tx,y:this.ty},rotate:{angle:Math.atan2(this.b,this.a)},skew:{angleX:Math.tan(this.c),angleY:Math.tan(this.b)},scale:{x:Math.sqrt(this.a*this.a+this.c*this.c),y:Math.sqrt(this.d*this.d+this.b*this.b)},matrix:this.toJSON()}}transformPoint(t){return o.fromPoint(t).transform(this)}toFloat32Array(){return this.value}toJSON(){return{a:this.a,b:this.b,c:this.c,d:this.d,tx:this.tx,ty:this.ty}}toString(t){if(t){let t=t=>((t<0?"":" ")+t.toPrecision(6)).substring(0,8);return" Matrix 4x4\n"+"-".repeat(39)+`\n${t(this.m11)}, ${t(this.m21)}, ${t(this.m31)}, ${t(this.m41)}`+`\n${t(this.m12)}, ${t(this.m22)}, ${t(this.m32)}, ${t(this.m42)}`+`\n${t(this.m13)}, ${t(this.m23)}, ${t(this.m33)}, ${t(this.m43)}`+`\n${t(this.m14)}, ${t(this.m24)}, ${t(this.m34)}, ${t(this.m44)}`}return this.is2D?`matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`:`matrix3d(${this.m11}, ${this.m12}, ${this.m13}, ${this.m14}, ${this.m21}, ${this.m22}, ${this.m23}, ${this.m24}, ${this.m31}, ${this.m32}, ${this.m33}, ${this.m34}, ${this.m41}, ${this.m42}, ${this.m43}, ${this.m44})`}static fromString(t,e){let i=s.create();if("none"!=t){let e=t.substring(0,t.indexOf("("));t=t.substring(t.indexOf("(")+1,t.indexOf(")")).split(/,\s*/g),"matrix3d"==e?(i[0]=parseFloat(t[0]),i[1]=parseFloat(t[1]),i[2]=parseFloat(t[2]),i[3]=parseFloat(t[3]),i[4]=parseFloat(t[4]),i[5]=parseFloat(t[5]),i[6]=parseFloat(t[6]),i[7]=parseFloat(t[7]),i[8]=parseFloat(t[8]),i[9]=parseFloat(t[9]),i[10]=parseFloat(t[10]),i[11]=parseFloat(t[11]),i[12]=parseFloat(t[12]),i[13]=parseFloat(t[13]),i[14]=parseFloat(t[14]),i[15]=parseFloat(t[15])):(i[l]=parseFloat(t[0]),i[h]=parseFloat(t[1]),i[u]=parseFloat(t[2]),i[p]=parseFloat(t[3]),i[c]=parseFloat(t[4]),i[d]=parseFloat(t[5]))}return new f(i,e)}static fromMatrix(t,e){if(!t)throw new Error("data not found, Matrix instance creation failed");if("function"==typeof t)throw new Error("data type function is not allowed");if(t instanceof f)return t;if(Array.isArray(t)&&(t=new Float32Array(t)),t instanceof Float32Array)return new f(t,e);if("string"==typeof t)return f.fromString(t,e);let i=s.create(),r=Object.assign({},t);return isFinite(t.a)&&(r.m11=t.a),isFinite(t.b)&&(r.m12=t.b),isFinite(t.c)&&(r.m21=t.c),isFinite(t.d)&&(r.m22=t.d),isFinite(t.tx)?r.m41=t.tx:isFinite(t.e)?r.m41=t.e:isFinite(t.dx)&&(r.m41=t.dx),isFinite(t.ty)?r.m42=t.ty:isFinite(t.f)?r.m42=t.f:isFinite(t.dy)&&(r.m42=t.dy),isFinite(r.m11)&&(i[0]=r.m11),isFinite(r.m12)&&(i[1]=r.m12),isFinite(r.m13)&&(i[2]=r.m13),isFinite(r.m14)&&(i[3]=r.m14),isFinite(r.m21)&&(i[4]=r.m21),isFinite(r.m22)&&(i[5]=r.m22),isFinite(r.m23)&&(i[6]=r.m23),isFinite(r.m24)&&(i[7]=r.m24),isFinite(r.m31)&&(i[8]=r.m31),isFinite(r.m32)&&(i[9]=r.m32),isFinite(r.m33)&&(i[10]=r.m33),isFinite(r.m34)&&(i[11]=r.m34),isFinite(r.m41)&&(i[12]=r.m41),isFinite(r.m42)&&(i[13]=r.m42),isFinite(r.m43)&&(i[14]=r.m43),isFinite(r.m44)&&(i[15]=r.m44),new f(i,e||t.multiplicationType)}static fromTranslate(t){let e=isFinite(t)?{tx:t,ty:t}:{tx:t.x,ty:t.y};return f.fromMatrix(e)}static fromRotate(t,e){let i=Math.sin(t),s=Math.cos(t),r={a:s,b:i,c:-i,d:s};return e&&(r.tx=e.x-e.x*s+e.y*i,r.ty=e.y-e.x*i-e.y*s),f.fromMatrix(r)}static fromScale(t,e){isFinite(t)&&(t={x:t,y:t});let i={a:t.x,d:t.y};return e&&(i.tx=e.x-e.x*t.x,i.ty=e.y-e.y*t.y),f.fromMatrix(i)}static fromPoints(t,e){if(!Array.isArray(t)||!Array.isArray(e))throw new Error("Expected input type Array requirement not satisfied");if(3!=t.length||3!=e.length)throw new Error("Expected input size 3 requirement not satisfied");let i=f.fromMatrix({m11:t[0].x,m21:t[1].x,m31:t[2].x,m12:t[0].y,m22:t[1].y,m32:t[2].y,m13:1,m23:1,m33:1}),s=f.fromMatrix({m11:e[0].x,m21:e[1].x,m31:e[2].x,m12:e[0].y,m22:e[1].y,m32:e[2].y,m13:1,m23:1,m33:1}),r=i.invert().preMultiply(s);return f.fromMatrix({a:r.m11,b:r.m12,c:r.m21,d:r.m22,tx:r.m31,ty:r.m32})}static multiply(t,e){let i=s.create();return s.multiply(i,t.value,e.value),new f(i)}}f.MultiplicationType=Object.freeze({PRE:"PRE",POST:"POST"});class m extends o{static defaults={size:1,rotation:0,scaleX:1,scaleY:1,scaleZ:1,offsetX:0,offsetY:0,offsetZ:0};constructor(t,e,i,s={}){super(t,e,i),this.red=s.red,this.green=s.green,this.blue=s.blue,this.alpha=s.alpha,this.size=s.size||m.defaults.size,this.rotation=s.rotation||m.defaults.rotation,this.scaleX=s.scaleX||m.defaults.scaleX,this.scaleY=s.scaleY||m.defaults.scaleY,this.scaleZ=isFinite(i)?s.scaleZ||m.defaults.scaleZ:void 0,this.offsetX=s.offsetX||m.defaults.offsetX,this.offsetY=s.offsetY||m.defaults.offsetY,this.offsetZ=isFinite(i)?s.offsetZ||m.defaults.offsetZ:void 0,this.dX,this.dY}static createInstance(t,e,i,s=0){let r=new m(0,0,t.includes(m.Property.Z)?0:void 0);return i&&r.fill(s,i,t,e),r}fill(t,e,i,s={}){let r={},n=t*i.length;i.forEach(((t,i)=>m.setProperty(r,t,e[n+i]))),this.x=r.x,this.y=r.y,this.z=r.z,this.red=isFinite(r.red)?r.red:s.red,this.green=isFinite(r.green)?r.green:s.green,this.blue=isFinite(r.blue)?r.blue:s.blue,this.alpha=isFinite(r.alpha)?r.alpha:s.alpha,this.size=r.size||s.size||m.defaults.size,this.rotation=r.rotation||s.rotation||m.defaults.rotation,this.scaleX=r.scaleX||s.scaleX||m.defaults.scaleX,this.scaleY=r.scaleY||s.scaleY||m.defaults.scaleY,this.scaleZ=isFinite(r.z)?r.scaleZ||s.scaleZ||m.defaults.scaleZ:void 0,this.offsetX=r.offsetX||s.offsetX||m.defaults.offsetX,this.offsetY=r.offsetY||s.offsetY||m.defaults.offsetY,this.offsetZ=isFinite(r.z)?r.offsetZ||s.offsetZ||m.defaults.offsetZ:void 0,this.dX=r.dX,this.dY=r.dY}getProperty(t){switch(t){case m.Property.X:return this.x;case m.Property.Y:return this.y;case m.Property.Z:return this.z;case m.Property.RED:return this.red;case m.Property.GREEN:return this.green;case m.Property.BLUE:return this.blue;case m.Property.ALPHA:return this.alpha;case m.Property.SIZE:return this.size;case m.Property.ROTATION:return this.rotation;case m.Property.SCALE_X:return this.scaleX;case m.Property.SCALE_Y:return this.scaleY;case m.Property.SCALE_Z:return this.scaleZ;case m.Property.OFFSET_X:return this.offsetX;case m.Property.OFFSET_Y:return this.offsetY;case m.Property.OFFSET_Z:return this.offsetZ;case m.Property.D_X:return this.dX;case m.Property.D_Y:return this.dY;default:throw console.warn(t),new Error("Invalid property found")}}setProperty(t,e){m.setProperty(this,t,e)}static setProperty(t,e,i){switch(e){case m.Property.X:t.x=i;break;case m.Property.Y:t.y=i;break;case m.Property.Z:t.z=i;break;case m.Property.RED:t.red=i;break;case m.Property.GREEN:t.green=i;break;case m.Property.BLUE:t.blue=i;break;case m.Property.ALPHA:t.alpha=i;break;case m.Property.SIZE:t.size=i;break;case m.Property.ROTATION:t.rotation=i;break;case m.Property.SCALE_X:t.scaleX=i;break;case m.Property.SCALE_Y:t.scaleY=i;break;case m.Property.SCALE_Z:t.scaleZ=i;break;case m.Property.OFFSET_X:t.offsetX=i;break;case m.Property.OFFSET_Y:t.offsetY=i;break;case m.Property.OFFSET_Z:t.offsetZ=i;break;case m.Property.D_X:t.dX=i;break;case m.Property.D_Y:t.dY=i;break;default:throw console.warn(e),new Error("Invalid property found")}}transform(t){if(!(t instanceof f))throw new Error(`matrix is instance of ${t.constructor.name} - it should be instance of Matrix. Use Matrix.fromMatrix method to convert.`);let e=t.scaleX,i=t.rotation;this.transformSelf(t),this.size*=e,this.rotation+=i,this.scaleX*=e,this.scaleY*=e,isFinite(this.z)&&(this.scaleZ*=e),this.offsetX*=e,this.offsetY*=e,isFinite(this.z)&&(this.offsetZ*=e)}toArray(t){return t.map((t=>{let e=this.getProperty(t);if(null==e||isNaN(e))throw new Error(`Property ${t.name} has invalid value ${e}`);return e}))}toJSON(){let t={};return m.Property.values.forEach((e=>{let i=this.getProperty(e);null!=i&&isFinite(i)&&(t[e.name]=this.getProperty(e))})),t}}Object.defineEnum(m,"Property",["X","Y","Z","RED","GREEN","BLUE","ALPHA","SIZE","ROTATION","SCALE_X","SCALE_Y","SCALE_Z","OFFSET_X","OFFSET_Y","OFFSET_Z","D_X","D_Y"]);class y{constructor(t,e,i,s=1){if(this.red=t,this.green=e,this.blue=i,this.alpha=s,s<0||s>1)throw new Error(`Invalid alpha ${s} found. The value must be in the interval [0, 1].`);Object.defineProperty(this,"hex",{get:()=>`#${this.red.toString(16).pad(2,"0")}${this.green.toString(16).pad(2,"0")}${this.blue.toString(16).pad(2,"0")}${Math.round(255*this.alpha).toString(16).pad(2,"0")}`,enumerable:!0})}premultiply(){return{red:this.red/255*this.alpha,green:this.green/255*this.alpha,blue:this.blue/255*this.alpha,alpha:this.alpha}}static postdivide(t,e,i,s){let r=parseInt(255*t/s),n=parseInt(255*e/s),o=parseInt(255*i/s);return new y(r,n,o,s)}equals(t){return t&&this.red==t.red&&this.green==t.green&&this.blue==t.blue&&this.alpha==t.alpha}toRGB(){return 1==this.alpha?this:new y(this.red,this.green,this.blue)}toRGBA(t){return new y(this.red,this.green,this.blue,t)}toHSLA(){let t=this.red/255,e=this.green/255,i=this.blue/255,s=Math.min(t,e,i),r=Math.max(t,e,i),n=0,o=0,a=(r+s)/2;if(r!=s){let l=r-s;switch(o=l/(1-Math.abs(2*a-1)),r){case t:n=(e-i)/l%6;break;case e:n=(i-t)/l+2;break;case i:n=(t-e)/l+4}}return n*=60,n<0&&(n+=360),{hue:parseFloat(n.toFixed(0)),saturation:parseFloat((100*o).toFixed(2)),lightness:parseFloat((100*a).toFixed(2)),alpha:this.alpha}}toArray(){return[this.red,this.green,this.blue,this.alpha]}toJSON(){return{red:this.red,green:this.green,blue:this.blue,alpha:this.alpha}}toString(){return 1==this.alpha?`rgb(${this.red}, ${this.green}, ${this.blue})`:`rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`}static isColor(t){return t&&isFinite(t.red)&&isFinite(t.green)&&isFinite(t.blue)}static fromColor(t){let e,i,s,r;if("string"==typeof t)if(t.startsWith("rgb"))t=t.substring(t.indexOf("(")+1,t.indexOf(")")).split(/,\s*/g),e=parseInt(t[0]),i=parseInt(t[1]),s=parseInt(t[2]),r=t[3]?parseInt(t[3]):1;else{if(!t.startsWith("#"))throw new Error(`Unknown input found: ${t}. Expected data starts with rgba, rgb or #.`);t=t.substring(1),e=parseInt(t.substring(0,2),16),i=parseInt(t.substring(2,4),16),s=parseInt(t.substring(4,6),16),r=8==t.length?parseInt(t.substring(6,8),16)/255:1}else Array.isArray(t)?(e=t[0],i=t[1],s=t[2],r=t[3]):(e=t.red,i=t.green,s=t.blue,r=t.alpha);return new y(e,i,s,r)}static fromHSLA(t=0,e=0,i=0,s){t/=60,e/=100,i/=100;let r=(1-Math.abs(2*i-1))*e,n=r*(1-Math.abs(t%2-1)),o=0,a=0,l=0;t>=0&&t<1?(o=r,a=n):t>=1&&t<2?(o=n,a=r):t>=2&&t<3?(a=r,l=n):t>=3&&t<4?(a=n,l=r):t>=4&&t<5?(o=n,l=r):(o=r,l=n);let h=i-r/2;return o+=h,a+=h,l+=h,new y(Math.round(255*o),Math.round(255*a),Math.round(255*l),s)}static random(t){return new y(Math.randomInt(0,255),Math.randomInt(0,255),Math.randomInt(0,255),t?Math.random():1)}}y.TRANSPERENT=new y(0,0,0,0),y.BLACK=new y(0,0,0,1),y.WHITE=new y(255,255,255,1),y.RED=new y(255,0,0,1),y.GREEN=new y(0,255,0,1),y.BLUE=new y(0,0,255,1);let g={longToByteArray(t){let e=[0,0,0,0,0,0,0,0];for(let i=0;i<e.length;i++){let s=255&t;e[i]=s,t=(t-s)/256}return e},byteArrayToLong(t){let e=0;for(let i=t.length-1;i>=0;i--)e=256*e+t[i];return e},crc32:function(){let t=new Uint32Array(256);for(let e=256;e--;){let i=e;for(let t=8;t--;)i=1&i?3988292384^i>>>1:i>>>1;t[e]=i}return function(e){let i=-1;for(let s=0,r=e.length;s<r;s++)i=i>>>8^t[255&i^e[s]];return(-1^i)>>>0}}(),encodeBitMask(t=[]){if(0==t.length)return 0;let e="",i=Math.max(...t);for(let s=1;s<=i;s++)e+=t.includes(s)?"1":"0";return parseInt(e.split("").reverse().join(""),2)},decodeBitMask(t){let e=[],i=t.toString(2).split("").reverse();for(let t=0;t<i.length;t++)1==i[t]&&e.push(t+1);return e},mapTo:(t,e,i)=>i.min+(g.clamp(t,e)-e.min)/(e.max-e.min)*(i.max-i.min),clamp:(t,e)=>Math.min(Math.max(t,e.min),e.max),debounce(t,e){let i=null;return function(){let s=this,r=arguments;clearTimeout(i),i=setTimeout((function(){t.apply(s,r)}),e)}},comparator(){let t=Array.prototype.slice.call(arguments),e=function(t,e,i){return e.replace("[",".").replace("]","").split(".").forEach((e=>t=t[e])),i?t.toLowerCase():t};return function(i,s){return t.map((t=>function(t,e,i){let s="asc"===i?1:-1;return t>e?1*s:t<e?-1*s:0}(e(i,t.sortBy,t.ignoreCase),e(s,t.sortBy,t.ignoreCase),t.sortOrder))).reduceRight((function(t,e){return e||t}))}},isValidURL(t){if("string"!=typeof t)return!1;try{return new URL(t),!0}catch(t){return!1}},getPropName(t,e){let i=t.split("_"),s=i.first.toLowerCase();e&&(s=s.substring(0,1).toUpperCase()+s.substring(1));for(let t=1;t<i.length;t++)s+=i[t].substring(0,1),s+=i[t].substring(1).toLowerCase();return s},getEnumValueName(t){let e="";for(let i=0;i<t.length;i++)i>0&&t[i]!=t[i].toLowerCase()&&(e+="_"),e+=t[i];return e.toUpperCase()}};class b{constructor(t,e,i={}){this.layout=t,this.pointProps=e,this.sheet={};let s={};Object.defineProperties(s,{size:{get:this.getComputed.bind(this,"size"),set:this.setStyle.bind(this,"size"),enumerable:!0},red:{get:this.getComputed.bind(this,"red"),set:this.setStyle.bind(this,"red"),enumerable:!0},green:{get:this.getComputed.bind(this,"green"),set:this.setStyle.bind(this,"green"),enumerable:!0},blue:{get:this.getComputed.bind(this,"blue"),set:this.setStyle.bind(this,"blue"),enumerable:!0},alpha:{get:this.getComputed.bind(this,"alpha"),set:this.setStyle.bind(this,"alpha"),enumerable:!0},rotation:{get:this.getComputed.bind(this,"rotation"),set:this.setStyle.bind(this,"rotation"),enumerable:!0},scaleX:{get:this.getComputed.bind(this,"scaleX"),set:this.setStyle.bind(this,"scaleX"),enumerable:!0},scaleY:{get:this.getComputed.bind(this,"scaleY"),set:this.setStyle.bind(this,"scaleY"),enumerable:!0},scaleZ:{get:this.getComputed.bind(this,"scaleZ"),set:this.setStyle.bind(this,"scaleZ"),enumerable:!0},offsetX:{get:this.getComputed.bind(this,"offsetX"),set:this.setStyle.bind(this,"offsetX"),enumerable:!0},offsetY:{get:this.getComputed.bind(this,"offsetY"),set:this.setStyle.bind(this,"offsetY"),enumerable:!0},offsetZ:{get:this.getComputed.bind(this,"offsetZ"),set:this.setStyle.bind(this,"offsetZ"),enumerable:!0},color:{get:this.getComputed.bind(this,"color"),set:this.setStyle.bind(this,"color"),enumerable:!0},blendMode:{get:this.getComputed.bind(this,"blendMode"),set:this.setStyle.bind(this,"blendMode"),enumerable:!0},visibility:{get:this.getComputed.bind(this,"visibility"),set:this.setStyle.bind(this,"visibility"),enumerable:!0},reset:{value:t=>{t&&(i=t),this.clear(),Object.keys(i).forEach((t=>this.setStyle(t,i[t])))}},clear:{value:this.clear.bind(this)}}),this.style=Object.freeze(s),this.style.reset(i)}setStyle(t,e){if(null==e&&(e=void 0),b.validate(this.layout,t,e),"color"==t&&e)return this.sheet.red=e.red,this.sheet.green=e.green,this.sheet.blue=e.blue,void(this.sheet.alpha=e.alpha);null==e?delete this.sheet[t]:this.sheet[t]=e}getStyle(t){let e=this.sheet[t];return"visibility"==t?"boolean"!=typeof e&&(e=!0):"color"==t&&y.isColor(this.sheet)&&(e=y.fromColor(this.sheet)),e}getComputed(t){let e=this.getStyle(t);if(null==e)if("color"==t){let t={red:isFinite(this.sheet.red)?this.sheet.red:this.pointProps.red,green:isFinite(this.sheet.green)?this.sheet.green:this.pointProps.green,blue:isFinite(this.sheet.blue)?this.sheet.blue:this.pointProps.blue,alpha:isFinite(this.sheet.alpha)?this.sheet.alpha:this.pointProps.alpha};y.isColor(t)&&(e=y.fromColor(t))}else e=this.pointProps[t];return e}clear(){this.sheet={}}static validate(t,e,i,s){let r;if(i&&t.includes(m.Property[g.getEnumValueName(e)])){if(!s)throw new Error(`Property ${e} value ${i} is not applicable. This is a dynamic property and is part of the layout.`);console.warn(`Property ${e} value ${i} is not applicable. This is a dynamic property and is part of the layout.`),i=void 0}if("color"==e)!i||i instanceof y||(r=`Property ${e} is not an instance of Color`);else if("blendMode"==e)""==i&&(i=void 0);else if("number"==typeof i)if("size"==e)i<0?r=`Property ${e} with value ${i} is not allowed. Value should be a positive number.`:0==i&&(i=void 0);else if("red"==e||"green"==e||"blue"==e||"alpha"==e){let t="alpha"==e?{min:0,max:1}:{min:0,max:255};i>=t.min&&i<=t.max||(r=`Property ${e} with value ${i} is out of range. Allowd range: [${t.min}, ${t.max}].`)}else"rotation"==e?0==i&&(i=void 0):"scattering"==e&&i<0&&(i=void 0);if(r)throw new Error(r);return i}}const P=[m.Property.X,m.Property.Y];class x{constructor(t,e={},i=P){if(x.name==this.constructor.name)throw new Error("Path class is abstract. Constructor is not accessible.");if(t%i.length!=0)throw new Error("Points length do not matches with given layout");if(Object.defineProperties(this,{layout:{value:Object.freeze(i)},stride:{value:i.length},length:{value:t/i.length}}),!Object.isSealed(e))for(let t in e)void 0!==e[t]&&(e[t]=b.validate(this.layout,t,e[t],!0));i.includes(m.Property.ROTATION)||"rotation"in e||(e.rotation=void 0),i.includes(m.Property.SIZE)||e.size||(e.size=1),Object.defineProperty(this,"pointProps",{value:Object.seal(e)}),i.forEach(((t,e)=>{let i=g.getPropName(t.name,!0);Object.defineProperty(this,`setPoint${i}`,{value:this.setPointPropertyValue.bind(this,e)}),Object.defineProperty(this,`getPoint${i}`,{value:this.getPointPropertyValue.bind(this,e)})}))}setPointPropertyValue(t,e,i){if(isNaN(e))throw new Error("Point index is required");if(e>=this.length||e<0)throw new Error(`Index ${t} out of range - (0, ${this.length-1})`);if(isNaN(i))throw new Error("value is required");this.points[e*this.layout.length+t]=i}getPointPropertyValue(t,e){if(isNaN(e))throw new Error("Point index is required");if(e>=this.length||e<0)throw new Error(`Index ${t} out of range - (0, ${this.length-1})`);return this.points[e*this.layout.length+t]}setPoint(t,e){let i=t*this.stride;this.layout.forEach(((t,s)=>this.points[i+s]=e.getProperty(t)))}getPoint(t,e=this.pointProps){if(t>=this.length||t<0)throw new Error(`Index ${t} out of range - (0, ${this.length-1})`);return m.createInstance(this.layout,e,this.points,t)}getChannelData(t){let e=new([m.Property.RED,m.Property.GREEN,m.Property.BLUE].includes(t)?Uint8Array:Float32Array)(this.length),i=this.layout.indexOf(t);if(-1==i)throw new Error(`Property ${t.name} is not part from the spline layout ${this.layout.map((t=>t.name)).join(", ")}`);for(let t=0;t<this.length;t++)e[t]=this.points[t*this.stride+i];return e}transform(t){let e=t.scaleX,s=t.rotation;for(let r=0;r<this.length;r++){let n=r*this.stride,o=i.fromValues(this.getPointX(r),this.getPointY(r),0,1);i.transformMat4(o,o,t.value);for(let t=0;t<this.stride;t++){let i=n+t;switch(this.layout[t]){case m.Property.X:this.points[i]=o[0]/o[3];break;case m.Property.Y:this.points[i]=o[1]/o[3];break;case m.Property.Z:this.points[i]=o[2]/o[3];break;case m.Property.ROTATION:this.points[i]+=s;break;case m.Property.SIZE:case m.Property.SCALE_X:case m.Property.SCALE_Y:case m.Property.SCALE_Z:case m.Property.OFFSET_X:case m.Property.OFFSET_Y:case m.Property.OFFSET_Z:this.points[i]*=e}}}this.layout.includes(m.Property.ROTATION)||(this.pointProps.rotation=0==s?void 0:s)}clone(){throw new Error("Path.clone()) is abstract and should be implemented")}slice(t){throw new Error("Path.slice(fragment)) is abstract and should be implemented")}slicePoints(t,e,i=0,s=1){throw new Error("Path.slicePoints(fromPointIndex, toPointIndex, fromTValue, toTValue)) is abstract and should be implemented")}toSVGPath(){let t=[];for(let e=0;e<this.length;e++)t.push(`${this.getPointX(e)},${this.getPointY(e)}`);return`M ${t.join(" L ")} Z`}toJSON(){throw new Error("Path.toJSON() is abstract and should be implemented")}static fromJSON(t){throw new Error("static Path.fromJSON(data) is abstract and should be implemented")}static fromRect(t,e){return new this([t.left,t.top,t.right,t.top,t.right,t.bottom,t.left,t.bottom,t.left,t.top],e)}}class S{constructor(t,e,i,s=0,r=1){Object.defineProperties(this,{path:{value:t,enumerable:!0},fromPointIndex:{value:e,enumerable:!0},toPointIndex:{value:i,enumerable:!0},fromTValue:{value:s,enumerable:!0},toTValue:{value:r,enumerable:!0}}),this.validate()}validate(){S.validate(this.path,this.fromPointIndex,this.toPointIndex,this.fromTValue,this.toTValue)}overlaps(t){if(t.path!=this.path)return!1;let e=t.fromPointIndex<this.toPointIndex-3||t.fromPointIndex==this.toPointIndex-3&&t.fromTValue<=this.toTValue,i=t.toPointIndex-3>this.fromPointIndex||t.toPointIndex-3==this.fromPointIndex&&t.toTValue>=this.fromTValue;return e&&i}toPath(){return this.path.slice(this)}toString(){return`fragment${this.path.id?`{${this.path.id}}`:""}(${this.fromPointIndex}, ${this.toPointIndex}, ${this.fromTValue}, ${this.toTValue})`}static validate(t,e,i,s=0,r=1){if(e<0)throw new Error(`Invalid fragment fromPointIndex ${e} found. The value must be non-negative.`);if(i>t.length-1)throw new Error(`Invalid fragment toPointIndex ${i} found. Last point in path index is ${t.length-1}.`);if(isFinite(t.ts)&&isFinite(t.tf)){if(s<0||s>=1)throw new Error(`Invalid fragment fromTValue ${s} found. The value must be in the interval [0, 1).`);if(r<=0||r>1)throw new Error(`Invalid fragment toTValue ${r} found. The value must be in the interval (0, 1].`);if(i+1-e<4)throw new Error(`Invalid fragment points range {${e}, ${i}} found. At least 4 points are needed to define spline.`);if(e==i-3&&r<=s)throw new Error(`Invalid fragment T values range {${s}, ${r}} found. The value must be in the interval (fromTValue, 1].`)}}}m.Property.X,m.Property.Y;class E extends x{constructor(t,e,i){super(t.length,e,i),Array.isArray(t)&&(t=Object.seal(t)),Object.defineProperty(this,"points",{get:()=>t,enumerable:!0})}clone(){return new E(this.points.clone(),Object.clone(this.pointProps),this.layout.slice())}slice(t){let e=this.slicePoints(t.fromPointIndex,t.toPointIndex);return new E(e,Object.clone(this.pointProps),this.layout.slice())}slicePoints(t,e,i=0,s=1){return S.validate(this,t,e,i,s),this.points.slice(t*this.stride,(e+1)*this.stride)}toJSON(){return{type:"ArrayPath",points:this.points,pointProps:this.pointProps,layout:this.layout.map((t=>t.name))}}static fromJSON(t){if("ArrayPath"!=t.type)throw new Error(`ArrayPath deserialization failed. JSON type is ${t.type}, expected ArrayPath.`);return new E(t.points,t.pointProps,t.layout.map((t=>m.Property[t])))}}class w{static encode(t,e=w.Encoding.AUTO){let i;if(e==w.Encoding.AUTO&&(e="undefined"==typeof Buffer?"undefined"!=typeof SharedArrayBuffer&&t.buffer instanceof SharedArrayBuffer?w.Encoding.NONE:w.Encoding.ARRAY:w.Encoding.BUFFER),e==w.Encoding.NONE)i=t;else if(e==w.Encoding.ARRAY)i=t.toArray();else{if("undefined"==typeof Buffer)throw new Error("Buffer not found, unable to serialize. Please provide Buffer in global scope.");let s=Buffer.from(t.buffer);switch(e){case w.Encoding.BUFFER:i=s.toJSON();break;case w.Encoding.BASE64:i=s.toString("base64");break;default:throw new Error(`Invalid encoding provided: ${e.name}`)}}return{encoding:e.name,type:t.constructor.name,content:i}}static decode(t){let e,i=w.Encoding[t.encoding];if(i==w.Encoding.NONE)e=t.content;else if(i==w.Encoding.ARRAY)e=t.content.toFloat32Array();else{if("undefined"==typeof Buffer)throw new Error("Buffer not found, unable to deserialize. Please provide Buffer in global scope.");let s;switch(i){case w.Encoding.BUFFER:s=Buffer.from(t.content);break;case w.Encoding.BASE64:s=Buffer.from(t.content,"base64");break;default:throw new Error(`Invalid encoding provided: ${i.name}`)}let r=new Uint8Array(s);e=new globalThis[t.type](r.buffer)}return e}static isTypedArrayData(t){return t&&t.encoding&&t.type&&t.type.endsWith("Array")}}Object.defineEnum(w,"Encoding",["AUTO","NONE","ARRAY","BUFFER","BASE64"]);class I extends x{constructor(t,e,i){super(t.length,e,i),t=Float32Array.createSharedInstance(t),Object.defineProperty(this,"points",{get:()=>t,enumerable:!0}),Object.defineProperty(this,"buffer",{get:()=>t.buffer,set:e=>{if("undefined"!=typeof SharedArrayBuffer&&this.points.buffer instanceof SharedArrayBuffer)throw new Error("Underlying buffer is SharedArrayBuffer and cannot be restored");if(this.points.buffer.byteLength>0)throw new Error("Cannot restore buffer when underlying buffer is not empty");t=new Float32Array(e)}})}clone(t=!1){if(0==this.buffer.byteLength)throw new Error("Path buffer is empty. Data could be processing under some thread. Clone failed.");return t?new E(this.points.toArray(),Object.clone(this.pointProps),this.layout.slice()):new I(this.points.clone(),Object.clone(this.pointProps),this.layout.slice())}slice(t){let e=this.slicePoints(t.fromPointIndex,t.toPointIndex);return new I(e,Object.clone(this.pointProps),this.layout.slice())}slicePoints(t,e,i=0,s=1){let r;if(S.validate(this,t,e,i,s),"undefined"!=typeof SharedArrayBuffer&&this.buffer instanceof SharedArrayBuffer){let i=this.points.subarray(t*this.stride,(e+1)*this.stride),s=new SharedArrayBuffer(i.length*Float32Array.BYTES_PER_ELEMENT);r=new Float32Array(s),r.set(i)}else r=this.points.slice(t*this.stride,(e+1)*this.stride);return r}toJSON(){return{type:"SharedPath",points:w.encode(this.points,this.encoding),pointProps:this.pointProps,layout:this.layout.map((t=>t.name))}}static fromJSON(t){if("SharedPath"!=t.type)throw new Error(`SharedPath deserialization failed. JSON type is ${t.type}, expected SharedPath.`);return new I(w.decode(t.points),t.pointProps,t.layout.map((t=>m.Property[t])))}}class v{constructor(t,e,i,s){let r=t,n=e,o=t+i,a=e+s;Object.defineProperties(this,{left:{value:r,enumerable:!0},x:{value:t,enumerable:!0},bottom:{value:n,enumerable:!0},y:{value:e,enumerable:!0},right:{value:o,enumerable:!0},top:{value:a,enumerable:!0},width:{value:i,enumerable:!0},height:{value:s,enumerable:!0}})}union(t){if(t&&!(t instanceof v))throw new TypeError("rect must be instance of RectGL");return t?v.ofEdges(Math.min(this.left,t.left),Math.min(this.bottom,t.bottom),Math.max(this.right,t.right),Math.max(this.top,t.top)):this}intersect(t){if(t&&!(t instanceof v))throw new TypeError("rect must be instance of RectGL");if(!t)return null;let e=v.ofEdges(Math.max(this.left,t.left),Math.max(this.bottom,t.bottom),Math.min(this.right,t.right),Math.min(this.top,t.top));return e.width>0&&e.height>0?e:null}ceil(){return v.ofEdges(Math.floor(this.left),Math.floor(this.bottom),Math.ceil(this.right),Math.ceil(this.top))}floor(){return v.ofEdges(Math.ceil(this.left),Math.ceil(this.bottom),Math.floor(this.right),Math.floor(this.top))}transform(t){if(!t)return this;let e=o.fromPoint({x:this.left,y:this.bottom}).transform(t),i=o.fromPoint({x:this.right,y:this.bottom}).transform(t),s=o.fromPoint({x:this.left,y:this.top}).transform(t),r=o.fromPoint({x:this.right,y:this.top}).transform(t),n=Math.min(s.x,r.x,e.x,i.x),a=Math.min(s.y,r.y,e.y,i.y),l=Math.max(s.x,r.x,e.x,i.x),h=Math.max(s.y,r.y,e.y,i.y);return v.ofEdges(n,a,l,h)}toQuad(t){let e;if(t){let i=o.fromPoint({x:this.left,y:this.bottom}).transform(t),s=o.fromPoint({x:this.right,y:this.bottom}).transform(t),n=o.fromPoint({x:this.left,y:this.top}).transform(t),a=o.fromPoint({x:this.right,y:this.top}).transform(t);e=r.fromValues(i.x,i.y,s.x,s.y,n.x,n.y,a.x,a.y)}else e=r.fromValues(this.left,this.bottom,this.right,this.bottom,this.left,this.top,this.right,this.top);return e}toString(){return`gl-rect(${this.x}, ${this.y}, ${this.width}, ${this.height})`}static ofEdges(t,e,i,s){return new v(t,e,i-t,s-e)}static calculateBrushGLSegmentBounds(t,e=0,i){let s,r=.5*t.size,n=Math.abs(e*r);if(i){s=new o(t.x,t.y,t.x,t.z).transform(i)}else s=t;let a=s.x,l=s.y,h=t.scaleX*r,u=t.scaleY*r,p=t.offsetX,c=-t.offsetY,d=Math.cos(t.rotation),f=Math.sin(t.rotation),m=Number.MAX_SAFE_INTEGER,y=Number.MIN_SAFE_INTEGER,g=Number.MAX_SAFE_INTEGER,b=Number.MIN_SAFE_INTEGER;return[{x:-1,y:-1},{x:1,y:-1},{x:-1,y:1},{x:1,y:1}].forEach((t=>{t.x=t.x*h+p,t.y=t.y*u+c;let e=d*t.x+f*t.y+a,i=-f*t.x+d*t.y+l,s=e-n;m=Math.min(m,s),y=Math.max(y,s),s=e+n,m=Math.min(m,s),y=Math.max(y,s);let r=i-n;g=Math.min(g,r),b=Math.max(b,r),r=i+n,g=Math.min(g,r),b=Math.max(b,r)})),v.ofEdges(m,g,y,b)}}Object.defineProperty(v,"SQURE",{value:Object.freeze([Object.freeze({x:-1,y:-1}),Object.freeze({x:1,y:-1}),Object.freeze({x:-1,y:1}),Object.freeze({x:1,y:1})]),enumerable:!0});class O{constructor(t,e,i,s){let r,n,o=t,a=e,l=t+i,h=e+s;Object.defineProperties(this,{left:{value:o,enumerable:!0},top:{value:a,enumerable:!0},right:{value:l,enumerable:!0},bottom:{value:h,enumerable:!0},x:{value:t,enumerable:!0},y:{value:e,enumerable:!0},width:{value:i,enumerable:!0},height:{value:s,enumerable:!0},size:{get:()=>(r||(r={width:i,height:s}),r),enumerable:!0},center:{get:()=>(n||(n={x:(o+l)/2,y:(a+h)/2}),n),enumerable:!0}})}union(t){return t?O.ofEdges(Math.min(this.left,t.left),Math.min(this.top,t.top),Math.max(this.right,t.right),Math.max(this.bottom,t.bottom)):this}intersect(t){if(!t)return null;let e=O.ofEdges(Math.max(this.left,t.left),Math.max(this.top,t.top),Math.min(this.right,t.right),Math.min(this.bottom,t.bottom));return e.width>0&&e.height>0?e:null}intersects(t){return this.left<=t.right&&this.right>=t.left&&this.top<=t.bottom&&this.bottom>=t.top}ceil(t){let e=Math.floor(this.left),i=Math.floor(this.top),s=Math.ceil(this.right),r=Math.ceil(this.bottom);if(t){let t=s-e,n=r-i;t+=t%2,n+=n%2,s=e+t,r=i+n}return O.ofEdges(e,i,s,r)}floor(t){let e=Math.ceil(this.left),i=Math.ceil(this.top),s=Math.floor(this.right),r=Math.floor(this.bottom);if(t){let t=s-e,n=r-i;t-=t%2,n-=n%2,s=e+t,r=i+n}return O.ofEdges(e,i,s,r)}contains(t){return this.left<=t.x&&this.right>=t.x&&this.top<=t.y&&this.bottom>=t.y}includes(t){return this.left<=t.left&&this.right>=t.right&&this.top<=t.top&&this.bottom>=t.bottom}transform(t){if(!t)return this;let e=o.fromPoint({x:this.left,y:this.top}).transform(t),i=o.fromPoint({x:this.right,y:this.top}).transform(t),s=o.fromPoint({x:this.left,y:this.bottom}).transform(t),r=o.fromPoint({x:this.right,y:this.bottom}).transform(t),n=Math.min(e.x,i.x,s.x,r.x),a=Math.min(e.y,i.y,s.y,r.y),l=Math.max(e.x,i.x,s.x,r.x),h=Math.max(e.y,i.y,s.y,r.y);return O.ofEdges(n,a,l,h)}toPath(t,e=1){throw new Error("Rect.toPath is deprecated. Try oneof (ArrayPath, SharedPath, Spline).fromRect(rect, pointProps)")}toGLRect(){return new v(this.x,this.y,this.width,this.height)}toString(){return`rect(${this.x}, ${this.y}, ${this.width}, ${this.height})`}toJSON(){return{x:this.left,y:this.top,width:this.width,height:this.height}}static fromGLRect(t){if(!t)return null;if(!(t instanceof v))throw new TypeError("rect must be instance of RectGL");return new O(t.left,t.bottom,t.width,t.height)}static isRect(t){return t&&isFinite(t.left)&&isFinite(t.top)&&isFinite(t.width)&&isFinite(t.height)}static fromString(t){return t=t.substring(t.indexOf("(")+1,t.indexOf(")")).split(/,\s*/g),new O(parseFloat(t[0]),parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3]))}static fromRect(t){return"string"==typeof t?O.fromString(t):new O(t.x,t.y,t.width,t.height)}static ofPolygon(t){if(t.shape&&(t=t.shape),0==t.length)return null;let e=Number.MAX_SAFE_INTEGER,i=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER;for(let n=0;n<t.length;n++){let o=t.getPointX(n),a=t.getPointY(n);e=Math.min(e,o),i=Math.min(i,a),s=Math.max(s,o),r=Math.max(r,a)}return O.ofEdges(e,i,s,r)}static ofSpline(t,e=0){let i;for(let s=0;s<t.length;s++)i=v.calculateBrushGLSegmentBounds(t.getPoint(s),e).union(i);return O.fromGLRect(i)}static ofEdges(t,e,i,s){return new O(t,e,i-t,s-e)}static union(t,e){return t?e?t.union(e):t:e}static intersect(t,e){return t&&e?t.intersect(e):null}}class T extends I{constructor(t,e,i,s=0,r=1){super(e,i,t),this.ts=s,this.tf=r,Object.defineProperty(this,"segmentsCount",{value:this.length-3,configurable:!0}),Object.defineProperty(this,"bounds",{get:()=>O.ofSpline(this,this.pointProps.scattering).ceil(),enumerable:!0}),Object.defineProperty(this,"color",{get:()=>y.isColor(this.pointProps)?y.fromColor(this.pointProps):void 0,set:t=>{if(!t)throw new Error("Spline color cannot be removed");if(!(t instanceof y))throw new Error("Expected value should be Color instance");"red"in this.pointProps&&(this.pointProps.red=t.red),"green"in this.pointProps&&(this.pointProps.green=t.green),"blue"in this.pointProps&&(this.pointProps.blue=t.blue),"alpha"in this.pointProps&&(this.pointProps.alpha=t.alpha)},enumerable:!0}),this.validate()}validate(){if(!this.layout.includes(m.Property.X))throw new Error("Layout doesn't contains required properties X");if(!this.layout.includes(m.Property.Y))throw new Error("Layout doesn't contains required properties Y");if(0==this.points.length)throw new Error("Empty spline is not allowed");if(this.points.length%this.stride!=0)throw new Error("Path length doesn't match the stride provided via the layout");if(this.ts<0||this.ts>=1)throw new Error(`Invalid spline ts ${this.ts} found. The value must be in the interval [0, 1).`);if(this.tf<=0||this.tf>1)throw new Error(`Invalid spline tf ${this.tf} found. The value must be in the interval (0, 1].`);if(1==this.segmentsCount&&this.ts>this.tf)throw new Error(`Invalid spline t range ${this.ts} - ${this.tf} found. Spline has only one segment and ts <= tf.`);if(this.segmentsCount<1)throw new Error("Incompleted spline found. Spline is defined with at least 4 control points.")}clone(){return new T(this.layout.slice(),this.points.clone(),Object.clone(this.pointProps),this.ts,this.tf)}getSegment(t){let e=t,i=t+3,s=0==e?this.ts:0,r=i+1==this.length?this.tf:1;return this.slice({fromPointIndex:e,toPointIndex:i,fromTValue:s,toTValue:r})}slice(t){let e=this.slicePoints(t.fromPointIndex,t.toPointIndex,t.fromTValue,t.toTValue),i=new T(this.layout.slice(),e,Object.clone(this.pointProps),t.fromTValue,t.toTValue);return i.id=t.id,i}toPlainPath(){let t=[];for(let e=0;e<this.length;e++)t.push(this.getPointX(),this.getPointY());return new E(t)}toJSON(){return{type:"Spline",id:this.id,layout:this.layout.map((t=>t.name)),points:w.encode(this.points,this.encoding),pointProps:this.pointProps,ts:this.ts,tf:this.tf}}static fromJSON(t){let e=w.decode(t.points),i=new T(t.layout.map((t=>m.Property[t])),e,t.pointProps,t.ts,t.tf);return i.id=t.id,i}static fromRect(t,e){let i=[t.left,t.top,t.left,t.top,t.right,t.top,t.right,t.bottom,t.left,t.bottom,t.left,t.top,t.left,t.top];return new T(void 0,i,e)}}class A extends I{constructor(t,e,i,s=[]){super(e,i,t),s.length>0&&!Object.isFrozen(s.first)&&s.forEach((t=>Object.freeze(t))),Object.defineProperty(this,"splineParameters",{value:Object.freeze(s),enumerable:!0});let r=new b(t,i);Object.defineProperty(this,"style",{get:()=>r.style,set:t=>r.style.reset(t),enumerable:!0}),Object.defineProperty(this,"color",{get:()=>this.style.color,set:t=>{if(!t)throw new Error("Spline color cannot be removed");if(!(t instanceof y))throw new Error("Expected value should be Color instance");"red"in this.pointProps&&(this.pointProps.red=t.red),"green"in this.pointProps&&(this.pointProps.green=t.green),"blue"in this.pointProps&&(this.pointProps.blue=t.blue),"alpha"in this.pointProps&&(this.pointProps.alpha=t.alpha)},enumerable:!0}),Object.defineProperty(this,"bounds",{get:()=>O.ofSpline(this,this.pointProps.scattering).ceil(),enumerable:!0}),this.validate()}validate(){if(!this.layout.includes(m.Property.X))throw new Error("Layout doesn't contains required properties X");if(!this.layout.includes(m.Property.Y))throw new Error("Layout doesn't contains required properties Y");if(0==this.points.length)throw new Error("Empty spline is not allowed");if(this.points.length%this.stride!=0)throw new Error("Path length doesn't match the stride provided via the layout")}clone(){return new A(this.layout.slice(),this.points.clone(),Object.clone(this.pointProps),this.splineParameters.slice())}getPoint(t){return super.getPoint(t,this.style)}getPointSegmentIndex(t){return this.splineParameters[t]?this.splineParameters[t].index:void 0}getPointT(t){return this.splineParameters[t]?this.splineParameters[t].t:void 0}getPointParameter(t){return this.splineParameters[t]}toJSON(){return{type:"InterpolatedSpline",layout:this.layout.map((t=>t.name)),points:w.encode(this.points,this.encoding),pointProps:this.pointProps,splineParameters:this.splineParameters}}static fromJSON(t){let e=w.decode(t.points);return new A(t.layout.map((t=>m.Property[t])),e,t.pointProps,t.splineParameters)}static fromRect(t,e){throw new Error("InterpolatedSpline.fromRect is not supported. Try Spline.fromRect and interpolate with particular Spline interpolator.")}}let N=n?n.default||globalThis.poly2tri:{};const{SweepContext:R,Point:F}=N;class M{constructor(t=2){this.stride=t}sort(t,e){return this.sortArrayPart(t,0,t.length-this.stride,e),t}partition(t,e,i,s){let r=t[i],n=t[i+1],o=e-this.stride;for(let a=e;a<i;a+=2)s?s(r,n,t[a],t[a+1])&&(o+=this.stride,this.swap(t,o,a)):(r>t[a]||r==t[a]&&n>t[a+1])&&(o+=this.stride,this.swap(t,o,a));return this.swap(t,o+this.stride,i),o+this.stride}swap(t,e,i){let s=t[e],r=t[e+1];return t[e]=t[i],t[e+1]=t[i+1],t[i]=s,t[i+1]=r,t}sortArrayPart(t,e,i,s){if(e<i){let r=this.partition(t,e,i,s);this.sortArrayPart(t,e,r-this.stride,s),this.sortArrayPart(t,r+this.stride,i,s)}}}function D(t,e,i,s,r,n){return(i-t)*(n-e)-(s-e)*(r-t)}function C(t,e,i,s,r,n){let o=t-i,a=r-i,l=o*(n-s)-a*(e-s);l*=l,o=r-i,a=n-s;let h=o*o+a*a;return h>0?Math.sqrt(l/h):Math.sqrt((i-t)*(i-t)+(s-e)*(s-e))}class ${constructor(t=Float32Array){this.ArrayType=t,this.quickSort=new M}monotoneChain(t){if(t.length<=0)return new this.ArrayType;this.quickSort.sort(t);let e=new this.ArrayType(t.length),i=0;for(let s=0;s<t.length;s+=2){for(;i>=4&&D(e[i-4],e[i-3],e[i-2],e[i-1],t[s],t[s+1])<=0;)i-=2;e[i]=t[s],e[i+1]=t[s+1],i+=2}e=e.slice(0,i);let s,r=new this.ArrayType(t.length);i=0;for(let e=t.length-2;e>=0;e-=2){for(;i>=4&&D(r[i-4],r[i-3],r[i-2],r[i-1],t[e],t[e+1])<=0;)i-=2;r[i]=t[e],r[i+1]=t[e+1],i+=2}if(r=r.slice(0,i-2),this.ArrayType==Float32Array){let t=r.length+e.length;s=Float32Array.createSharedInstance(t),s.set(r),s.set(e,r.length)}else s=r.concat(e);return s}}class k{constructor(t,e=[]){if(!(t instanceof x))throw new Error("Expected shape type is Path. Use createInstance or createSharedInstance Polygon methods to allocate instance.");if(e.some((t=>!(t instanceof x))))throw new Error("Expected hole type is Path. Use createInstance or createSharedInstance Polygon methods to allocate instance.");let i;this.holesDirection=k.PointsDirection.CLOCKWISE,Object.defineProperty(this,"shape",{value:t,enumerable:!0}),Object.defineProperty(this,"holes",{value:e,enumerable:!0}),Object.defineProperty(this,"contours",{value:[t,...e],enumerable:!0}),Object.defineProperty(this,"ArrayType",{value:t instanceof I?Float32Array:Array}),Object.defineProperty(this,"bounds",{get:()=>O.ofPolygon(this),enumerable:!0}),Object.defineProperty(this,"vertices",{get:()=>(i||(i=this.triangulate()),i),set:t=>i=t,enumerable:!0}),Object.defineProperty(this,"verticesValue",{get:()=>i})}clone(t=!1){let e=this.shape.clone(t),i=this.holes.map((e=>e.clone(t))),s=new k(e,i);return this.verticesValue&&(s.vertices=this.vertices.slice()),s}fit(t){let e=this.bounds,i=t.width/e.width,s=t.height/e.height,r=i>0&&s>0?Math.min(i,s):Math.max(i,s);for(let t of this.contours)for(let e=0;e<t.length;e++)t.setPointX(e,t.getPointX(e)*r),t.setPointY(e,t.getPointY(e)*r)}center(){let t=this.bounds;for(let e of this.contours)for(let i=0;i<e.length;i++)e.setPointX(i,e.getPointX(i)-t.center.x),e.setPointY(i,e.getPointY(i)-t.center.y)}transform(t){this.contours.forEach((e=>e.transform(t)))}intersects(t){if(!(t instanceof k))throw new Error("Expected 'poly' type is Polygon");let e=this.shape,i=t.shape;for(let t=0;t<2;t++){let s=0==t?e:i;for(let t=0;t<s.length;t++){let r=t+1==s.length?0:t+1,n=s.getPointX(t),o=s.getPointY(t),a=s.getPointX(r),l=s.getPointY(r)-o,h=n-a,u=Number.POSITIVE_INFINITY,p=Number.NEGATIVE_INFINITY;for(let t=0;t<e.length;t++){let i=l*e.getPointX(t)+h*e.getPointY(t);i<u&&(u=i),i>p&&(p=i)}let c=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY;for(let t=0;t<i.length;t++){let e=l*i.getPointX(t)+h*i.getPointY(t);e<c&&(c=e),e>d&&(d=e)}if(p<c||d<u)return!1}}return!0}triangulate(){let t,e=[];for(let t of this.contours){let i=[];for(let e=0;e<t.length;e++){let s=new F(t.getPointX(e),t.getPointY(e));if(e>0){if(i.last.x==s.x&&i.last.y==s.y)continue;if(e==t.length-1&&i.first.x==s.x&&i.first.y==s.y)continue}i.push(s)}e.push(i)}try{t=new R(e.shift())}catch(t){return console.error(t),new Float32Array}for(let i of e)try{t.addHole(i)}catch(t){return console.error(t),new Float32Array}try{t.triangulate()}catch(t){return console.warn(t),new Float32Array}let i=t.getTriangles(),s=Float32Array.createSharedInstance(6*i.length),r=0;for(let t of i){let e=t.getPoints();for(let t of e)s[r++]=t.x,s[r++]=t.y}return s}convex(){return this.buildConvex.convex(this.shape.points)}union(t){let e=Array.of(...this.shape.points,...t.shape.points);return this.buildConvex(e)}buildConvex(t){this.convexHullProducer||(this.convexHullProducer=new $(this.ArrayType));let e=this.convexHullProducer.monotoneChain(t);return this.ArrayType==Float32Array?k.createSharedInstance(e):k.createInstance(e)}simplify(t=.1){if(t<=0)throw new Error("epsilon expected value > 0");this.epsilon=t;let e=this.simplifyPath(this.shape),i=[];for(let t of this.holes){let e=this.simplifyPath(t);e.length>0&&i.push(e)}return this.shape instanceof I?k.createSharedInstance(e,i):k.createInstance(e,i)}simplifyPath(t){if(t.length<3)return t.points;let e=Array.of(...t.points,t.getPointX(0),t.getPointY(0)),i=this.simplifyPolyline(e);return i.length<8?e.slice(0,e.length-2):i.slice(0,i.length-2)}simplifyPolyline(t){if(t.length<4)return t;let e=0,i=0;for(let s=2;s<t.length-2;s+=2){let r=C(t[s],t[s+1],t[0],t[1],t[t.length-2],t[t.length-1]);r>e&&(i=s,e=r)}if(e>this.epsilon){let e=this.simplifyPolyline(t.slice(0,i+2)),s=this.simplifyPolyline(t.slice(i,t.length));return e.concat(s.slice(2,s.length))}return[t[0],t[1],t[t.length-2],t[t.length-1]]}toSVGPath(){return this.contours.map((t=>t.toSVGPath())).join(" ")}toJSON(){return{type:"Polygon",shape:this.shape.toJSON(),holes:this.holes.map((t=>t.toJSON())),holesDirection:this.holesDirection.name,vertices:this.verticesValue}}static fromJSON(t){if("Polygon"!=t.type)throw new Error(`Polygon deserialization failed. JSON type is ${t.type}, expected Polygon.`);let e="SharedPath"==t.shape.type?I.fromJSON(t.shape):E.fromJSON(t.shape),i=t.holes.map((t=>"SharedPath"==t.type?I.fromJSON(t):E.fromJSON(t))),s=new k(e,i);return s.holesDirection=k.PointsDirection[t.holesDirection],s.vertices=t.vertices,s}static fromRect(t){return k.createInstance([t.left,t.top,t.right,t.top,t.right,t.bottom,t.left,t.bottom,t.left,t.top])}static createInstance(t,e=[]){return new k(new E(t),e.map((t=>new E(t))))}static createSharedInstance(t,e=[]){let i=new k(new I(t),e.map((t=>new I(t))));return Object.defineProperty(i,"encoding",{get:()=>i.shape.encoding,set:t=>{i.contours.forEach((e=>e.encoding=t))},enumerable:!0}),i}}Object.defineEnum(k,"PointsDirection",["CLOCKWISE","COUNTERCLOCKWISE"]);class L{static ARRAY_TYPE=Array;constructor(){this.keepAllData=!1,Object.defineProperty(this,"allData",{get:()=>{if(!this.keepAllData)throw new Error("All data is not accumulated. By default keepAllData property is false.");return this.path||(this.path=new this.constructor.ARRAY_TYPE),this.getOutput(this.path,L.OutputType.ALL_DATA)},enumerable:!0})}build(t,e=L.OutputType.PROCESSOR,i=!0){let s;switch(e){case L.OutputType.ADDITION:s=this.add(t,i);break;case L.OutputType.PREDICTION:s=this.predict(t);break;case L.OutputType.PROCESSOR:this.reset(),s=this.buildImpl(t,e);break;default:throw new Error("Unexpected OutputType found. Allowed type is oneof(ADDITION, PREDICTION, PROCESSOR)")}return e!=L.OutputType.PREDICTION&&this.keepAllData&&(this.path||(this.path=new this.constructor.ARRAY_TYPE),s instanceof k?this.path.push(s):this.path.push(...s)),this.debug&&console.log(this.constructor.name,e.name,i,s),this.getOutput(s,e)}add(t,e=!1){return this.buildImpl(t,L.OutputType.ADDITION)}predict(t){return this.buildImpl(t,L.OutputType.PREDICTION)}buildImpl(t){throw new Error("Abstract method buildImpl(input) of DataSequenceProcessor should be implemented")}getOutput(t,e){return t}reset(){this.path&&(this.path=new this.constructor.ARRAY_TYPE)}}Object.defineEnum(L,"OutputType",["ADDITION","PREDICTION","ALL_DATA","PROCESSOR"]);class j extends Array{static get[Symbol.species](){return Array}constructor(...t){if(super(...t),t.some((t=>!(t instanceof k))))throw new Error("Expected data item type is Polygon");Object.defineProperty(this,"bounds",{get:()=>{let t;return this.length>0&&(this.forEach((e=>t=e.bounds.union(t))),t=t.ceil()),t},enumerable:!0}),Object.defineProperty(this,"vertices",{get:()=>this.triangulate(),enumerable:!0})}clone(){return new this.constructor(...this.map((t=>t.clone())))}push(...t){if(t.some((t=>!(t instanceof k))))throw new Error("Expected data item type is Polygon");super.push(...t)}triangulate(){return Float32Array.createSharedInstance().concat(...this.map((t=>t.vertices)))}transform(t){this.forEach((e=>e.transform(t)))}toJSON(){return{type:"PolygonArray",polygons:this.map((t=>t.toJSON()))}}static fromJSON(t){if("PolygonArray"!=t.type)throw new Error(`PolygonArray deserialization failed. JSON type is ${t.type}, expected PolygonArray.`);return new j(...t.polygons.map((t=>k.fromJSON(t))))}}class _ extends j{constructor(...t){let e;super(...t),Object.defineProperty(this,"encoding",{get:()=>e,set:t=>{e=t,this.forEach((e=>e.encoding=t))},enumerable:!0})}intersects(t){t instanceof k&&(t=[t]);for(let e of this)for(let i of t)if(e.intersects(i))return{poly1:e,poly2:i};return null}toJSON(){let t=super.toJSON();return t.type="InkPath2D",t}static fromJSON(t){if("InkPath2D"!=t.type)throw new Error(`InkPath2D deserialization failed. JSON type is ${t.type}, expected InkPath2D.`);return new _(...t.polygons.map((t=>k.fromJSON(t))))}}class V extends L{static ARRAY_TYPE=_;constructor(t){super(),this.brush=t}buildImpl(t){return this.generatePolygons(t)}generatePolygons(t){let e=new _;if(!t)return e;for(let i=0;i<t.length;i++){let s=t.getPoint(i),r=this.applyBrush(s);e.push(r)}return e}applyBrush(t){let e=this.createTransform(t),s=this.brush.selectShape(e.maxScale).shape,r=Float32Array.createSharedInstance(2*s.length);for(let t=0;t<s.length;t++){let n=t*s.stride,o=i.fromValues(s.getPointX(t),s.getPointY(t),0,1);i.transformMat4(o,o,e),r[n]=o[0]/o[3],r[n+1]=o[1]/o[3]}return k.createSharedInstance(r)}createTransform(t){if(isNaN(t.size))throw new Error("Size information not found.");let i=s.create(),r=t.size*t.scaleX,n=t.size*t.scaleY,o=t.size*t.scaleZ||0,a=Math.max(r,n,o);return s.translate(i,i,e.fromValues(t.x,t.y,t.z||0)),s.rotateZ(i,i,t.rotation),s.translate(i,i,e.fromValues(t.offsetX,t.offsetY,t.offsetZ||0)),s.scale(i,i,e.fromValues(r,n,o)),i.maxScale=a,i}}let Y;class X{constructor(){if(Y)throw new Error("URIResolver instance already available");Y=this,this.init()}init(){throw new Error("URIResolver: init should be implemented")}get(t){return this[t]}register(t,e){this[t]=e}resolve(t){let e;if(t.includes("?")){let i=this[t.split("?")[0]];if(i){let s=t.split("?")[1],r=[];s.split("&").forEach((t=>{let e=t.split("=")[1],i=parseFloat(e);isFinite(i)?e=i:"true"==e?e=!0:"false"==e&&(e=!1),r.push(e)})),e=function(){return i(...Array.from(arguments).concat(r))}}}else e=this[t];if(!e)throw new Error(`Failed to resolve ${t}`);return e}}Object.defineProperty(X,"instance",{get:()=>Y});class B{static repetitionsCache=new Set;constructor(t,e){this.name=t,!t||g.isValidURL(t)||B.repetitionsCache.has(t)||(B.repetitionsCache.add(t),console.warn(`The string ${t} is not a well formed URI`)),Object.defineProperty(this,"value",{get:function(){if(!e){if(!this.name)throw new Error("Resource descriptor identifier not found. Cannot resolve resource content.");if("function"==typeof this.resolve&&(e=this.resolve(this.name)),!e){if(!X.instance)throw new Error(`Resource URI ${this.name} cannot be resolved. URIResolver not implemented yet. Please implement and instantiate.`);e=X.instance.resolve(this.name)}if(!e)throw new Error(`Resource URI ${this.name} cannot be resolved. Please provide resource definition in URIResolver init implementation.`)}return e},set:function(t){e=t},enumerable:!0})}toJSON(){let t=this.value;return ArrayBuffer.isTypedArray(t)?t=w.encode(t,this.encoding):"function"==typeof t&&(t=t()),{name:this.name,value:t}}static fromJSON(t){let e=t.value;return w.isTypedArrayData(e)&&(e=w.decode(e)),new B(t.name,e)}static getInstance(t,e){return new B(e,t)}}class z{static defaults={CIRCLE_PRECISION:20,CIRCLE_RADIUS:.5,ELLIPSE_PRECISION:20,ELLIPSE_RADIUS_X:.5,ELLIPSE_RADIUS_Y:.25,STAR_POINTS:5,STAR_RADIUS:.5,STAR_INTERNAL_RADIUS:.25};static createCircle(t=z.defaults.CIRCLE_PRECISION,e=z.defaults.CIRCLE_RADIUS,i={x:0,y:0}){return z.createEllipse(t,e,e,i)}static createEllipse(t=z.defaults.ELLIPSE_PRECISION,e=z.defaults.ELLIPSE_RADIUS_X,i=z.defaults.ELLIPSE_RADIUS_Y,s={x:0,y:0}){let r=[],n=2*Math.PI/t;if(e<=0)throw new Error(`Invalid radius x found ${e} > 0`);if(i<=0)throw new Error(`Invalid radius y found ${i} > 0`);for(let o=0;o<t;o++){let t=o*n,a=e*Math.cos(t),l=i*Math.sin(t);r.push(s.x+a,s.y+l)}return Float32Array.createSharedInstance(r)}static createStar(t=z.defaults.STAR_POINTS,e=z.defaults.STAR_INTERNAL_RADIUS,i=z.defaults.STAR_RADIUS){let s=[];if(i<=0)throw new Error(`Invalid radius found ${i} > 0`);if(e<=0)throw new Error(`Invalid internal radius found ${e} > 0`);if(e>i)throw new Error(`Invalid internal radius found 0 < ${e} < ${i}`);let r=2*Math.PI/t;for(let n=0;n<t;n++){let t=n*r,o=i*Math.cos(t),a=i*Math.sin(t),l=e*Math.cos(t+r/2),h=e*Math.sin(t+r/2);s.push(o,a,l,h)}return Float32Array.createSharedInstance(s)}}class U{static SHAPE_FRAME=new O(-.5,-.5,1,1);constructor(t,e=1){this.size=e,Object.defineProperty(this,"descriptor",{value:{shape:void 0},enumerable:!0}),Object.defineProperty(this,"shape",{get:function(){if(!t){if("function"==typeof(t=this.descriptor.shape.value)&&(t=t()),(Array.isArray(t)||t instanceof Float32Array)&&(t=k.createSharedInstance(t)),!(t instanceof k))throw new Error("Expected shape type is Polygon");U.fitShape(t)}return t},set:function(e){if(!e)throw new Error("BrushPrototype: shape not found");"string"==typeof e?e=new B(e):e instanceof k||e instanceof Float32Array||Array.isArray(e)?e=B.getInstance(e):e instanceof B||(e=new B(e.name,e.value)),t=null,this.descriptor.shape=e,this.descriptor.shape.resolve=U.resolve},enumerable:!0}),this.shape=t}toJSON(){return this.shape.encoding=this.encoding,{shape:{name:this.descriptor.shape.name,value:this.shape.toJSON()},size:this.size}}static fromJSON(t){return new U({name:t.shape.name,value:k.fromJSON(t.shape.value)},t.size)}static create(t,e=0,...i){let s,r=t;switch(t){case U.Type.CIRCLE:s=z.createCircle(...i),r+=`?precision=${i[0]||z.defaults.CIRCLE_PRECISION}&radius=${i[1]||z.defaults.CIRCLE_RADIUS}`;break;case U.Type.ELLIPSE:s=z.createEllipse(...i),r+=`?precision=${i[0]||z.defaults.ELLIPSE_PRECISION}&radiusX=${i[1]||z.defaults.ELLIPSE_RADIUS_X}&radiusY=${i[2]||z.defaults.ELLIPSE_RADIUS_Y}`;break;case U.Type.STAR:s=z.createStar(...i),r+=`?points=${i[0]||z.defaults.STAR_POINTS}&internalRadius=${i[1]||z.defaults.STAR_INTERNAL_RADIUS}&radius=${i[2]||z.defaults.STAR_RADIUS}`;break;default:console.error(`Brush2D: createShape fails with ${t} type`)}return new U({name:r,shape:s},e)}static resolve(t){let e,i=t.split("?"),s=i.first;if(Object.values(U.Type).includes(s)){let t=i.last.split("&"),r={};switch(t.forEach((t=>{r[t.substring(0,t.indexOf("="))]=t.substring(t.indexOf("=")+1)})),s){case U.Type.CIRCLE:{let t=r.precision?parseInt(r.precision):void 0,i=r.radius?parseFloat(r.radius):1;e=z.createCircle(t,i);break}case U.Type.ELLIPSE:{let t=r.precision?parseInt(r.precision):void 0,i=r.radiusX?parseFloat(r.radiusX):void 0,s=r.radiusY?parseFloat(r.radiusY):void 0;e=z.createEllipse(t,i,s);break}case U.Type.STAR:{let t=r.points?parseInt(r.points):void 0,i=r.radius?parseFloat(r.radius):void 0,s=r.internalRadius?parseFloat(r.internalRadius):void 0;e=z.createStar(t,s,i);break}default:console.error(`Brush2D: createShape fails with ${s} type`)}}return e}static fitShape(t){if(!(t instanceof k))throw new Error("Expected shape type is Polygon");t.center(),t.fit(U.SHAPE_FRAME)}}U.Type={ELLIPSE:"will://brush/3.0/shape/Ellipse",CIRCLE:"will://brush/3.0/shape/Circle",STAR:"will://brush/3.0/shape/Star"};Object.defineProperty(globalThis,"DIGITAL_INK_ENV",{value:"AUTO",enumerable:!0,configurable:!0});let J={version:"1.4.2"};async function Z(t){let e;return e="string"==typeof t||"undefined"==typeof createImageBitmap?await function(t){return new Promise(((e,i)=>{let s,r=new Image;r.crossOrigin="anonymous",r.onload=()=>{if(J.type2D==J.Type2D.OFFSCREEN){const t=new OffscreenCanvas(r.width,r.height);t.getContext("2d").drawImage(r,0,0),e(t)}else s&&URL.revokeObjectURL(s),e(r)},r.onerror=i,"string"==typeof t?r.src=t:J.type2D==J.Type2D.OFFSCREEN?t instanceof Uint8Array?r.src=Buffer.from(t):t instanceof OffscreenCanvas?e(t):r.src=t:(t instanceof Uint8Array&&(t.byteLength!=t.buffer.byteLength&&(t=t.slice()),t=t.buffer),t instanceof ArrayBuffer&&(t=new Blob([t],{type:"image/png"})),s=URL.createObjectURL(t),r.src=s)}))}(t):t instanceof ArrayBuffer||t instanceof Uint8Array?await createImageBitmap(new Blob([t],{type:"image/png"})):await createImageBitmap(t),e}Object.defineEnum(J,"Type",["WEB","WORKER","NODE","SHELL"]),Object.defineEnum(J,"Type2D",["SCREEN","OFFSCREEN"]),Object.defineEnum(J,"TypeGL",["WEB","STACK"]),function(t){let e,i="BROWSER"!=DIGITAL_INK_ENV&&"object"==typeof process&&"function"==typeof require;e="object"==typeof window?"WEB":"function"==typeof importScripts?"WORKER":i?"NODE":"SHELL";let s="undefined"==typeof OffscreenCanvas?"OFFSCREEN":"SCREEN",r="undefined"==typeof WebGLRenderingContext?"STACK":"WEB";Object.defineProperty(J,"commonJS",{value:i,enumerable:!0}),Object.defineProperty(J,"type",{value:J.Type[e],enumerable:!0}),Object.defineProperty(J,"type2D",{value:J.Type2D[s],enumerable:!0}),Object.defineProperty(J,"typeGL",{value:J.TypeGL[r],enumerable:!0})}();class G extends class{constructor(t){g.isValidURL(t)||(B.repetitionsCache.has(t)||(B.repetitionsCache.add(t),console.warn(`Brush URI ${t} is not a well formed URI`)),t=this.constructor.onInvalidName(t)),Object.defineProperty(this,"id",{value:t}),Object.defineProperty(this,"uri",{value:t}),Object.defineProperty(this,"name",{value:t,enumerable:!0})}toJSON(){throw new Error("Brush.toJSON() should be implemented")}static fromJSON(t){throw new Error("static Brush.fromJSON() should be implemented")}static onInvalidName(t){return t}}{constructor(t,e,i,s=1){super(t),isFinite(i)&&(s=i,i=void 0),s<=0&&(console.warn(`Invalid spacing found ${s}. It should be positive number.`),s=1),Object.defineProperty(this,"shape",{get:()=>e,set:t=>{if(t instanceof Float32Array&&(t=new U(t)),t instanceof U&&(t=[t]),t.some((t=>!(t instanceof U))))throw console.warn(t),new Error("Brush2D: Invalid shape found");t.sort(g.comparator({sortBy:"size",sortOrder:"asc"})),e=t},enumerable:!0}),this.shape=e,this.fill=i,this.spacing=s}async configure(t){if(this.pattern||!this.fill)return;if(!(t instanceof CanvasRenderingContext2D||t instanceof OffscreenCanvasRenderingContext2D))throw new Error("ctx is not instance of CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D");let e=await Z(this.fill);this.pattern=t.createPattern(e,"repeat")}selectShape(t){let e;for(let i=1;i<this.shape.length;i++)if(this.shape[i].size>t){e=this.shape[i-1];break}return e||(e=this.shape.last),e.shape}toJSON(){return{type:"Brush2D",name:this.name,spacing:this.spacing,shape:this.shape.map((t=>(t.encoding=this.encoding,t.toJSON())))}}static fromJSON(t){let e=1==t.shape.length?U.fromJSON(t.shape[0]):t.shape.map((t=>U.fromJSON(t)));return new G(t.name,e,t.spacing)}}const H=s.fromValues(0,-.5,1,-.5,1,0,-2.5,1.5,0,.5,2,-1.5,0,0,-.5,.5);class q extends L{constructor(t=!1,e=!1){super(),this.calculateDerivates=t,this.keepSplineParameters=e,this.state={lastPointPosition:void 0,lastPointSize:0}}initState(t){this.state.layout={},t.layout.forEach(((t,e)=>{this.state.layout[t.name]={index:e,polynomials:i.create()}})),this.keepSplineParameters&&(this.state.splineParameters=[]),this.splineLayout=t.layout,this.pathPointProps=Object.clone(t.pointProps),this.scattering&&(this.pathPointProps.scattering=this.scattering),this.layout=this.calculateDerivates?t.layout.concat([m.Property.D_X,m.Property.D_Y]):t.layout,this.state.ready=!0}predict(t){if(!t)return[];this.state.ready||this.initState(t);let e=Object.clone(this.state);delete this.state.splineParameters,this.resetState();let i=this.discretize(t);return this.state=e,i}buildImpl(t){return t?(this.state.ready||this.initState(t),this.discretize(t)):[]}getOutput(t,e){if(0!=t.length){let i=e==q.OutputType.ALL_DATA?void 0:this.state.splineParameters;return i&&(i=i.slice()),new A(this.layout,t,this.pathPointProps,i)}}discretize(t){throw new Error("This method is abstract and should be implemented")}storeLastPoint(t,e=0){this.state.lastPointPosition=new o(this.getPropValue(m.Property.X,t,e),this.getPropValue(m.Property.Y,t,e),this.getPropValue(m.Property.Z,t,e)),this.state.lastPointSize=this.getPropValue(m.Property.SIZE,t,e)}getPropValue(t,e,i=0){return this.state.layout[t.name]?e[i+this.state.layout[t.name].index]:void 0}calculatePolynomials(t,e){let s=t.points,r=this.splineLayout.length*(e+0),n=this.splineLayout.length*(e+1),o=this.splineLayout.length*(e+2),a=this.splineLayout.length*(e+3);this.splineLayout.forEach(((t,e)=>{let l=i.fromValues(s[r+e],s[n+e],s[o+e],s[a+e]);i.transformMat4(this.state.layout[t.name].polynomials,l,H)}))}calculateInterpolatedPoint(t,e,s){this.initState(t);let r=new m(0,0,this.splineLayout.includes(m.Property.Z)?0:void 0),n=i.fromValues(1,s,s*s,s*s*s);return this.calculatePolynomials(t,e),this.splineLayout.forEach((t=>{let e=i.dot(this.state.layout[t.name].polynomials,n);r[g.getPropName(t.name)]=e})),r}samplePoint(t){let e=[],s=i.fromValues(1,t,t*t,t*t*t);return this.splineLayout.forEach((t=>{let r=i.dot(this.state.layout[t.name].polynomials,s);e.push(r)})),this.calculateDerivates&&(e.push(this.getDerivativeOf(this.state.layout.X.polynomials,s)),e.push(this.getDerivativeOf(this.state.layout.Y.polynomials,s))),e}getDerivativeOf(t,e){let s=i.fromValues(t[1],2*t[2],3*t[3],0);return i.dot(s,e)}static defineParameter(t,e){return t>0&&0==e?{index:t-1,t:1}:{index:t,t:e}}keepSegmentT(t,e){this.state.splineParameters&&this.state.splineParameters.push(q.defineParameter(t,e))}resetState(){}reset(){super.reset(),this.state.ready=!1,this.state.lastPointPosition=void 0,this.state.lastPointSize=0,delete this.state.splineParameters}}class K extends q{constructor(t=.1,e,i){super(e,i),this.spacing=t}split(t,e=8){let i=this.spacing;this.spacing=1,this.splitCount=e;let s=this.build(t);return this.spacing=i,delete this.splitCount,s}discretize(e){let i=[],s=this.splitCount,r=Math.max(1,10*(this.spacing>1?1:this.spacing));for(let n=0;n<e.segmentsCount;n++){if(this.calculatePolynomials(e,n),isNaN(this.splitCount)){let i=e.getPoint(n+1),o=e.getPoint(n+2),a=t.distance(i.value,o.value),l=this.pathPointProps.size;this.state.layout.SIZE&&(l=Math.min(i.size,o.size)),s=Math.floor(r*(a/l)/this.spacing)+1}let a=1/s;for(let t=0;t<=s;t++){let r=!this.state.lastPointPosition,l=t/s;if(0==n&&l<e.ts){if(!(l+a>=e.ts))continue;l=e.ts,r=this.spacing<=1}if(n==e.segmentsCount-1&&l>=e.tf){if(!(l<e.tf+a))continue;l=e.tf,r=this.lastSegment&&this.spacing<=1}if(n>0&&0==l)continue;let h=this.samplePoint(l);if(!r&&this.state.lastPointPosition){let t=new o(this.getPropValue(m.Property.X,h),this.getPropValue(m.Property.Y,h),this.getPropValue(m.Property.Z,h)),e=this.state.lastPointPosition.vec.squaredDistance(this.state.lastPointPosition.value,t.value),i=(this.state.layout.SIZE?(this.state.lastPointSize+h[this.state.layout.SIZE.index])/2:this.pathPointProps.size)*this.spacing;r=e>=i*i}r&&(i.push(...h),this.storeLastPoint(h),this.keepSegmentT(n,l))}}return this.state.splineParameters&&(0!=i.length&&this.state.splineParameters.first.t==e.ts||(i.unshift(...this.samplePoint(e.ts)),this.state.splineParameters.unshift(q.defineParameter(0,e.ts))),this.state.splineParameters.last.t!=e.tf&&(i.push(...this.samplePoint(e.tf)),this.state.splineParameters.push(q.defineParameter(e.segmentsCount-1,e.tf)))),i}}class W{constructor(t){this.header=[],this.table=[],t.forEach((t=>{"string"==typeof t&&(t={name:t,title:t}),t.size=t.title.length,this.header.push(t)})),Object.defineProperty(this,"length",{get:()=>this.table.length,enumerable:!0})}insert(t){this.table.push(t),this.header.forEach((e=>{let i=t[e.name];null!=i&&(e.size=Math.max(e.size,i.toString().length))}))}build(){let t=[],e=this.header.length+1,i=[];return this.header.forEach((t=>{e+=t.size+2;let s=t.size-t.title.length,r=Math.floor(s/2),n=Math.ceil(s/2);i.push(this.getRepetedValue(r)+t.title+this.getRepetedValue(n))})),this.table.forEach((e=>{let i=[];this.header.forEach((t=>{let s=null==e[t.name]?"":e[t.name],r=t.size-s.toString().length;i.push(s+this.getRepetedValue(r))})),t.push(i)})),{delimiterLength:e,headerRow:i,content:t}}getFormattedRow(t){let e="| ";return t.forEach((t=>{e+=t,e+=" | "})),e.trim()}getRepetedValue(t,e=" "){return new Array(t+1).join(e)}clear(){this.table.clear()}toString(){let t="",{delimiterLength:e,headerRow:i,content:s}=this.build();return t+=this.getRepetedValue(e,"="),t+="\n",t+=this.getFormattedRow(i),t+="\n",t+=this.getRepetedValue(e,"="),t+="\n",s.forEach((e=>{t+=this.getFormattedRow(e),t+="\n"})),t}}class Q{constructor(){this.interpolator=new K(.1,!1,!0)}build(t,e,i){this.context=t,this.path=i,this.holesPerStroke={},this.strokeHoles=[],e.sort(g.comparator({sortBy:"strokeID",sortOrder:"asc"},{sortBy:"segmentIndex",sortOrder:"asc"},{sortBy:"splineIndex",sortOrder:"asc"},{sortBy:"pointIndex",sortOrder:"asc"})),this.debug&&(this.table=new W([{name:"strokeID",title:"Stroke ID"},{name:"segmentIndex",title:"Segment Index"},{name:"splineIndex",title:"Spline Index"},{name:"pointIndex",title:"Point Index"},{name:"prevT",title:"Prev T"},{name:"t",title:"T Value"},{name:"nextT",title:"Next T"},{name:"ts",title:"Start T"},{name:"tf",title:"End T"},{name:"size",title:"Size"},{name:"hole",title:"HolePart"},{name:"nodeIndex",title:"Node Index"}]));for(let t of e)this.isHolePart(t)?this.update(t):this.add(t),this.debug&&this.table.insert({strokeID:t.strokeID,segmentIndex:t.segmentIndex,splineIndex:t.splineIndex,pointIndex:t.pointIndex,prevT:t.prevT.toFixed(4),t:t.t.toFixed(4),nextT:t.nextT.toFixed(4),ts:t.spline.ts.toFixed(4),tf:t.spline.tf.toFixed(4),size:`${t.bounds.width.toFixed(2)} / ${t.bounds.height.toFixed(2)}`,hole:t.hole,nodeIndex:t.nodeIndex});return this.debug&&this.table.length>0&&console.log(this.table.toString()),this.narrow(),this.holesPerStroke}add(t){this.strokeHoles=this.holesPerStroke[t.strokeID],this.strokeHoles||(this.strokeHoles=[],this.holesPerStroke[t.strokeID]=this.strokeHoles);let e=this.context.getNodes(t.strokeID).indexOf(t);this.strokeHoles.push({fromPointIndex:t.segmentIndex,toPointIndex:t.segmentIndex,fromTValue:t.prevT,toTValue:t.nextT,fromNodeIndex:e,toNodeIndex:e,strokeID:t.strokeID}),this.debug&&(t.hole=!1,t.nodeIndex=e)}update(t){let e=this.strokeHoles.last;e.toPointIndex=t.segmentIndex,e.toTValue=t.nextT,e.toNodeIndex=this.context.getNodes(t.strokeID).indexOf(t),this.debug&&(t.hole=!0,t.nodeIndex=e.toNodeIndex)}isHolePart(t){let e=this.strokeHoles.last;return!(!e||e.strokeID!=t.strokeID)&&(t.segmentIndex==e.toPointIndex&&t.prevT<=e.toTValue||t.segmentIndex==e.toPointIndex+1&&1==e.toTValue&&0==t.prevT)}narrow(){let t=Object.values(this.holesPerStroke);for(let e of t)for(let t of e){let e=this.context.getNodes(t.strokeID),i=e[t.fromNodeIndex],s=e[t.toNodeIndex],r={s:this.extractT(i,"s",i.prevT,i.nextT),f:this.extractT(s,"f",s.prevT,s.nextT)};i.ts=r.s,s.tf=r.f,t.fromTValue=r.s,t.toTValue=r.f}}extractT(t,e,i,s){let r,n,o="s"==e?i:s;try{r=new T(t.spline.layout,t.spline.points,t.spline.pointProps,i,s)}catch(t){return o}let a=this.interpolator.build(r);for(let i=0;i<a.length;i++){let s=a.getPoint(i),r=this.context.getBrushApplier(t.strokeID).applyBrush(s);if(this.path.intersects(r)){if("s"==e){o=n;break}n=a.getPointT(i)}else if("s"==e)n=a.getPointT(i);else if(n){o=a.getPointT(i);break}}return o}}class tt{constructor(t=tt.Mode.WHOLE_STROKE){this.mode=t,this.operations=Promise.resolve(),this.holesBuilder=new Q}updateSegmentation(t){if(!this.context)throw new Error("Required spatial context not found");if(!t||0==t.length)return;let e=[],i=!1;for(let s of t){let r=this.context.search(s.bounds);if(0==r.length)continue;let n=[];for(let t of r)switch(t.depth){case tt.SegmentationDepth.STROKE_BOUNDS:{let e=[],s=this.context.getStroke(t.strokeID),r=this.context.getBrushApplier(s.id);for(let t=0;t<s.segmentsCount;t++){let i=tt.buildStrokeSegment(s.id,s.spline,t,r);e.push(i)}this.context.updateTree(t,e),n=n.concat(e),i=!0;break}case tt.SegmentationDepth.STROKE_SEGMENT:{let e=[],s=this.context.getBrushApplier(t.strokeID),r=this.context.distanceInterpolator.build(t.spline),o=s.build(r),a=this.buildShapeSegment(0,t.spline,r,o);for(let i=0;i<r.length-1;i++){let s=this.buildSplineSegment(t,i,r,o,a);a=s.fPoint,e.push(s)}this.context.updateTree(t,e),n=n.concat(e),i=!0;break}case tt.SegmentationDepth.SPLINE_SEGMENT:t.convex=this.context.convexHullChainProducer.build(t.shapesPath),t.shape=t.convex.first,t.depth=tt.SegmentationDepth.CONVEX,i=!0;break;case tt.SegmentationDepth.CONVEX:if(t.convex.intersects(s))if(this.mode==tt.Mode.PARTIAL_STROKE){let e=[];e.push(this.buildPointSegment(t,0)),e.push(this.buildPointSegment(t,1)),this.context.updateTree(t,e),n=n.concat(e),i=!0}else e.push(t);break;case tt.SegmentationDepth.SHAPE:e.push(t);break;default:throw new Error(`Invalid node depth found: ${t.depth}`)}if(n.length>0&&this.context.load(n),i){this.updateSegmentation(t);break}for(let t of e)this.nodes.add(t);this.context.tree.canvas&&this.context.tree.canvas.refresh()}}async updateSegmentationAsync(t){if(!this.context)throw new Error("Required spatial context not found");if(!t||0==t.length)return;let e=!1;for(let i of t){let s=this.context.search(i.bounds);if(0==s.length)continue;let r=[];for(let t of s)switch(t.depth){case tt.SegmentationDepth.STROKE_BOUNDS:{let i=this.context.getStroke(t.strokeID),s=await this.context.segmentsProducer.buildStrokeSegments(i);this.context.updateTree(t,s),r=r.concat(s),e=!0;break}case tt.SegmentationDepth.STROKE_SEGMENT:{let i=[],s=this.context.getBrushApplier(t.strokeID),n=this.context.curvatureInterpolator.build(t.spline),o=s.build(n);for(let e=0;e<n.length-1;e++){let s=this.buildSplineSegment2(t,e,n,o);i.push(s)}this.context.updateTree(t,i),r=r.concat(i),e=!0;break}case tt.SegmentationDepth.SPLINE_SEGMENT:t.convex=this.context.convexHullChainProducer.build(t.shapesPath),t.depth=tt.SegmentationDepth.CONVEX,e=!0;break;case tt.SegmentationDepth.CONVEX:if(t.convex.intersects(i))if(this.mode==tt.Mode.PARTIAL_STROKE){let i=[],s=this.context.getBrushApplier(t.strokeID),n=this.context.distanceInterpolator.build(t.spline),o=s.build(n);for(let e=0;e<n.length;e++){let s=this.buildPointSegment2(t,e,n,o);i.push(s)}this.context.updateTree(t,i),r=r.concat(i),e=!0}else this.nodes2.push(t),this.context.unload(t);break;case tt.SegmentationDepth.SHAPE:this.nodes2.push(t),this.context.unload(t);break;default:throw new Error(`Invalid node depth found: ${t.depth}`)}if(r.length>0&&this.context.load(r),e){await this.updateSegmentationAsync(t);break}this.context.tree.canvas&&this.context.tree.canvas.refresh()}}static buildStrokeNode(t){return{strokeID:t.id,bounds:t.bounds,depth:tt.SegmentationDepth.STROKE_BOUNDS}}static buildStrokeSegment(t,e,i,s){if(i<0||i>=e.segmentsCount)throw new Error(`Invalid index ${i} found. Ensure that index range is {0, ${e.segmentsCount-1}}.`);const r=.166666666666;let n=e.getSegment(i),o=n.getPoint(0),a=n.getPoint(1),l=n.getPoint(2),h=n.getPoint(3),u=-r*o.x+a.x+r*l.x,p=-r*o.y+a.y+r*l.y,c=+r*a.x+l.x-r*h.x,d=+r*a.y+l.y-r*h.y,f=a.toArray(n.layout).concat(l.toArray(n.layout)),m=new A(n.layout,f,n.pointProps),y=s.build(m),g=y.first.bounds,b=y.last.bounds,P=Math.max(g.width,b.height),x=Math.max(g.height,b.height),S=Math.max(P,x),E=new O(u-S/2,p-x/2,S,S),w=new O(c-S/2,d-x/2,S,S);return{strokeID:t,segmentIndex:i,bounds:g.union(b).union(E).union(w),spline:n,depth:tt.SegmentationDepth.STROKE_SEGMENT}}buildSplineSegment(t,e,i,s,r){let n=new _(s[e],s[e+1]),o=this.buildShapeSegment(e+1,t.spline,i,s);return{strokeID:t.strokeID,segmentIndex:t.segmentIndex,splineIndex:e,bounds:n.bounds,spline:new T(t.spline.layout,t.spline.points,t.spline.pointProps,i.getPointT(e),i.getPointT(e+1)),shapesPath:n,sPoint:r,fPoint:o,depth:tt.SegmentationDepth.SPLINE_SEGMENT}}buildSplineSegment2(t,e,i,s){let r=new _(s[e],s[e+1]);return{strokeID:t.strokeID,segmentIndex:t.segmentIndex,splineIndex:e,bounds:r.bounds,spline:new T(t.spline.layout,t.spline.points,t.spline.pointProps,i.getPointT(e),i.getPointT(e+1)),shapesPath:r,depth:tt.SegmentationDepth.SPLINE_SEGMENT}}buildShapeSegment(t,e,i,s){let r=s[t],n=r.bounds,o=i.getPointT(t),a=i.getPointT(t-1),l=i.getPointT(t+1);if(isNaN(a)&&(a=e.ts),isNaN(l)&&(l=e.tf),n.width!=n.height){let t=Math.max(n.width,n.height);n=new O(n.center.x-t/2,n.center.y-t/2,t,t)}return{shape:r,prevT:a,t:o,nextT:l,bounds:n}}buildPointSegment(t,e){let i=0==e?t.sPoint:t.fPoint;return{strokeID:t.strokeID,segmentIndex:t.segmentIndex,splineIndex:t.splineIndex,pointIndex:e,spline:t.spline,bounds:i.bounds,prevT:i.prevT,t:i.t,nextT:i.nextT,shape:i.shape,depth:tt.SegmentationDepth.SHAPE}}buildPointSegment2(t,e,i,s){let r=this.buildShapeSegment(e,t.spline,i,s);return{strokeID:t.strokeID,segmentIndex:t.segmentIndex,splineIndex:t.splineIndex,pointIndex:e,spline:t.spline,bounds:r.bounds,prevT:r.prevT,t:r.t,nextT:r.nextT,shape:r.shape,depth:tt.SegmentationDepth.SHAPE}}createIntervals(t,e){let i={intersected:{},selected:[]};if(0==e.length)return i;let s=this.holesBuilder.build(this.context,t instanceof Set?Array.from(t):t,e);for(let t in s){let r=s[t],n=this.context.getNodes(t),o=[],a=[];i.intersected[t]={intervals:o,holes:a};for(let s of r){let l,h=0==s.fromPointIndex&&s.fromTValue==n.first.ts,u=s.toPointIndex==n.last.segmentIndex&&s.toTValue==n.last.tf;h&&u?(i.selected.push(t),delete i.intersected[t]):(a.push(s),this.context.tree.canvas&&this.context.tree.canvas.addOperation("drawIntersection",e,this.context.getNodes(s.strokeID).slice(s.fromNodeIndex,s.toNodeIndex+1)),h?l={fromPointIndex:s.toPointIndex,fromTValue:s.toTValue,fromNodeIndex:s.toNodeIndex}:u?(o.last||o.push({fromPointIndex:0,fromTValue:n.first.spline.ts,fromNodeIndex:0}),o.last.toPointIndex=s.fromPointIndex+3,o.last.toTValue=s.fromTValue,o.last.toNodeIndex=s.fromNodeIndex):o.last?(o.last.toPointIndex=s.fromPointIndex+3,o.last.toTValue=s.fromTValue,o.last.toNodeIndex=s.fromNodeIndex,l={fromPointIndex:s.toPointIndex,fromTValue:s.toTValue,fromNodeIndex:s.toNodeIndex}):(o.push({fromPointIndex:0,fromTValue:n.first.spline.ts,toPointIndex:s.fromPointIndex+3,toTValue:s.fromTValue,fromNodeIndex:0,toNodeIndex:s.fromNodeIndex}),l={fromPointIndex:s.toPointIndex,fromTValue:s.toTValue,fromNodeIndex:s.toNodeIndex}),l&&o.push(l),s!=r.last||u||(o.last.toPointIndex=n.last.segmentIndex+3,o.last.toTValue=n.last.spline.tf,o.last.toNodeIndex=n.length-1))}let l=[];for(let t of o){if(1==t.fromTValue){let e=n.filter((e=>e.segmentIndex==t.fromPointIndex+1)).first,i=n.filter((e=>e.segmentIndex==t.fromPointIndex));a.push({fromNodeIndex:i.first.nodeIndex||n.indexOf(i.first),toNodeIndex:i.last.nodeIndex||n.indexOf(i.last),type:"OVERLAPPING_INC"}),t.fromPointIndex++,t.fromTValue=0,t.fromNodeIndex=n.indexOf(e)}if(0==t.toTValue){let e=t.toPointIndex-3,i=n.filter((t=>t.segmentIndex==e-1)).last,s=n.filter((t=>t.segmentIndex==e));a.push({fromNodeIndex:s.first.nodeIndex||n.indexOf(s.first),toNodeIndex:s.last.nodeIndex||n.indexOf(s.last),type:"OVERLAPPING_DEC"}),t.toPointIndex--,t.toTValue=1,t.toNodeIndex=n.indexOf(i)}if(t.toPointIndex-t.fromPointIndex<3)l.push(t);else if(t.toPointIndex-t.fromPointIndex==3&&t.fromTValue>=t.toTValue){let e=n.filter((e=>e.segmentIndex==t.fromPointIndex));a.push({fromNodeIndex:e.first.nodeIndex||n.indexOf(e.first),toNodeIndex:e.last.nodeIndex||n.indexOf(e.last),type:"INVALID"}),l.push(t)}}o.remove(...l),0==o.length&&(i.selected.includes(t)||i.selected.push(t),delete i.intersected[t])}return i}reset(t){if(!t)throw new Error("Required spatial context not found");this.context=t,this.nodes=new Set,this.nodes2=[],this.context.tree.canvas&&this.context.tree.canvas.refresh()}}tt.SegmentationDepth={STROKE_BOUNDS:0,STROKE_SEGMENT:1,SPLINE_SEGMENT:2,CONVEX:3,SHAPE:4},Object.defineEnum(tt,"Mode",["WHOLE_STROKE","PARTIAL_STROKE"]);(class extends class{constructor(){this.worker,this.transferables=[]}async recieve(t){let e;"INIT"==t.action?(this.worker=t.worker,e=await this.init(t)):e=await this.process(t),e.worker=this.worker,this.send(e)}send(t){self.postMessage(t,this.transferables),this.transferables.length=0}async init(t){return t}async process(t){throw new Error("ThreadProcessor.process(message) is abstract and should be implemented")}static async connect(...t){let e=new this(...t);if("undefined"==typeof self){const t=await import("worker_threads"),{parentPort:e,workerData:i}=t;global.self=e,self.name=i.name,self.data=i}self.on("message",(async t=>await e.recieve(t)))}}{constructor(){super(),this.splines={},this.brushes={},this.brushAppliers={}}process(t){let e={action:t.action,actionID:t.actionID};switch(t.action){case"IMPORT_BRUSHES":this.importBrushes(t.brushes);break;case"IMPORT_SPLINE":this.importSpline(t.strokeID,t.spline);break;case"REMOVE_SPLINE":this.removeSpline(t.strokeID);break;case"BUILD_STROKE_SEGMENT":{let{strokeID:i,brushName:s,index:r}=t,n=this.buildStrokeSegment(i,r,s);e.bounds=n.bounds.toJSON(),e.spline=n.spline.toJSON(),e.depth=n.depth,n.spline.points.buffer instanceof ArrayBuffer&&this.transferables.push(n.spline.points.buffer),e.index=t.index;break}default:throw new Error(`Unknow data action found: ${t.action}`)}return e}importBrushes(t){for(let e of t)if(!this.brushes[e.name]){if("Brush2D"!=e.type)throw new Error("BrushGL is not supported");this.brushes[e.name]=G.fromJSON(e)}}importSpline(t,e){this.splines[t]||(this.splines[t]=T.fromJSON(e))}removeSpline(t){delete this.splines[t]}buildStrokeSegment(t,e,i){if(!this.splines[t])throw new Error(`Stroke spline ${t} expected. Import spline first.`);let s=this.brushAppliers[i];if(!s){let t=this.brushes[i];if(!t)throw new Error(`${i} expected. Import brushes first.`);s=new V(t),this.brushAppliers[t.name]=s}return tt.buildStrokeSegment(t,this.splines[t],e,s)}}).connect();
